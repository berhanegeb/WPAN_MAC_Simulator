/* Process model C form file: WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET.pr.c */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_pr_c [] = "MIL_3_Tfile_Hdr_ 150A 30A modeler 7 50DCA289 50DCA289 1 s-cwc-pc204 bgebreme 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/*
** $File : LR-WPAN Mac layer header
**
** EPON model in Opnet
** National Institute of Standards and Technology
**
** This model was developed at the National Institute of Standards
** and Technology by employees of the Federal Government in the course
** of their official duties. Pursuant to title 17 Section 105 of the
** United States Code this software is not subject to copyright
** protection and is in the public domain. This is an experimental
** system.  NIST assumes no responsibility whatsoever for its use by
** other parties, and makes no guarantees, expressed or implied,
** about its quality, reliability, or any other characteristic.
**
** We would appreciate acknowledgement if the model is used.
**
** NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION
** AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER
** RESULTING FROM THE USE OF THIS SOFTWARE.
**
** Primary Author:      O. Rebala
** Secondary Author:	N. Chevrollier
** Module description:  header file for Low Rate WPAN model
** Last Modification:   October, 1st 2003
**
*/

/* header include */
#include "lr_wpan_support_15_4a.h"
#include "channel_buffer.h"
#include "lr_wpan_stat_write.h"
#include <math.h>
#include "Physical_Layer.h"
/* include for the TCP/IP stack */
#include "oms_pr.h"
#include "oms_auto_addr_support.h"


/* Constant definitions */
#define HIGHER_LAYER_DOWN_STRM 0
#define HIGHER_LAYER_UP_STRM 0
#define LOWER_LAYER_UP_STRM 1
#define MAC_SUBQ	0
#define POWER_TRANS 0.001

#define CODE_BULK 10

/*defining the maximum length of Serv_time in slots*/
#define MAX_SERV_TIME 300

/*define GADGET simple moving average size*/
#define GADGET_SMA_SIZE 7
#define GADGET_SMA_LENGTH 3

/*define GADGET threshold set size*/
#define GADGET_THRESHOLD_SET 6

/*define protocol used value*/
#define GADGET_USE_S_ALOHA 0x0
#define GADGET_USE_PSMA 0x1

/* macro definition */
#ifndef min
#define min(a,b)	(a < b)?a:b
#endif

/* debugging Macro */
#define ENTER_STATE_ODB_PRINTING(a) if (STATE_PRINT_STATUS)\
	printf ("%s MAC layer (%d): %.9f s: %s\n",\
	lr_wpan_node_name, my_parameters->mac_address, op_sim_time (), a)

#define FLAG_ODB_PRINTING		if (FLAG_PRINT_STATUS)\
	printf ("%s MAC layer (%d): flag status:\n\t%s\n\t%s\n\t%s\n\t%s\n",\
	lr_wpan_node_name, my_parameters->mac_address,\
	(channel_flag.tx_idle)?"TX is idle":"TX is busy",\
	(channel_flag.rx_idle)?"RX is idle":"RX is busy",\
	(Rx_Ack_Expected)?"Acknowledge expected":"No expected Ack",\
	(Tx_Ack_Require)?"Ack has to be sent":"No Ack pending")

/* structure definition */

/* structure to create the MAC subqueues system */
typedef struct t_Wpan_Queue {
	List * subqueue;
	int mac_address;
	int size;
	int nb_element;
	struct t_Wpan_Queue * next;
} Wpan_Queue;

/* define the codes for the interruptions */
typedef enum {
	Backoff_Time_Out,				//0
	Data_Pkt_To_Send,				//1
	Ack_Time_Out,					//2
	Ack_Received,					//3
	Wpan_Ack_Tx_Required,			//4
	End_Of_Transmission,			//5
	CCA_Pkt_Detect,					//6
	Wpan_CCA_Time_Out,				//7
	Wpan_Rcv_Pkt,					//8
	Wpan_Rx_TAT,					//9
	Wpan_Tx_TAT,					//10
	Wpan_LIFS_Over,					//11
	Wpan_Beacon_To_Send,			//12
	Wpan_Data_Req_To_Send,			//13
		
		
	Wpan_Backoff_Period_Elapsed,	//14		//Backoff done before CCA rame transmission		
	Wpan_GTS_Period_End,			//15		/* End of the contention free period (GTS period)*/		
	Wpan_CAP_Period_End,			//16		/* End of the contention access period */		
	Wpan_Beacon_Tracking,			//17		/* Time to enable receiver for next beacon arrival  */
	//PSMA_TIME_TO_TX
		
	
} Wpan_Intrpt_Code;

#define Regular_packet			59	
#define	Emergency_packet		57
#define end_of_backoff			58
#define No_data_inBackoff_queue	60

/* define some code for TX and RX */
typedef enum {
	RX_CODE,
	TX_CODE,
	TXRX_CODE
} TxRx_Management;

/* define a statistic vector */
typedef struct {
	int Data_Pkt_Rcv;
	int	Data_Pkt_Rcv_emergency;
	int Segment_generated;
	int Data_Pkt_Sent;
	int Data_Req_Send;
	int Ack_Pkt_Rcv;
	int Ack_Pkt_Sent;
	int Pkt_Lost;
	int Pkt_Collided;
	int Pkt_Noise;
	int Pkt_Dropped; //because CSMA failed or because max number of transmission retries reached
	int Pkt_Dropped_CCA; //because CCA failed
	int Pkt_Dropped_retx; //because max number of transmission retries reached
	int Segment_Dropped;
	int Retransmission;
	int Nb_Time_Out;
	double total_backoff_time;
	int	total_backoff;
	double Total_MAC_Delay;
	double Total_MAC_Delay_emergency;
	int tcp_HL_pkt_sent;
	int tcp_HL_bit_sent;
	int tcp_HL_pkt_rcvd;
	int tcp_HL_bit_rcvd;
	
	int Beacon_Frame_Sent;
	int Beacon_Frame_Rcv;
	int	Beacon_Frame_Collided;
	int Beacon_Frame_Noise;
	int Beacon_Frame_Lost;

} Wpan_Stat_Vector;

Wpan_Stat_Vector Wpan_Superframe_Statistics;

/* define a statistic vector */
typedef struct {
	int Segments_Bits_Generated;
	int Data_Bits_Sent; 
	int Data_Bits_Correctly_Sent; //ACKs were reveived
	double Data_Delay;
	
} Wpan_Node_Stat;



   /* define CCA statistics vector */
typedef struct {

	int First_CCA_count;
	int First_CCA_Success_Count;
	int First_CCA_Failure_Count;

	int Second_CCA_count;
	int Second_CCA_Success_Count;
	int Second_CCA_Failure_Count;

	int Total_CCA_Count;
	int Total_CCA_Success_Count;
	} Wpan_CCA_Vector;

Wpan_CCA_Vector Global_CCA_Statistics;


Wpan_CCA_Vector Superframe_CCA_Statistics;


/* define a global statistic vector */
typedef struct {
	int Data_Pkt_Rcv; 
	int	Data_Pkt_Rcv_emergency;
	int Segment_generated; //number of MPDUs accepted to the MAC queue
	int Data_Pkt_Sent;
	int	Data_Pkt_Sent_emergency;
	int Data_Req_Send;
	int Ack_Pkt_Rcv;
	int Ack_Pkt_Sent;
	int Pkt_Lost;
	int Pkt_Collided;
	int Pkt_Noise;
	int Pkt_Dropped; //because CSMA failed or because max number of transmission retries reached
	int Pkt_Dropped_CCA; //because CCA failed
	int Pkt_Dropped_retx; //because max number of transmission retries reached
	int Segment_Dropped;
	int Retransmission;
	int Retransmission_emergency;
	int Total_Bits_Rcv;
	int Total_number_backoff_slots; //statistic to gather the total amount of backoff slots from all nodes
	int	Total_number_backoff_slots_emergency;
	int Total_Ack_not_rcv; //statistic to gather the total amount of maxMacAckWaitTime  from all nodes
	int Total_backoff_wait_for_beacon; //statistic to gather the total amount of beacons received during backoff
	double Total_Delay_Dropped_packets; //statistic to gather the total delay of dropped packets (time interval between generation of the packet and istant in which the packet is dropped)
	int Pkt_not_enqueued; //total number of packets which are not enqueued in MAC queue because there is already one packet being processed
	int Application_generated; //total number of packets generated by the application
	int	Application_generated_emergency;
	
} Global_Stat_Vector;
Global_Stat_Vector global_statistics;

Global_Stat_Vector superframe_statistics;

/* define the channel flag */
typedef struct {
	Boolean tx_idle;
	Boolean rx_idle;
	Boolean LIFS_on;
	Boolean data_is_sending;
} Wpan_Chan_Flag;

/* define the Data Rx Seqn */
typedef struct {
	int mac_address;
	int seqn;
} Mac_Data_Seqn;

/* define the backoff parameters */
typedef struct {
	int max_backoff; // maximum number of Backoff
	int nb_backoff; // current number of backoff
	int min_BE; // minimum backoff exponent
	int max_BE; // maximum backoff exponent
	int Be; // Backoff exponent
} Mac_CSMA_Param;


/* define the CSMA operation parameters */
typedef struct {
	Boolean		backoff_countdown_is_paused;
	int			pending_backoff_periods;
	Boolean 	evaluate_after_backoff;
	Boolean		CCA_evaluation_pending;
	Boolean		can_proceed;
	Boolean		wait_for_the_next_cap // this is used when an emergency packet access the channel when none of the CPAs are active and if one the PCAs start allocation beforeit finishes. so it has to pause tillthat PCA finsihes
	Boolean		wait_for_the_next_superframe;
} CSMA_Operation_Param;

typedef struct {
	double time;
	int transmissions;
		
} tx;

typedef struct {
	double time;
	int retransmissions;
		
} retx;

/* stack change struct */
typedef struct {
	double time;
	int s_aloha_status;
	int psma_status;
	double observed_traffic;
	double observed_snr;
} stack_change;


//List* list_tx_ptr_global;
//List* list_retx_ptr_global;
List* list_stack_change_ptr;
List* list_traffic_snr_ptr;

int    aBaseSlotDuration = 0;
int    aUnitBackoffPeriod = 0;
double LR_WPAN_BACKOFF_UNIT = 0.0;
double LR_WPAN_BACKOFF_PERIOD_DURATION = 0.0;

/*GADGET simple moving average vector*/
double GADGET_SMA_SNR_VECT[GADGET_SMA_SIZE] = {0.0};
double GADGET_SMA_TRAFFIC_VECT[GADGET_SMA_SIZE] = {0.0};

/*GADGET threshold point vector, must contain 0.0 as last element*/
double GADGET_THRESHOLD_VECT[GADGET_THRESHOLD_SET];

/*The protocol to be used before each threshold*/
/*each element is either GADGET_USE_S_ALOHA or GADGET_USE_PSMA*/
int GADGET_THRESHOLD_PROTOCOL[GADGET_THRESHOLD_SET]; 

/*Flush time recorder for GADGET*/
double GADGET_SMA_FLUSH_TIME = 0.0;
double GADGET_STABILITY_TIME = 120.0; //seconds

/*Superframe reporting counter*/
int superframe_reporting_counter = 0;
double superframe_time_counter = 0.0;
double single_superframe_time_counter = 0.0;
int GADGET_SUPERFRAME_TRAFFIC = 0;

/*File for debug information*/
FILE* fp_debug;
char file_name[100] = "C:\\Users\\bgebreme\\op_reports\\Simulation.txt";

FILE* fp_service_time;
char file_service_time[100] = "C:\\Users\\bgebreme\\op_reports\\";
char service_name[100] = "service_time.txt";

/*service time statistics*/
long int frame_service_time[MAX_SERV_TIME];


/* state machine conditions */
#define		SLOTTED_CONDITION		((my_parameters->master_enable && lr_wpan_beacon_param.beacon_rcvd) ||\
									 (!my_parameters->master_enable && lr_wpan_beacon_param.data_requested))
#define		UNSLOTTED_CONDITION		(my_parameters->slotted_enable == OPC_FALSE)
#define		READY_TO_SEND			(!channel_flag.LIFS_on && wpan_transmission_required)

/*#define		PACKET_TO_SEND 			((INTRPT_SELF && (READY_TO_SEND || intrpt_code == Wpan_Data_Req_To_Send)) &&\
									((!my_parameters->slotted_enable) || ((my_parameters->slotted_enable == OPC_TRUE) &&\
									(sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE))))*/

/*#define PACKET_TO_SEND	(LECIM_enable)?(a):(b)*/

#define PACKET_TO_SEND				(LECIM_enable)?(((INTRPT_SELF && (READY_TO_SEND || intrpt_code == Wpan_Data_Req_To_Send)) &&\
									((!my_attributes.slotted_enable) || ((my_attributes.slotted_enable == OPC_TRUE) &&\
									((sf_param.CPA1_ACTIVE == OPC_FALSE||sf_param.CPA2_ACTIVE == OPC_FALSE ||sf_param.CPA3_ACTIVE == OPC_FALSE||sf_param.CPA4_ACTIVE == OPC_FALSE) &&\
									(sf_param.CAP1_ACTIVE == OPC_TRUE || sf_param.CAP2_ACTIVE == OPC_TRUE || sf_param.CAP3_ACTIVE == OPC_TRUE || sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE)))) &&\
									(REGULAR_TYPE == OPC_TRUE))):(((INTRPT_SELF && (READY_TO_SEND || intrpt_code == Wpan_Data_Req_To_Send)) &&\
									((!my_parameters->slotted_enable) || ((my_parameters->slotted_enable == OPC_TRUE) &&\
									(sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE)))))

/*#define		PACKET_TO_SEND 			((INTRPT_SELF && (READY_TO_SEND || intrpt_code == Wpan_Data_Req_To_Send)) &&\
									((!my_attributes.slotted_enable) || ((my_attributes.slotted_enable == OPC_TRUE) &&\
									((sf_param.CPA1_ACTIVE == OPC_FALSE||sf_param.CPA2_ACTIVE == OPC_FALSE ||sf_param.CPA3_ACTIVE == OPC_FALSE||sf_param.CPA4_ACTIVE == OPC_FALSE) &&\
									(sf_param.CAP1_ACTIVE == OPC_TRUE || sf_param.CAP2_ACTIVE == OPC_TRUE || sf_param.CAP3_ACTIVE == OPC_TRUE || sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE)))) &&\
									(REGULAR_TYPE == OPC_TRUE))*/
									
#define		EMERGENCY_PACKET_TO_SEND 			((INTRPT_SELF && (READY_TO_SEND || intrpt_code == Wpan_Data_Req_To_Send)) &&\
												((!my_attributes.slotted_enable) || ((my_attributes.slotted_enable == OPC_TRUE) &&\
												(((sf_param.CPA1_ACTIVE == OPC_TRUE||sf_param.CPA2_ACTIVE == OPC_TRUE ||sf_param.CAP3_ACTIVE == OPC_TRUE||sf_param.CPA4_ACTIVE == OPC_TRUE) &&\
												(sf_param.CAP1_ACTIVE == OPC_FALSE||sf_param.CAP2_ACTIVE == OPC_FALSE ||sf_param.CAP3_ACTIVE == OPC_FALSE||sf_param.CAP_PERIOD_ACTIVE == OPC_FALSE))||\
												((sf_param.CPA1_ACTIVE == OPC_FALSE||sf_param.CPA2_ACTIVE == OPC_FALSE ||sf_param.CPA3_ACTIVE == OPC_FALSE||sf_param.CPA4_ACTIVE == OPC_FALSE) &&\
												((sf_param.CAP1_ACTIVE == OPC_TRUE || sf_param.CAP2_ACTIVE == OPC_TRUE || sf_param.CAP3_ACTIVE == OPC_TRUE || sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE))))))&&\
												(EMERGENCY_TYPE == OPC_TRUE))
//#define		EMERGENCY_PACKET		((op_intrpt_type ()== OPC_INTRPT_SELF) && (op_intrpt_code () == Emergency_packet))

/*#define 	BACKOFF_EXPIRED			(LECIM_enable)?(a):(b)*/
#define 	BACKOFF_EXPIRED			(LECIM_enable)?(((INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									((!my_parameters->slotted_enable) || ((my_parameters->slotted_enable == OPC_TRUE) &&\
									(csma_operation_param.wait_for_the_next_cap == OPC_FALSE && csma_operation_param.wait_for_the_next_superframe == OPC_FALSE))))):(((INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									((!my_parameters->slotted_enable) || ((my_parameters->slotted_enable == OPC_TRUE) && (csma_operation_param.wait_for_the_next_superframe == OPC_FALSE)))))


/*#define 	BACKOFF_EXPIRED			((INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									((!my_parameters->slotted_enable) || ((my_parameters->slotted_enable == OPC_TRUE) &&\
									(csma_operation_param.wait_for_the_next_cap == OPC_FALSE && csma_operation_param.wait_for_the_next_superframe == OPC_FALSE))))
*/


/*#define 	BACKOFF_TO_IDLE			( (my_parameters->slotted_enable == OPC_TRUE) && (INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									(csma_operation_param.wait_for_the_next_cap == OPC_TRUE || csma_operation_param.wait_for_the_next_superframe == OPC_TRUE))*/
/*#define 	BACKOFF_EXPIRED			(LECIM_enable)?(a):(b)*/

#define 	BACKOFF_TO_IDLE 		(LECIM_enable)?(((my_parameters->slotted_enable == OPC_TRUE) && (INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									(csma_operation_param.wait_for_the_next_cap == OPC_TRUE || csma_operation_param.wait_for_the_next_superframe == OPC_TRUE))):(( (my_parameters->slotted_enable == OPC_TRUE) && (INTRPT_SELF && intrpt_code == Backoff_Time_Out) &&\
									(csma_operation_param.wait_for_the_next_superframe == OPC_TRUE)))

#define		CCA_EXPIRED				(INTRPT_SELF && intrpt_code == Wpan_CCA_Time_Out)

#define		TRANSMISSION_OK			(channel_is_idle && END_OF_CCA) 
#define		TRANSMISSION_NOT_OK		(!channel_is_idle) /* && !SECOND_CCA_REQ ) || (!channel_is_idle && SECOND_CCA_REQ)) */



#define		BACK_TO_BACKOFF			(CCA_EXPIRED && !channel_is_idle && csma_parameters.nb_backoff <= csma_parameters.max_backoff)

#define		END_OF_CCA				(CCA_EXPIRED && (channel_is_idle || csma_parameters.nb_backoff > csma_parameters.max_backoff))


#define		BACK_TO_IDLE			(INTRPT_SELF && (intrpt_code == Ack_Time_Out || intrpt_code == Ack_Received))
#define		END_OF_TRANSMISSION		(channel_flag.data_is_sending && INTRPT_SELF && intrpt_code == End_Of_Transmission)
#define		ACKNOWLEDGEMENT			(END_OF_TRANSMISSION && Rx_Ack_Expected)
#define		NO_ACK					(END_OF_TRANSMISSION && !Rx_Ack_Expected)

#define		TAT						(psma_enabled && !Tx_Ack_Require && !Rx_Ack_Expected && !END_OF_TRANSMISSION && !psma_time_to_tx)

#define 	PSMA_TX_NOW   	            (INTRPT_SELF && intrpt_code == Wpan_Backoff_Period_Elapsed && channel_is_idle && psma_time_to_tx)

#define 	S_ALOHA_BACKOFF_EXPIRED		(s_aloha_enabled && BACKOFF_EXPIRED)
	
#define 	PSMA_BACKOFF_EXPIRED	    (psma_enabled && BACKOFF_EXPIRED)

/* function prototypes */
static void 		lr_wpan_mac_init (void);
static void			lr_wpan_model_wide_register (void);
static void 		lr_wpan_mac_address_resolve (void);
static void			lr_wpan_schedule_TAT (TxRx_Management code);
static void			lr_wpan_cancel_TAT (TxRx_Management code);
static void			lr_wpan_cca_init (void);
static void 		lr_wpan_mac_backoff (void);
static void 		lr_wpan_intrpt_check (const char * state_name);
static void			lr_wpan_generate_beacon (void);
static void			lr_wpan_generate_data_request (void);
static void 		higher_layer_pkt_recv (void);
static void 		lower_layer_pkt_rcv (void);
static void			unacknowledgement_reset (void);
static void 		lr_wpan_packet_to_transmit (void);
static void			lr_wpan_ack_to_transmit (void);
static void 		lr_wpan_debug_state_msg (const char * state_name, Boolean exit);
static void			lr_wpan_drop_higher_layer_pkt (void);
static int			lr_wpan_destroy_retransmission (void);
static void 		lr_wpan_print_queue (void);
static int			lr_wpan_get_beacon_size (Addressing_Field * address);
static void 		lr_wpan_enqueue_packet (int mac_address, Packet * pkptr);
static Wpan_Queue * lr_wpan_allocate_subqueue (int mac_address, Packet * pkptr);
//static void		lr_wpan_subq_allocation (void);
static void			lr_wpan_subq_checking (void);
static int 			lr_wpan_get_rx_seqn (int mac_address);
static void 		lr_wpan_set_rx_seqn (int mac_address, int seqn);

static void 		lr_wpan_collect_stat (void);
static void  		lr_wpan_collect_performance_info1 ();
static void  		lr_wpan_collect_performance_info2 ();
static void 		lr_wpan_collect_stat_nodes (void);
static void 		lr_wpan_collect_stat_global (void);

static void			lr_wpan_process_rcvd_beacon_frame (Packet * wpan_rcvd_frame_ptr);
static Boolean 		lr_wpan_csma_can_proceed (void);
static int 			lr_wpan_get_tx_packet_size (void);
static void 		lr_wpan_cca_evaluation(void);
static double 		lr_wpan_locate_backoff_period_boundary(void);

static double 		lr_wpan_slotted_boundary_time (void);

static double		lr_wpan_slotted_boundary_time_modified (void);
static void 		lr_wpan_cca_failure (void);
static void 		lr_wpan_cca2_success (void);

static void 		lr_wpan_ack_not_received(void);
static void 		lr_wpan_reset_backoff_parameters(void);

static void 		s_aloha_set_flags(void);

static void 		update_retransmissions_list();
static void 		update_transmissions_list();



/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	int	                    		intrpt_type                                     ;	/* type of current interruption */
	int	                    		intrpt_stream                                   ;	/* stream of current interruption */
	int	                    		intrpt_code                                     ;	/* code of current interruption */
	Mac_CSMA_Param	         		csma_parameters                                 ;	/* CSMA CA parameters */
	Boolean	                		channel_is_idle                                 ;	/* flag to perform the CCA */
	Wpan_Node_Param *	      		my_parameters                                   ;	/* Parameters of the node */
	double	                 		wpan_frequency_center                           ;	/* Frequency used by the device */
	char *	                 		lr_wpan_node_name                               ;	/* Name of the WPAN node */
	Wpan_Queue *	           		wpan_queue                                      ;	/* MAC queue to store the packet from the higher layer */
	Stathandle	             		nb_pkt_subq                                     ;	/* Number of packet in the subqueue */
	Stathandle	             		nb_pkt_recv                                     ;	/* Number of packet received */
	Stathandle	             		nb_pkt_send                                     ;	/* Number of packet send */
	Packet *	               		retransmission_ptr                              ;	/* Copy of the current packet to transmit for retransmission */
	List *	                 		Mac_Data_Rx_Seqn                                ;	/* Data sequence number (DSN) defined in the IEEE 802.15.4 */
	Boolean	                		Rx_Ack_Expected                                 ;	/* flag to know whether we are waiting for an acknowledgment */
	Boolean	                		Tx_Ack_Require                                  ;	/* flag to know whether we have to send an acknowledgment */
	Evhandle	               		Ack_TimeOut_Evhandle                            ;	/* Handle for the interruption of the acknowledgment time out */
	int	                    		Mac_Data_Tx_Seqn                                ;	/* Data sequence number (DSN) defined in the IEEE 802.15.4 */
	int	                    		Ack_Dest_Addr                                   ;	/* Destination address of the acknowledgment */
	Wpan_Chan_Flag	         		channel_flag                                    ;	/* Flag for the TX/RX channel */
	Wpan_Stat_Vector	       		statistic                                       ;	/* Vector of all the collected statistics */
	Boolean	                		bulk_data_source                                ;	/* Flag to know whether the source of packet is a simple source or not */
	Evhandle	               		TAT_TX_Evhandle                                 ;	/* Handle for the interruption of the turn around time of the TX */
	Evhandle	               		TAT_RX_Evhandle                                 ;	/* Handle for the interruption of the turn around time of the RX */
	Boolean	                		wpan_transmission_required                      ;	/* Indicate that some packets need to be transmitted */
	Wpan_Queue *	           		current_queue                                   ;	/* mark the queue using to send the packets */
	int	                    		max_frame_retries                               ;	/* Number of maximum transmission retries */
	int	                    		nb_transmission_retries                         ;	/* Number of current transmission retries */
	OmsT_Pr_Handle	         		own_process_record_handle                       ;	/* Used to record the MAC process in the model wide registry */
	OmsT_Aa_Address_Handle	 		oms_aa_handle                                   ;	/* Used to resolve the MAC address */
	Boolean	                		Acknowledgement_Enable                          ;	/* Used to make the acknowledgement or not in the transmission */
	Wpan_Beacon_Param	      		lr_wpan_beacon_param                            ;	/* Beacon Parameters */
	int	                    		Mac_Beacon_Tx_Seqn                              ;	/* Beacon sequence number (BSN) defined in the IEEE 802.15.4 */
	Wpan_Superframe_Param	  		sf_param                                        ;
	Superframe_Spec_Field	  		sf_spec                                         ;
	double	                 		beacon_interval_time                            ;
	Evhandle	               		Wpan_CAP_Period_End_evh                         ;
	CSMA_Operation_Param	   		csma_operation_param                            ;
	int	                    		can_proceed_index                               ;
	int	                    		DEBUG_BEACON_RCVD                               ;
	char *	                 		lr_wpan_scenario                                ;
	int	                    		group_number                                    ;
	Wpan_CCA_Vector	        		CCA_statistic                                   ;
	int	                    		CCA_stage                                       ;
	int	                    		last_transmitted_pkt_size                       ;
	double	                 		last_tx_pkt_time_generation                     ;
	Wpan_Node_Stat	         		node_statistics                                 ;
	Boolean	                		DEBUG_Tx_Beacon                                 ;
	Boolean	                		DEBUG_MAC_Application                           ;
	Boolean	                		DEBUG_Data_Tx                                   ;
	Boolean	                		DEBUG_Rx_Data                                   ;
	Boolean	                		DEBUG_Idle_State                                ;
	Boolean	                		DEBUG_Tx_Ack                                    ;
	Boolean	                		DEBUG_Rx_Ack                                    ;
	Boolean	                		DEBUG_State                                     ;
	Boolean	                		DEBUG_Backoff                                   ;
	Boolean	                		psma_enabled                                    ;
	Boolean	                		s_aloha_enabled                                 ;
	Boolean	                		psma_time_to_tx                                 ;
	Boolean	                		DEBUG_test                                      ;
	Stathandle	             		nb_ack_stat_handle                              ;
	Stathandle	             		BE_handle                                       ;
	Stathandle	             		backoff_interval_handle                         ;
	Stathandle	             		cca_stat_handle                                 ;
	List *	                 		statistic_retx_list_ptr                         ;
	int	                    		aloha_cw                                        ;
	List *	                 		statistic_tx_list_ptr                           ;
	Boolean	                		ideal_poisson_traffic                           ;
	Boolean	                		GADGET_enabled                                  ;
	double	                 		GADGET_snr                                      ;
	int	                    		GADGET_pkt_per_superframe                       ;
	double	                 		GADGET_sma_snr                                  ;
	double	                 		GADGET_sma_traffic                              ;
	int	                    		GADGET_sma_counter                              ;
	Boolean	                		lecim_enabled                                   ;
	Boolean	                		pca_used_enabled                                ;
	int	                    		data_rate                                       ;
	Boolean	                		pca_allocation_super_rate_enabled               ;
	double	                 		delay_tolerance                                 ;
	int	                    		lecim_aloha_unit_backoff_periods_per_pca        ;
	int	                    		lecim_channel_number                            ;
	} WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state;

#define intrpt_type             		op_sv_ptr->intrpt_type
#define intrpt_stream           		op_sv_ptr->intrpt_stream
#define intrpt_code             		op_sv_ptr->intrpt_code
#define csma_parameters         		op_sv_ptr->csma_parameters
#define channel_is_idle         		op_sv_ptr->channel_is_idle
#define my_parameters           		op_sv_ptr->my_parameters
#define wpan_frequency_center   		op_sv_ptr->wpan_frequency_center
#define lr_wpan_node_name       		op_sv_ptr->lr_wpan_node_name
#define wpan_queue              		op_sv_ptr->wpan_queue
#define nb_pkt_subq             		op_sv_ptr->nb_pkt_subq
#define nb_pkt_recv             		op_sv_ptr->nb_pkt_recv
#define nb_pkt_send             		op_sv_ptr->nb_pkt_send
#define retransmission_ptr      		op_sv_ptr->retransmission_ptr
#define Mac_Data_Rx_Seqn        		op_sv_ptr->Mac_Data_Rx_Seqn
#define Rx_Ack_Expected         		op_sv_ptr->Rx_Ack_Expected
#define Tx_Ack_Require          		op_sv_ptr->Tx_Ack_Require
#define Ack_TimeOut_Evhandle    		op_sv_ptr->Ack_TimeOut_Evhandle
#define Mac_Data_Tx_Seqn        		op_sv_ptr->Mac_Data_Tx_Seqn
#define Ack_Dest_Addr           		op_sv_ptr->Ack_Dest_Addr
#define channel_flag            		op_sv_ptr->channel_flag
#define statistic               		op_sv_ptr->statistic
#define bulk_data_source        		op_sv_ptr->bulk_data_source
#define TAT_TX_Evhandle         		op_sv_ptr->TAT_TX_Evhandle
#define TAT_RX_Evhandle         		op_sv_ptr->TAT_RX_Evhandle
#define wpan_transmission_required		op_sv_ptr->wpan_transmission_required
#define current_queue           		op_sv_ptr->current_queue
#define max_frame_retries       		op_sv_ptr->max_frame_retries
#define nb_transmission_retries 		op_sv_ptr->nb_transmission_retries
#define own_process_record_handle		op_sv_ptr->own_process_record_handle
#define oms_aa_handle           		op_sv_ptr->oms_aa_handle
#define Acknowledgement_Enable  		op_sv_ptr->Acknowledgement_Enable
#define lr_wpan_beacon_param    		op_sv_ptr->lr_wpan_beacon_param
#define Mac_Beacon_Tx_Seqn      		op_sv_ptr->Mac_Beacon_Tx_Seqn
#define sf_param                		op_sv_ptr->sf_param
#define sf_spec                 		op_sv_ptr->sf_spec
#define beacon_interval_time    		op_sv_ptr->beacon_interval_time
#define Wpan_CAP_Period_End_evh 		op_sv_ptr->Wpan_CAP_Period_End_evh
#define csma_operation_param    		op_sv_ptr->csma_operation_param
#define can_proceed_index       		op_sv_ptr->can_proceed_index
#define DEBUG_BEACON_RCVD       		op_sv_ptr->DEBUG_BEACON_RCVD
#define lr_wpan_scenario        		op_sv_ptr->lr_wpan_scenario
#define group_number            		op_sv_ptr->group_number
#define CCA_statistic           		op_sv_ptr->CCA_statistic
#define CCA_stage               		op_sv_ptr->CCA_stage
#define last_transmitted_pkt_size		op_sv_ptr->last_transmitted_pkt_size
#define last_tx_pkt_time_generation		op_sv_ptr->last_tx_pkt_time_generation
#define node_statistics         		op_sv_ptr->node_statistics
#define DEBUG_Tx_Beacon         		op_sv_ptr->DEBUG_Tx_Beacon
#define DEBUG_MAC_Application   		op_sv_ptr->DEBUG_MAC_Application
#define DEBUG_Data_Tx           		op_sv_ptr->DEBUG_Data_Tx
#define DEBUG_Rx_Data           		op_sv_ptr->DEBUG_Rx_Data
#define DEBUG_Idle_State        		op_sv_ptr->DEBUG_Idle_State
#define DEBUG_Tx_Ack            		op_sv_ptr->DEBUG_Tx_Ack
#define DEBUG_Rx_Ack            		op_sv_ptr->DEBUG_Rx_Ack
#define DEBUG_State             		op_sv_ptr->DEBUG_State
#define DEBUG_Backoff           		op_sv_ptr->DEBUG_Backoff
#define psma_enabled            		op_sv_ptr->psma_enabled
#define s_aloha_enabled         		op_sv_ptr->s_aloha_enabled
#define psma_time_to_tx         		op_sv_ptr->psma_time_to_tx
#define DEBUG_test              		op_sv_ptr->DEBUG_test
#define nb_ack_stat_handle      		op_sv_ptr->nb_ack_stat_handle
#define BE_handle               		op_sv_ptr->BE_handle
#define backoff_interval_handle 		op_sv_ptr->backoff_interval_handle
#define cca_stat_handle         		op_sv_ptr->cca_stat_handle
#define statistic_retx_list_ptr 		op_sv_ptr->statistic_retx_list_ptr
#define aloha_cw                		op_sv_ptr->aloha_cw
#define statistic_tx_list_ptr   		op_sv_ptr->statistic_tx_list_ptr
#define ideal_poisson_traffic   		op_sv_ptr->ideal_poisson_traffic
#define GADGET_enabled          		op_sv_ptr->GADGET_enabled
#define GADGET_snr              		op_sv_ptr->GADGET_snr
#define GADGET_pkt_per_superframe		op_sv_ptr->GADGET_pkt_per_superframe
#define GADGET_sma_snr          		op_sv_ptr->GADGET_sma_snr
#define GADGET_sma_traffic      		op_sv_ptr->GADGET_sma_traffic
#define GADGET_sma_counter      		op_sv_ptr->GADGET_sma_counter
#define lecim_enabled           		op_sv_ptr->lecim_enabled
#define pca_used_enabled        		op_sv_ptr->pca_used_enabled
#define data_rate               		op_sv_ptr->data_rate
#define pca_allocation_super_rate_enabled		op_sv_ptr->pca_allocation_super_rate_enabled
#define delay_tolerance         		op_sv_ptr->delay_tolerance
#define lecim_aloha_unit_backoff_periods_per_pca		op_sv_ptr->lecim_aloha_unit_backoff_periods_per_pca
#define lecim_channel_number    		op_sv_ptr->lecim_channel_number

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/*
 * Function:	lr_wpan_init
 *
 * Description:	initialize the process
 *				read the attributes and set the global variables
 *
 * No parameters
 */

static void lr_wpan_mac_init ()
{
	Objid csma_parameters_comp_id;
	Objid csma_parameters_id;
	int mac_address, index_wpan;
	int channel_number;
	char buffer[64];
	char proc_model_name[64];
	char scenario_buffer[64];
	
	char error_message[256];
	Wpan_Node_Param * element;
	
	Objid superframe_parameters_comp_id;
	Objid superframe_parameters_id;
	
	Objid for_lecim_comp_id;
	Objid for_lecim_id;
	
	int k ;
	int h= 0;
	char dev_number[6];
	
		
	FIN (lr_wpan_mac_init ());
	
	
	/* memory allocation */
	my_parameters	= (Wpan_Node_Param *) op_prg_mem_alloc (sizeof (Wpan_Node_Param));
	
	/* initialize the wpan queue to NULL */
	wpan_queue = NULL;
	current_queue = NULL;
	
	/* set the type of the node */
	strcpy (my_parameters->type, "wpan");
	
	/* get the ID of this module */
	my_parameters->objid = op_id_self ();
	
	

	/* get the ID of the node */
	my_parameters->parent_id = op_topo_parent (my_parameters->objid);

	/* get the channel number */
	op_ima_obj_attr_get (my_parameters->objid, "Channel", &channel_number);
		
	
	/* get the power of the transmission */
	op_ima_obj_attr_get (my_parameters->objid, "Power", &my_parameters->power);
	
	/* compute the center frequency for the channel selected */
	wpan_frequency_center = compute_center_frequency (channel_number);
	my_parameters->frequency_wpan = wpan_frequency_center;
	
	/* get the type of source */
	op_ima_obj_attr_get (my_parameters->objid, "Source Type", &bulk_data_source);
	
	/* get the Acknowledgemnent attribute */
	op_ima_obj_attr_get (my_parameters->objid, "Acknowledgement", &Acknowledgement_Enable);
	
	/* get the Channel Access attribute */
	op_ima_obj_attr_get (my_parameters->objid, "Channel Access", &my_parameters->slotted_enable);
	op_ima_obj_attr_get (my_parameters->objid, "Mode", &my_parameters->master_enable);
	
	/* get the CSMA-CA settings */
	op_ima_obj_attr_get (my_parameters->objid, "CSMA-CA Parameters", &csma_parameters_id);
	csma_parameters_comp_id = op_topo_child (csma_parameters_id, OPC_OBJTYPE_GENERIC, 0);
	
	op_ima_obj_attr_get (csma_parameters_comp_id, "Maximum backoff number", &csma_parameters.max_backoff);
	op_ima_obj_attr_get (csma_parameters_comp_id, "Minimum backoff exponent", &csma_parameters.min_BE);
	op_ima_obj_attr_get (csma_parameters_comp_id, "Maximum backoff exponent", &csma_parameters.max_BE);	
	
	/* get the maximum transmission retries */
	op_ima_obj_attr_get (my_parameters->objid, "Nb of transmission retries", &max_frame_retries);
	
	/* get the group number */
	op_ima_obj_attr_get (my_parameters->objid, "Group number", &my_parameters->group);
	
	/* get the position of the node */
	op_ima_obj_attr_get (my_parameters->parent_id, "x position", &my_parameters->x);
	op_ima_obj_attr_get (my_parameters->parent_id, "y position", &my_parameters->y);

	/* get the name of the node */
	op_ima_obj_attr_get_str (my_parameters->parent_id, "name", 64, buffer);
	
	
	
	/* get the simulation scenario */
	op_ima_obj_attr_get_str (my_parameters->objid, "Scenario", 64, scenario_buffer);
	lr_wpan_scenario = (char *) op_prg_mem_alloc ((strlen (scenario_buffer) + 1) * sizeof (char));
	strcpy (lr_wpan_scenario, scenario_buffer);
	printf("Scenario Name: %s\n",lr_wpan_scenario);
	
	
	/*MAC protocl*/
	op_ima_obj_attr_get (my_parameters->objid, "PSMA_Enabled", &psma_enabled);
	op_ima_obj_attr_get (my_parameters->objid, "S_Aloha_Enabled", &s_aloha_enabled);
	
	op_ima_obj_attr_get (my_parameters->objid, "LECIM_DSSS attribues", &for_lecim_id);
	csma_parameters_comp_id = op_topo_child (for_lecim_id, OPC_OBJTYPE_GENERIC, 0);
	
	op_ima_obj_attr_get (for_lecim_comp_id, "Lecim_DSSS_Enabled", &lecim_enabled);
	op_ima_obj_attr_get (for_lecim_comp_id, "PCA used", &pca_used_enabled);
	op_ima_obj_attr_get (for_lecim_comp_id, "PCA allocation super-rate Enabled", &pca_allocation_super_rate_enabled);
	op_ima_obj_attr_get (for_lecim_comp_id, "Critical message delay tolerance", &delay_tolerance);
	op_ima_obj_attr_get (for_lecim_comp_id, "Number of macLECIMAlohaUnitBackoffPeriod per PCA", &lecim_aloha_unit_backoff_periods_per_pca);
	op_ima_obj_attr_get (for_lecim_comp_id, "Channel for LECIM_DSSS", &lecim_channel_number);
	op_ima_obj_attr_get (for_lecim_comp_id, "Data rate", &data_rate);
	
	/*DEBUG flags*/
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_BEACON_RCVD", &DEBUG_BEACON_RCVD);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_TX_BEACON", &DEBUG_Tx_Beacon);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_MAC_APPLICATION", &DEBUG_MAC_Application);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_DATA_TX", &DEBUG_Data_Tx);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_RX_DATA", &DEBUG_Rx_Data);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_IDLE_STATE", &DEBUG_Idle_State);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_TX_ACK", &DEBUG_Tx_Ack);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_RX_ACK", &DEBUG_Rx_Ack);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_STATE", &DEBUG_State);
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_BACKOFF", &DEBUG_Backoff);
	
	op_ima_obj_attr_get (my_parameters->objid, "DEBUG_TEST", &DEBUG_test);
	
	op_ima_obj_attr_get (my_parameters->objid, "Ideal_Poisson_Traffic", &ideal_poisson_traffic);
	op_ima_obj_attr_get (my_parameters->objid, "GADGET_enabled", &GADGET_enabled);
	
	//create a file for printing debug informations
	if(DEBUG_test || DEBUG_BEACON_RCVD || DEBUG_Backoff || DEBUG_Tx_Beacon || DEBUG_State || DEBUG_Rx_Ack || DEBUG_Rx_Data || DEBUG_Data_Tx || DEBUG_Idle_State || DEBUG_MAC_Application)
		{
		fp_debug = fopen (file_name, "a");
		}
	
	
	
	
	
	lr_wpan_node_name = (char *) op_prg_mem_alloc ((strlen (buffer) + 1) * sizeof (char));
	strcpy (lr_wpan_node_name, buffer);
	
	
	if(!strcmp(lr_wpan_node_name, "coordinator"))
		printf("Coordinator ID from node init: %d\n", (int)my_parameters->objid);

	/* Determine the group number (beacon) of the device*/
	for(k=0; k <= strlen(lr_wpan_node_name); k++)
	{
		if(isdigit(lr_wpan_node_name[k]))
		{
			dev_number[h] = lr_wpan_node_name[k];
			h++;
		}
	}
	dev_number[h]='\0';
	if( (atoi(dev_number) % 2 ) == 0)
		group_number = 2;
	else  group_number = 1;


	/* get the name of the process model */
	op_ima_obj_attr_get (my_parameters->objid, "process model", proc_model_name);
	
	/* get the MAC address of the node */
	op_ima_obj_attr_get (my_parameters->objid, "Address", &mac_address);
	
	if (bulk_data_source)
		{
		/* check the MAC address */
		if (mac_address == -2)
			{
			/* if the mac address is "auto assigned" */
			mac_address = (int) my_parameters->objid;
			}
		else if (wpan_node_param_list != OPC_NIL)
			{
			/* 
			* if the MAC address was set by the user, we have to
			* check whether this address doesn't exist
			*/
			
			if ((index_wpan = wpan_search_mac_address (mac_address)) != -1)
				{
				/* get the element with the same MAC address */
				element = op_prg_list_access (wpan_node_param_list, index_wpan);
				
				/* get the name of this node */
				op_ima_obj_attr_get_str (op_topo_parent (element->objid), "name", 64, buffer);
				
				/* edit the error message */
				sprintf (error_message, "Check the MAC addresses of the nodes %s and %s", lr_wpan_node_name, buffer);
				lr_wpan_mac_error ("lr_wpan_init:", "The MAC address already exist.", error_message);
				}
			}
		}
	
	/* set the MAC address */
	my_parameters->mac_address = mac_address;
	
	/* initialize the CCA requirement */
	my_parameters->cca_requirement = OPC_FALSE;
	
	/* Set the WLAN field to NULL */
	my_parameters->wlan_info = NULL;
		
	/* initialize the node list if it is not done */
	if (wpan_node_param_list == OPC_NIL)
		wpan_node_param_list = op_prg_list_create ();
	
	/* register the node into the list */
	op_prg_list_insert (wpan_node_param_list, my_parameters, OPC_LISTPOS_TAIL);
	
	/* set the backoff parameters */
	csma_parameters.Be = csma_parameters.min_BE;
	csma_parameters.nb_backoff = 0;
		
	/* statistic initializations */
	nb_pkt_subq = op_stat_reg ("subqueues.Number of packets", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	nb_pkt_send = op_stat_reg ("mac.Packet sent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	nb_pkt_recv = op_stat_reg ("mac.Packet received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	nb_ack_stat_handle = op_stat_reg ("mac.Ack received", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	BE_handle = op_stat_reg ("mac.Backoff Exponent", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	backoff_interval_handle = op_stat_reg ("mac.Backoff Interval", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	cca_stat_handle = op_stat_reg ("mac.CCA Result", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	op_stat_write(BE_handle, csma_parameters.Be);
	op_stat_write(cca_stat_handle, OPC_TRUE);
	
	/* initialize variables */
	retransmission_ptr 				= OPC_NIL;
	Rx_Ack_Expected 				= OPC_FALSE;
	Tx_Ack_Require 					= OPC_FALSE;
	Mac_Data_Tx_Seqn 				= rand () % MAX_MAC_SEQN;
	Mac_Beacon_Tx_Seqn				= 0;
	Mac_Data_Rx_Seqn 				= op_prg_list_create ();
	channel_flag.tx_idle 			= OPC_TRUE;
	channel_flag.rx_idle 			= OPC_TRUE;
	channel_flag.LIFS_on 			= OPC_FALSE;
	channel_flag.data_is_sending	= OPC_FALSE;
	wpan_transmission_required 		= OPC_FALSE;
	nb_transmission_retries 		= 0;
	
	GADGET_snr						= 0.0;
	GADGET_pkt_per_superframe		= 0;
	GADGET_sma_counter				= 0;
	
	/* beacon variables */
	lr_wpan_beacon_param.stop_time		= 0.0;
	lr_wpan_beacon_param.nb_addresses 	= 0;
	lr_wpan_beacon_param.addr_table 	= NULL;
	lr_wpan_beacon_param.beacon_rcvd	= OPC_FALSE;
	lr_wpan_beacon_param.data_req_rcvd	= OPC_FALSE;
	/*lr_wpan_beacon_param.second_cca_req = OPC_FALSE;*/
	lr_wpan_beacon_param.master_addr 	= -1;
	lr_wpan_beacon_param.data_request 	= OPC_NIL;
	
		
	/* initialize the statistics */
	statistic.Data_Pkt_Rcv 		= 0;
	statistic.Segment_generated = 0;
	statistic.Data_Pkt_Sent 	= 0;
	statistic.Ack_Pkt_Rcv 		= 0;
	statistic.Ack_Pkt_Sent 		= 0;
	statistic.Pkt_Lost 			= 0;
	statistic.Pkt_Collided		= 0;
	statistic.Pkt_Noise			= 0;
	statistic.Pkt_Dropped		= 0;
	statistic.Pkt_Dropped_CCA	= 0;
	statistic.Pkt_Dropped_retx	= 0;
	statistic.Segment_Dropped	= 0;
	statistic.Retransmission 	= 0;
	statistic.Nb_Time_Out 		= 0;
	statistic.Total_MAC_Delay 	= 0.0;
	statistic.tcp_HL_pkt_sent	= 0;
	statistic.tcp_HL_bit_sent	= 0;
	statistic.tcp_HL_pkt_rcvd	= 0;
	statistic.tcp_HL_bit_rcvd	= 0;
	statistic.Data_Req_Send 	= 0;
	statistic.total_backoff		= 0;
	statistic.total_backoff_time= 0.0;
	
	statistic.Beacon_Frame_Sent	= 0;
	statistic.Beacon_Frame_Rcv	= 0;
	statistic.Beacon_Frame_Collided = 0;
	statistic.Beacon_Frame_Noise = 0;
	statistic.Beacon_Frame_Lost = 0;
	

	
	node_statistics.Data_Bits_Correctly_Sent 	= 0;
	node_statistics.Data_Delay 	= 0;
	node_statistics.Segments_Bits_Generated 	= 0;
	node_statistics.Data_Bits_Sent 	= 0;
	
	can_proceed_index = 0;
	
	statistic_tx_list_ptr = op_prg_list_create ();
	statistic_retx_list_ptr = op_prg_list_create ();
	
	
	
	/*compute some backoff parameters*/	
	if(Acknowledgement_Enable)
		{
		aBaseSlotDuration=2*PROPAGATION_DELAY+2*LR_WPAN_PHY_OVERHEAD+WPAN_HEADER_SIZE+WPAN_PAYLOAD_MAX_SIZE+aTurnaroundTime+macAckWaitDuration+ACK+aMinLIFSPeriod;
		}
	else
		{
		aBaseSlotDuration=LR_WPAN_PHY_OVERHEAD+WPAN_HEADER_SIZE+WPAN_PAYLOAD_MAX_SIZE+aMinLIFSPeriod;
		}
	
	if(psma_enabled)
		{
		psma_time_to_tx = OPC_FALSE;
				
		aUnitBackoffPeriod = aBaseSlotDuration/2;//symbols
				
		/* backoff time unit (in seconds) */
		LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
		LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
		}
		
		
	if(s_aloha_enabled)
		{
		aUnitBackoffPeriod = aBaseSlotDuration;//symbols
				
		/* backoff time unit (in seconds) */
		LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
		LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
		}
	
	op_ima_obj_attr_get (my_parameters->objid, "ALOHA_max_delay_retx", &aloha_cw);
	printf("%s: ALOHA_max_delay_retx = %d\n", lr_wpan_node_name, aloha_cw);
	
	/*initialize GADGET*/
	if (GADGET_enabled)
		{
		GADGET_THRESHOLD_PROTOCOL[0]=GADGET_USE_S_ALOHA;
		GADGET_THRESHOLD_PROTOCOL[1]=GADGET_USE_PSMA;
		GADGET_THRESHOLD_PROTOCOL[2]=GADGET_USE_S_ALOHA;
		GADGET_THRESHOLD_PROTOCOL[3]=GADGET_USE_PSMA;
		/*GADGET_THRESHOLD_VECT[0] = 0.17; //with channel and capture
		GADGET_THRESHOLD_VECT[1] = 1.3;
		GADGET_THRESHOLD_VECT[2] = 2.2;
		*/
		/*GADGET_THRESHOLD_VECT[0] = 0.075; //no channel no capture
		GADGET_THRESHOLD_VECT[1] = 0.79;
		GADGET_THRESHOLD_VECT[2] = 2.4;
		*/
		GADGET_THRESHOLD_VECT[0] = 0.075; //no channel no capture
		GADGET_THRESHOLD_VECT[1] = 0.7;
		GADGET_THRESHOLD_VECT[2] = 2.4;
		}
	
		
		
	
	/* Initialze the superframe parameters */

	sf_param.beacon_interval_symbols = 0;
	sf_param.beacon_interval_seconds = 0.0;
	sf_param.superframe_duration_symbols = 0;  
	sf_param.superframe_duration_seconds = 0.0;
	sf_param.superframe_start_time = 0.0;
	sf_param.inactive_period_symbols = 0;
	sf_param.inactive_period_seconds = 0.0;
	sf_param.slot_duration_symbols = 0;
	sf_param.slot_duration_seconds = 0.0;
	sf_param.backoff_periods_per_superframe = 0;
	sf_param.backoff_periods_per_CAP = 0;
	sf_param.backoff_periods_per_slot = 0;
	sf_param.backoff_periods_time_symbols = 0;
	sf_param.backoff_periods_time_seconds = 0;
	sf_param.backoff_period_index = 0;
	sf_param.time_slot_index = 0;
  	sf_param.CAP_period_length_symbols = 0;
 	sf_param.CAP_period_length_seconds = 0.0;
	
	sf_param.CAP_start_time = 0.0;
	sf_param.remaining_CAP_backoff_periods = 0;
	sf_param.end_of_the_CAP_period = 0.0;
	sf_param.GTS_period_length_symbols = 0;
	sf_param.GTS_period_length_seconds = 0.0;
	sf_param.remaining_GTS_backoff_periods = 0;
	sf_param.has_GTS_period = OPC_FALSE;
	sf_param.has_inactive_period = OPC_FALSE;
	sf_param.CAP_PERIOD_ACTIVE = OPC_FALSE;
	sf_param.CAP1_ACTIVE = OPC_FALSE;
	sf_param.CAP2_ACTIVE = OPC_FALSE;
	sf_param.CAP3_ACTIVE = OPC_FALSE;
	sf_param.CPA1_ACTIVE = OPC_FALSE;
    sf_param.CPA2_ACTIVE = OPC_FALSE;
	sf_param.CPA3_ACTIVE = OPC_FALSE;
	sf_param.CPA4_ACTIVE = OPC_FALSE;
	sf_param.GTS_PERIOD_ACTIVE = OPC_FALSE;
	sf_param.INACTIVE_PERIOD = OPC_FALSE;
	sf_param.backoff_period_boundary_symbols = NULL;
	sf_param.time_slot_boundary_symbols = NULL;
	
	
	sf_param.backoff_period_boundary_symbols = (int *) op_prg_mem_alloc (MAX_NUMBER_OF_BACKOFF_PERIODS * sizeof(int));
	sf_param.time_slot_boundary_symbols = (int *) op_prg_mem_alloc ((aNumSuperframeSlots+1)* sizeof(int));
	
	/* Initialize the superframe specification fields */
	sf_spec.beacon_order = 0;
	sf_spec.superframe_order = 0; 
	sf_spec.final_CAP_slot = 0;
	sf_spec.battery_life_ext;
	//int-Boolean reserved
	sf_spec.PAN_coordinator = OPC_FALSE;
	sf_spec.association_permit = OPC_FALSE;

	csma_operation_param.backoff_countdown_is_paused 	= OPC_FALSE;
	csma_operation_param.pending_backoff_periods		= 0;
	csma_operation_param.evaluate_after_backoff			= OPC_FALSE;
	csma_operation_param.CCA_evaluation_pending			= OPC_FALSE;
	csma_operation_param.can_proceed					= OPC_FALSE;
	csma_operation_param.wait_for_the_next_cap			= OPC_FALSE;
	csma_operation_param.wait_for_the_next_superframe 	= OPC_FALSE;
	
	/* print information about the node */
	
	printf ("+-----------------------------------------------\n");
	printf ("| MAC layer of the node %s:\n", lr_wpan_node_name);
	printf ("| \tPosition: (%.1f, %.1f)\n", my_parameters->x, my_parameters->y);
	printf ("| \tGroup: %d; MAC address: %s%d\n", my_parameters->group, (my_parameters->mac_address == -2)?"Auto Assigned, ":"", my_parameters->mac_address);
	printf ("| \tChannel: %d; Center frequency: %f\n", channel_number, wpan_frequency_center);
	printf ("| \tChannel Access: %s (%s)\n", (my_parameters->slotted_enable) ? "Slotted" : "Unslotted", (my_parameters->master_enable) ? "Master" : "Slave");
	printf ("| \tFirst TX Seqn: %d\n", Mac_Data_Tx_Seqn);
	printf ("| \tAcknowledgement: %s\n", Acknowledgement_Enable ? "On" : "Off");
	printf ("| Status:\n");
	printf ("| \tMaximum number of backoff:\t%d\n", csma_parameters.max_backoff);
	printf ("| \tMinimum backoff exponent:\t%d\n", csma_parameters.min_BE);
	printf ("| \tMaximum backoff exponent:\t%d\n", csma_parameters.max_BE);
	printf ("+-----------------------------------------------\n");
	
	
	/* get/initialize the superframe specification attributes */
	if(my_parameters->slotted_enable && my_parameters->master_enable)
		{
		op_ima_obj_attr_get (my_parameters->objid, "Superframe parameters", &superframe_parameters_id);
		superframe_parameters_comp_id = op_topo_child (superframe_parameters_id, OPC_OBJTYPE_GENERIC, 0);
		
		op_ima_obj_attr_get (superframe_parameters_comp_id, "Beacon order", &sf_spec.beacon_order);
		op_ima_obj_attr_get (superframe_parameters_comp_id, "Superframe order", &sf_spec.superframe_order);
		op_ima_obj_attr_get (superframe_parameters_comp_id, "Final CAP slot", &sf_spec.final_CAP_slot);
		sf_spec.battery_life_ext = 0;
		sf_spec.PAN_coordinator = 1;
		sf_spec.association_permit = 1 ;
		
		beacon_interval_time = aBaseSuperframeDuration*(pow(2, sf_spec.beacon_order))*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE; 
		
		
		printf("\n\n\n**************************************************************************************\n");
		printf("Beacon order = %d \n", sf_spec.beacon_order);
		printf("Superframe order = %d \n", sf_spec.superframe_order);
		printf("Final CAP slot = %d \n", sf_spec.final_CAP_slot);
		printf("The beacon_interval_time = %f \n\n", beacon_interval_time);
		printf("aBaseSlotDuration: %d symb\n", aBaseSlotDuration);
		printf("aUnitBackoffPeriod: %d\n", aUnitBackoffPeriod);
		printf("LR_WPAN_BACKOFF_UNIT: %f sec\n", LR_WPAN_BACKOFF_UNIT);
		printf("LR_WPAN_BACKOFF_PERIOD_DURATION: %f sec\n", LR_WPAN_BACKOFF_PERIOD_DURATION);
		printf("\n**************************************************************************************\n\n\n\n ");		
	
		// create a list to save informations about retransmissions
		//list_retx_ptr_global = op_prg_list_create ();
		//list_tx_ptr_global = op_prg_list_create ();
		if (GADGET_enabled)
			list_stack_change_ptr = op_prg_list_create ();

		}
		list_traffic_snr_ptr = op_prg_list_create ();
	
	if(!strcmp(lr_wpan_node_name, "coordinator"))
		{
		superframe_statistics.Data_Pkt_Sent = 0;
		superframe_statistics.Pkt_Dropped_CCA = 0;
		Superframe_CCA_Statistics.First_CCA_Failure_Count = 0;
		superframe_time_counter = op_sim_time ();
		
		Wpan_Superframe_Statistics.Data_Pkt_Rcv = statistic.Data_Pkt_Rcv;
		Wpan_Superframe_Statistics.Total_MAC_Delay = statistic.Total_MAC_Delay;
		superframe_statistics.Total_Delay_Dropped_packets = 0.0;
		superframe_statistics.Application_generated = 0;
		superframe_statistics.Segment_generated = 0;
		superframe_statistics.Pkt_not_enqueued = 0;
		superframe_statistics.Data_Pkt_Rcv = 0;
		superframe_statistics.Pkt_Dropped = 0;
		superframe_statistics.Pkt_Dropped_retx = 0;
		superframe_statistics.Retransmission = 0;
		superframe_statistics.Total_number_backoff_slots = 0;
		superframe_statistics.Total_backoff_wait_for_beacon = 0;
		Superframe_CCA_Statistics.First_CCA_count = 0;
		global_statistics.Total_Ack_not_rcv = 0;
		}
	

	FOUT;
}


/*
 * Function:	lr_wpan_model_wide_register
 *
 * Description:	initialize the MAC layer with the TCP/IP
 *				stack if any
 */

static void	lr_wpan_model_wide_register (void)
{
	Prohandle own_prohandle;
	char proc_model_name[64];
	
	FIN (lr_wpan_tcp_ip_init ());
	
	/* Obtain the process prohandle */
	own_prohandle = op_pro_self ();
	
	/* Obatin the name of the process */
	op_ima_obj_attr_get (my_parameters->objid, "process model", proc_model_name);
	
	/* Register this MAC process in the model wide registry */
	own_process_record_handle = (OmsT_Pr_Handle)
		oms_pr_process_register (my_parameters->parent_id, my_parameters->objid, own_prohandle, proc_model_name);
	
	/*
	 * obtain  the address handle assigned to this node. The string
	 * "MAC addresses" rendez-vous with other MACs to guarantee
	 * unique addresses across all MAC types. The OMS_AA package
	 * handles this feature.
	 */
	oms_aa_handle = oms_aa_address_handle_get ("MAC Addresses", "Address");
	
	
	FOUT;
}


/*
 * Function:lr_wpan_mac_address_resolve
 */

static void lr_wpan_mac_address_resolve (void)
{
	Objid subnet_objid;
	int mac_address; // = my_parameters->mac_address;
	
	FIN (lr_wpan_mac_address_resolve ());
	
	mac_address = my_parameters->mac_address;
	
	/* Obtain the subnet identifier */
	subnet_objid = op_topo_parent (my_parameters->parent_id);
	
	/*
	 * Perform auto-addressing for the MAC address. Appart
	 * from dynamically addresses, if atau-assigned, the
	 * address resolution function also detects duplicate
	 * static assignments. By default, each address is
	 * considered as being a valid destination unless it is
	 * explicitly set.
	 */
	oms_aa_address_resolve (oms_aa_handle, my_parameters->objid, &mac_address);
	
	/* update the parameter of the MAC layer */
	my_parameters->mac_address = mac_address;
	
	/*
	 * Register station's MAC address into model-wide
	 * registery, since the address assignment is final now.
	 */
	oms_pr_attr_set (own_process_record_handle,
		"protocol",				OMSC_PR_STRING,			"mac",
		"mac_type",				OMSC_PR_STRING,			"wireless_pan",
		"subprotocol", 			OMSC_PR_NUMBER,			0.0,
		"subnetid",				OMSC_PR_OBJID,			subnet_objid,
		"address", 				OMSC_PR_NUMBER, 		(double) mac_address,
		"auto address handle",	OMSC_PR_ADDRESS,		oms_aa_handle,
		OPC_NIL);
	
	FOUT;
}

/*
 * Function:	lr_wpan_schedule_TAT
 *
 * Description:	schedule the next turn around time
 *
 * ParamIn:		
 */

static void lr_wpan_schedule_TAT (TxRx_Management code)
{
	FIN (lr_wpan_schedule_TAT (code));
	
	/* check if a Turn Around time was already schedule */
	lr_wpan_cancel_TAT (code);
	
	if (code == TX_CODE)
		TAT_TX_Evhandle = op_intrpt_schedule_self (op_sim_time () + WPAN_TURN_AROUND_TIME, Wpan_Tx_TAT);
	
	if (code == RX_CODE)
		TAT_RX_Evhandle = op_intrpt_schedule_self (op_sim_time () + WPAN_TURN_AROUND_TIME, Wpan_Rx_TAT);
	
	FOUT;
}

/*
 */
static void lr_wpan_cancel_TAT (TxRx_Management code)
{
	FIN (lr_wpan_cancel_TAT (code));
	
	/* check the channel according to the Tx RX management code */
	if ((code == RX_CODE || code == TXRX_CODE) && op_ev_valid (TAT_RX_Evhandle) == OPC_TRUE &&
		op_ev_id (TAT_RX_Evhandle) != op_ev_id (op_ev_current ()))
		op_ev_cancel (TAT_RX_Evhandle);
	
	if ((code == TX_CODE || code == TXRX_CODE) && op_ev_valid (TAT_TX_Evhandle) == OPC_TRUE &&
		op_ev_id (TAT_TX_Evhandle) != op_ev_id (op_ev_current ()))
		op_ev_cancel (TAT_TX_Evhandle);
	
	FOUT;
}



/*
 * Function:	lr_wpan_cca_init
 */

static void lr_wpan_cca_init (void)
{
	Buff_Info_Packet * info_packet;
	Boolean 			temp;
	
	double pfa =0.05 ;  
	
	
	FIN (lr_wpan_cca_init ());
		
	if(CCA_stage == 1)
		{
		CCA_statistic.First_CCA_count++;
		Global_CCA_Statistics.First_CCA_count++;
		/*CCA_statistic.Second_CCA_count++;
		Global_CCA_Statistics.Second_CCA_count++;*/
		}
	
	
	/* perform the CCA */
	my_parameters->cca_requirement = OPC_TRUE;
	
	/* set the time out for the CCA */
	op_intrpt_schedule_self (op_sim_time () + WPAN_CCA_PERIOD, Wpan_CCA_Time_Out);
	
	/* set TX to busy */
	channel_flag.tx_idle = OPC_FALSE;
	
	/* cancel any Turn Around time scheduled for the TX */
	lr_wpan_cancel_TAT (TX_CODE);
	
	/* check if the channel is idle */
	if (wpan_cca_all_pkt_types)
		channel_is_idle = (channel_buffer_ptr == NULL);
	else
		{
		/*
		 * in the case we only check the WPAN packets, we search for a WPAN packet
		 * in the channel buffer and if we find one, the channel is busy
		 */
		
			
		info_packet = channel_buffer_ptr; 
		
		
		if(info_packet == NULL)
	        	{ 
   	        if (op_dist_uniform (1.0) < pfa)
				{temp=OPC_FALSE;
			     }
		     else temp= OPC_TRUE;
			}
		
		
		
		temp = OPC_TRUE;
		
		/* check the channel: if the info_packet pointer is null, the channel will be idle */					
		while (info_packet != NULL)
			{
			if (info_packet->packet_type == WPAN_PKT_TYPE && info_packet->frequency == my_parameters->frequency_wpan && op_sim_time() == info_packet->tx_time)
				{
				temp = OPC_FALSE;
				info_packet = NULL;		
				}
			else
				{
				info_packet = info_packet->next_packet;
				}
			}
		
		
		if(temp == OPC_TRUE)  //false alarm can happen
   	        if (op_dist_uniform (1.0) < pfa)	temp=OPC_FALSE;
		
		
		
		channel_is_idle = temp;	
		}
		
	
	
	if(DEBUG_test)
		fprintf (fp_debug, "MAC MODULE: Node %s init_cca function at %12f s -- channel_is_idle %d \n", lr_wpan_node_name, op_sim_time(), channel_is_idle);	
	
	FOUT;
}





static void lr_wpan_cca2_success (void)
{

	FIN ( lr_wpan_cca2_success  ());
	
	CCA_statistic.Total_CCA_Success_Count ++;
	Global_CCA_Statistics.Total_CCA_Success_Count ++;	
	
	FOUT;
}


/*
 * Function:	lr_wpan_cca_failure
 */

static void lr_wpan_cca_failure (void)
{	

	FIN (lr_wpan_cca_failure ());

	/* Update the number of backoff */
	csma_parameters.nb_backoff ++;
	/* update the backoff exponent */
	csma_parameters.Be = min (csma_parameters.Be + 1, csma_parameters.max_BE);
	
	op_stat_write(BE_handle, csma_parameters.Be);
	op_stat_write(cca_stat_handle, channel_is_idle);
	
	if(CCA_stage ==1)
		{
		CCA_statistic.First_CCA_Failure_Count++;
		Global_CCA_Statistics.First_CCA_Failure_Count++;
		/*CCA_statistic.Second_CCA_Failure_Count++;
		Global_CCA_Statistics.Second_CCA_Failure_Count++;*/
		}	
	
	FOUT;
}

/*
 * Function:	lr_wpan_ack_not_received
 *
 * 
 * No parameters
 */

static void lr_wpan_ack_not_received(void)
{	

	FIN (lr_wpan_ack_not_received ());
	
		/* update the number of transmission retries */
		nb_transmission_retries++;
	
	
		if(psma_enabled)
			{
			/* update the backoff exponent following BEB rules */
			csma_parameters.Be = min (csma_parameters.Be + 1, csma_parameters.max_BE);
	
			op_stat_write(BE_handle, csma_parameters.Be);
			}
	
		
		global_statistics.Total_Ack_not_rcv ++;
			
	FOUT;
}

/*
 * Function:	lr_wpan_reset_backoff_parameters
 *
 * 
 * No parameters
 */

static void lr_wpan_reset_backoff_parameters(void)
{	

	FIN (lr_wpan_reset_backoff_parameters ());
	
		csma_parameters.Be = csma_parameters.min_BE;
		csma_parameters.nb_backoff = 0;
	
		op_stat_write(BE_handle, csma_parameters.Be);
	
	FOUT;
}
			
/*
 * Function:	lr_wpan_mac_backoff
 *
 * description:	
 *
 * No parameters
 */

static void lr_wpan_mac_backoff ()
{
	int		cw;
	int		backoff_periods = 0;
	double 	backoff_time = 0.0;
	double 	time_to_backoff_period_boundary=0.0;
	double bckoff_temp = 0.0;
		
	FIN (lr_wpan_mac_backoff ());
		
	if(psma_enabled)
		{
		if(my_parameters->slotted_enable == OPC_FALSE) 
			{
			/* compute the backoff time period */
			cw = (int) (01<<csma_parameters.Be); // compute 2^be
			//backoff_periods = floor (op_dist_uniform (cw));
			backoff_periods = (int) (op_dist_uniform (cw)); // choose random value between [0,2^be -1] 
			
			/* compute the backoff time (seconds) by multiply by the unit time for the backoff */
			backoff_time = (double) backoff_periods * LR_WPAN_BACKOFF_UNIT; 
			
			/* compute average backoff per packet */
			if (csma_parameters.nb_backoff == 0)
				{
				statistic.total_backoff ++;
				}
			
			statistic.total_backoff_time += backoff_time;
			/* We are in unslotted mode, so we start the backoff at the current time */
			op_intrpt_schedule_self (op_sim_time () + backoff_time, Backoff_Time_Out);
			}
		
		else 
			{
			
			if(csma_operation_param.backoff_countdown_is_paused == OPC_TRUE)
				{
				backoff_periods = csma_operation_param.pending_backoff_periods;
				}
			
			else
				if(csma_operation_param.CCA_evaluation_pending == OPC_TRUE)
				{
				backoff_periods = 0;
				}
				else
					{
					cw = (int) (01<<csma_parameters.Be); // compute 2^be
					//backoff_periods = floor (op_dist_uniform (cw));
					bckoff_temp = op_dist_uniform (cw);
					backoff_periods = (int) bckoff_temp; // choose random value between [0,2^be -1]
					}
				
			op_stat_write(backoff_interval_handle, backoff_periods);
			
			
			if(backoff_periods > sf_param.remaining_CAP_backoff_periods)
				{ /* No CCA evaluation in this superframe */
				csma_operation_param.pending_backoff_periods = backoff_periods - sf_param.remaining_CAP_backoff_periods;
				backoff_periods = sf_param.remaining_CAP_backoff_periods;
				csma_operation_param.evaluate_after_backoff = OPC_FALSE;
				
				global_statistics.Total_backoff_wait_for_beacon++;
				}
			
			else 
				{ /* After the backoff delay, evaluate whether we can proceed */
				csma_operation_param.pending_backoff_periods = 0;
				csma_operation_param.evaluate_after_backoff = OPC_TRUE;
				}
			
			/* compute the backoff time (seconds) */
			backoff_time = (double) backoff_periods * LR_WPAN_BACKOFF_UNIT; 
						
			/* compute average backoff per packet */
			statistic.total_backoff_time += backoff_time;
			
			global_statistics.Total_number_backoff_slots += backoff_periods;
 
			
			time_to_backoff_period_boundary = lr_wpan_slotted_boundary_time();
			
			/* We are in a slotted mode, we start the backoff at the boundary */
			op_intrpt_schedule_self (time_to_backoff_period_boundary + backoff_time , Backoff_Time_Out);
			
			}
		}
	
	if(s_aloha_enabled)
		{
		/*We resume the backoff countdown stppoed at the previous superframe due to lack of time (backoff contdown > 0)*/
		if(csma_operation_param.backoff_countdown_is_paused == OPC_TRUE)
				{
				backoff_periods = csma_operation_param.pending_backoff_periods;
				if(DEBUG_Backoff)
					fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function  -- backoff_countdown_is_paused \n", lr_wpan_node_name);
	
				}
			
		else
			if(csma_operation_param.CCA_evaluation_pending == OPC_TRUE) //Same case as above but here backoff countdown = 0
				{
				backoff_periods = 0;
				if(DEBUG_Backoff)
					fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function  -- CCA_evaluation_pending \n", lr_wpan_node_name);
	
				}
			else
				if (nb_transmission_retries == 0)
					{
					backoff_periods = 0;
					if(DEBUG_Backoff)
						fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function  -- backoff = 0 (first tx) \n", lr_wpan_node_name);
					}
	
				else
					{
					cw = aloha_cw;
					bckoff_temp = op_dist_uniform (cw);
					backoff_periods = (int) bckoff_temp; // choose random value between [0,31]
					if(DEBUG_Backoff)
						fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function  -- backoff periods = %d (retx) \n", lr_wpan_node_name, backoff_periods);
	
					}
			
		op_stat_write(backoff_interval_handle, backoff_periods);
		
		if(backoff_periods > sf_param.remaining_CAP_backoff_periods)
			{ /* No TX in this superframe */
			csma_operation_param.pending_backoff_periods = backoff_periods - sf_param.remaining_CAP_backoff_periods;
			backoff_periods = sf_param.remaining_CAP_backoff_periods;
			csma_operation_param.evaluate_after_backoff = OPC_FALSE;
			
			global_statistics.Total_backoff_wait_for_beacon++;
			
			if(DEBUG_Backoff)
					fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function  -- backoff_periods > sf_param.remaining_CAP_backoff_periods \n", lr_wpan_node_name);
	
			}
		
		else 
			{ /* After the backoff delay, evaluate whether we can proceed */
			csma_operation_param.pending_backoff_periods = 0;
			csma_operation_param.evaluate_after_backoff = OPC_TRUE;
			}
		
		/* compute the backoff time (seconds) */
		backoff_time = (double) backoff_periods * LR_WPAN_BACKOFF_UNIT; 
		
		/* compute average backoff per packet */
		statistic.total_backoff_time += backoff_time;
		
		global_statistics.Total_number_backoff_slots += backoff_periods;
		
		time_to_backoff_period_boundary = lr_wpan_slotted_boundary_time();
		
		/* We are in a slotted mode, we start the backoff at the boundary */
		op_intrpt_schedule_self ((time_to_backoff_period_boundary + backoff_time) , Backoff_Time_Out);
		}
			
	
		
	if(DEBUG_Backoff)
		fprintf (fp_debug, "MAC MODULE: Node %s mac_backoff function at %.12f s \n\t\t-- boundary time %.12f sec -- backoff time %.12f sec--  backoff_periods %d \n", lr_wpan_node_name, op_sim_time(), time_to_backoff_period_boundary, backoff_time,  backoff_periods);
	
	FOUT;
}


/*
 * Function:	lr_wpan_cca_evaluation
 *
 * No parameters
 */



static void lr_wpan_cca_evaluation(void)
{
	FIN (lr_wpan_cca_evaluation(void));

	if(csma_operation_param.evaluate_after_backoff == OPC_TRUE)
		{
		if(lr_wpan_csma_can_proceed() == OPC_TRUE)
			{
			csma_operation_param.CCA_evaluation_pending = OPC_FALSE;
			csma_operation_param.wait_for_the_next_superframe = OPC_FALSE;
			/* compute average backoff per packet */
			if (csma_parameters.nb_backoff == 0)
				{
				statistic.total_backoff ++;
				}
			}
		else 
			{
			csma_operation_param.wait_for_the_next_superframe = OPC_TRUE;
			csma_operation_param.CCA_evaluation_pending = OPC_TRUE;
			}
		}
	else
		{
		csma_operation_param.backoff_countdown_is_paused = OPC_TRUE;
		csma_operation_param.wait_for_the_next_superframe = OPC_TRUE;
		}
	FOUT;
}



/*
 * Function:	lr_wpan_csma_can_proceed
 *
 * description:	This function checks whether there is enough time (backoff periods) in
 *              the CAP of current superframe to finish a transaction (transmit a pending 
 *              packet to a device)
 * No parameters
 */

static Boolean lr_wpan_csma_can_proceed()
{

	/*
	int packet_size;
	int IFS; //interframe spacing;
	int IFS_time;
	
	double remaining_time;
	double time_to_backoff_period_boundary;
	double packet_tx_time;
	double transaction_time;
	*/

	FIN (lr_wpan_csma_can_proceed());

	/*ORIGINAL 15.4 standard
	
	packet_size = lr_wpan_get_tx_packet_size();
	
	if ((packet_size/8) <= aMaxSIFSFrameSize)
		IFS = aMinSIFSPeriod;
	else
		IFS = aMinLIFSPeriod;
	
	IFS_time = IFS*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;
	remaining_time = sf_param.end_of_the_CAP_period - op_sim_time();
	time_to_backoff_period_boundary = lr_wpan_slotted_boundary_time_modified(); 
	
	packet_tx_time = packet_size/LR_WPAN_BIT_RATE;
		
	transaction_time = 2*LR_WPAN_BACKOFF_UNIT + packet_tx_time + IFS_time;  
	
	if (Acknowledgement_Enable)
		{
		transaction_time += macAckWaitDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;	
		}  
	
	if (transaction_time > remaining_time)
		{
		FRET (OPC_FALSE);
		}
	else 
		{
		FRET (OPC_TRUE);
		}
	*/
	
	if(psma_enabled) 
		{
			if (sf_param.remaining_CAP_backoff_periods<MIN_BACKOFF_PERIOD_TO_PROCEED_PSMA)
				{
				FRET (OPC_FALSE);
				}
			else 
				{
				FRET (OPC_TRUE);		
				}
		}
	
	if(s_aloha_enabled)
		{
			if (sf_param.remaining_CAP_backoff_periods<1)
				{
				FRET (OPC_FALSE);
				}
			else 
				{
				FRET (OPC_TRUE);		
				}
	
		}
	
	FRET (OPC_FALSE);
}


/*
 * Function:	lr_wpan_slotted_boundary_time
 *
 * Description:	compute the time to reach the boundary of
 *				one slot. (absolute time)
 */

double lr_wpan_slotted_boundary_time (void)
{
	double time = op_sim_time ();
	double remainder = time;
	
	const double unit = LR_WPAN_BACKOFF_UNIT; //WPAN_CCA_PERIOD + WPAN_TURN_AROUND_TIME;
	
	
	FIN (lr_wpan_slotted_boundary_time ());
	
	/* compute the remainder */
	while (remainder >= unit) remainder -= unit;
	
	/* if the remainder is not zero, we compute the next odd time */
	if (remainder > 0.0000001)
		time += (unit - remainder);
	
	FRET (time);
}


/*
 * Function:	lr_wpan_slotted_boundary_time_modified 
 *
 * Description:	compute the time to reach the boundary of
 *				one slot. (relative time)
 */

static double lr_wpan_slotted_boundary_time_modified (void)
{
	double time;// = op_sim_time () - sf_param.superframe_start_time;
	double remainder;// = time;
	
	const double unit = LR_WPAN_BACKOFF_UNIT; //WPAN_CCA_PERIOD + WPAN_TURN_AROUND_TIME;
	
	
	FIN (lr_wpan_slotted_boundary_time_modified ());
	
	time = op_sim_time () - sf_param.superframe_start_time;
	remainder = time;
	
	/* compute the remainder */
	while (remainder >= unit) 
		remainder -= unit;
	
	/* if the remainder is not zero, we compute the next odd time */
	if (remainder > 0.0000001)
	{
		time = (unit - remainder);
	}
	else
	{
		time = 0.0; 
	}
	
	FRET (time);
}

	  
/* 
 * Function:	lr_wpan_locate_backoff_period_boundary
 *
 * Description:	Locate the next backoff boundary 
 *
*/

static double lr_wpan_locate_backoff_period_boundary()
	{
	int		next_backoff_period_boundary_symbols;
	double	next_backoff_period_boundary_seconds;
	double	time_to_next_backoff_period_boundary;
	double	time_to_next_backoff_period_boundary1;
	double	time_to_next_backoff_period_boundary2;
		
	FIN(lr_wpan_locate_backoff_period_boundary());

	next_backoff_period_boundary_symbols = sf_param.backoff_period_boundary_symbols[sf_param.backoff_period_index];
	next_backoff_period_boundary_seconds = next_backoff_period_boundary_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE; 
	
	time_to_next_backoff_period_boundary1 = (next_backoff_period_boundary_seconds + sf_param.superframe_start_time) - op_sim_time();
    time_to_next_backoff_period_boundary2 = lr_wpan_slotted_boundary_time_modified();
	time_to_next_backoff_period_boundary = time_to_next_backoff_period_boundary2;
	
	FRET(time_to_next_backoff_period_boundary);
	 	
	}


/*
 * Get the size of the packet to be transmitted
 *
 */

static int lr_wpan_get_tx_packet_size ()
{
	List   *copy_list_ptr;
	Packet *packet_ptr;
	int    packet_size;
		
	FIN (lr_wpan_get_tx_packet_size ());	

	/* We are transmitting a data request frame */
	if (lr_wpan_beacon_param.data_request != OPC_NIL)
		{
		last_transmitted_pkt_size= 0;

			packet_size = (int) op_pk_total_size_get (lr_wpan_beacon_param.data_request);
		}
	/* We are transmitting a new data frame */
	else if (retransmission_ptr == OPC_NIL)
		{		
		/* check if the (data) subqueue is not empty */
		if (!current_queue->size)
			lr_wpan_mac_error ("lr_wpan_get_tx_packet_size:", "The higher layer subqueue is empty.", OPC_NIL);
		/* Create a new list and copy the queue list into the newly created list */
		copy_list_ptr = op_prg_list_create ();
		op_prg_list_elems_copy (current_queue->subqueue, copy_list_ptr);
		/* dequeue the higher layer packet to transmit (from the copy list) */
		if ((packet_ptr = op_prg_list_remove (copy_list_ptr, OPC_LISTPOS_HEAD)) == OPC_NIL)
			lr_wpan_mac_error ("lr_wpan_get_tx_packet_size:", "Unable to get the packet from the subqueue.", OPC_NIL);
		
		packet_size = (int) op_pk_total_size_get (packet_ptr);	

		
		/* deallocate the elements on the list */
		op_prg_list_free (copy_list_ptr);
		/* deallocate the list itself */
		op_prg_mem_free (copy_list_ptr);
		}
	/* We are re-transmitting an old data frame */
	else
		{
		last_transmitted_pkt_size = 0;
		packet_size = (int) op_pk_total_size_get(retransmission_ptr);
		}	
	
	FRET (packet_size);
	}



/*
Function: lr_wpan_intrpt_check
*/

static void lr_wpan_intrpt_check (const char * state_name)
{
	char odb_msg[128]; // debugging message
	
	
	FIN (lr_wpan_intrpt_check ());
		
	/* compute the debugging message */
	sprintf (odb_msg, "exit the \"%s\" state: ", state_name);
	FLAG_ODB_PRINTING;
	
	/* get the type of the interuption */
	switch (intrpt_type = op_intrpt_type ())
		{
		case OPC_INTRPT_SELF:
		case OPC_INTRPT_REMOTE:
		switch (intrpt_code = op_intrpt_code ())
			{
			
			
			
			case Backoff_Time_Out:
			strcat (odb_msg, "backoff expired");
			
			if(my_parameters->slotted_enable == OPC_TRUE)
				lr_wpan_cca_evaluation();
			
			break;
				
			case Data_Pkt_To_Send:
			strcat (odb_msg, "transmission required");
			
			/* set the flag */
			wpan_transmission_required = OPC_TRUE;
			break;
			
			case Ack_Time_Out:
			strcat (odb_msg, "Ack period expired");
			
			if(DEBUG_Rx_Ack) 
				fprintf(fp_debug, "MAC MODULE: Node %s Ack not received at time %12f sec (Ack_Time_Out), with tx_idle flag = %d and rx_idle flag = %d\n", lr_wpan_node_name, op_sim_time(), channel_flag.tx_idle, channel_flag.rx_idle);
				
			
			/* if the time is out, we reset the acknowledgment flag */
			Rx_Ack_Expected = OPC_FALSE;
			
			/* update the statistic */
			(statistic.Nb_Time_Out)++;

			
			break;
			
			case Ack_Received:
			strcat (odb_msg, "Received an Ack");

			
			/* turn on the LIFS period */
			channel_flag.LIFS_on = OPC_TRUE;
	
			/* schedule when the LIFS will be over */
			op_intrpt_schedule_self (op_sim_time () + WPAN_LIFS_DURATION, Wpan_LIFS_Over);

			/* canceled the Ack Time out if it is still schedule */
			if (op_ev_valid (Ack_TimeOut_Evhandle) == OPC_TRUE &&
				op_ev_id (Ack_TimeOut_Evhandle) != op_ev_id (op_ev_current()))
				op_ev_cancel (Ack_TimeOut_Evhandle);

				
			break;
			
			case Wpan_Ack_Tx_Required:
			strcat (odb_msg, "Transmit an Ack");
			
			
			break;
			
			case End_Of_Transmission:
			strcat (odb_msg, "End of the transmission");
			
			/* set the TX to idle */
			channel_flag.tx_idle = OPC_TRUE;
						
			/* schedule the release of RX (Turn Around Time) */
			lr_wpan_schedule_TAT (RX_CODE);
			break;
			
			case CCA_Pkt_Detect:
			strcat (odb_msg, "Packet detecting during the CCA");
			
			/* set the channel to busy */
			channel_is_idle = OPC_FALSE;
			break;
			
			case Wpan_CCA_Time_Out:
			strcat (odb_msg, "CCA is over");
			
			/* schedule the release of TX (Turn Around Time) */
			lr_wpan_schedule_TAT (TX_CODE);
			
			/* end the CCA */
			my_parameters->cca_requirement = OPC_FALSE;
			
			/*
			 * if we are in a slotted mode, we need to switch the flag 
			 * for the second cca
			 */
			/*if (my_parameters->slotted_enable)
				lr_wpan_beacon_param.second_cca_req = (lr_wpan_beacon_param.second_cca_req) ? OPC_FALSE : OPC_TRUE; */
			break; 
			
			case Wpan_Rcv_Pkt:
			strcat (odb_msg, "We're receiving a packet");
			
			/* turn off the TX */
			channel_flag.tx_idle = OPC_FALSE;
			
			/* if a turn around time is schedule, we cancel it */
			lr_wpan_cancel_TAT (TX_CODE);
			break;
			
			case Wpan_Rx_TAT:
			strcat (odb_msg, "End of the Turn Around Time, Rx is idle");
			
			/* set the RX to idle */
			channel_flag.rx_idle    = OPC_TRUE;

			
			break;
			
			case Wpan_Tx_TAT:
			strcat (odb_msg, "End of the Turn Around Time, Tx is idle");
			
			/* set the TX to idle */
			channel_flag.tx_idle = OPC_TRUE;
			
			/* we check whether we need to send an Ack */
			if (Tx_Ack_Require)
				{
				/* transmit an acknowledgment */
				lr_wpan_ack_to_transmit ();
				
				/* complete the ODB message */
				strcat (odb_msg, "; send an acknoledge");
				
				/* turn off the flag */
				Tx_Ack_Require = OPC_FALSE;
				}
			break;
			
			case Wpan_LIFS_Over:
			strcat (odb_msg, "End of the LIFS period, Tx is idle");
			
			/* turn off the LIFS Period */
			channel_flag.LIFS_on = OPC_FALSE;
			break;
			
			case Wpan_Beacon_To_Send:
			/* we generate and send a beacon on broadcast */ 
			lr_wpan_generate_beacon ();
			break;
			
			case Wpan_Data_Req_To_Send:
			/* we generate a data request */
			lr_wpan_generate_data_request ();	
			break;
			
		
		
			/* Handle interrupt from backoff boundary timer */
			case Wpan_Backoff_Period_Elapsed:
			if(sf_param.backoff_period_index != (sf_param.backoff_periods_per_CAP-1)) //!!!!!!!!!!!!!!!!!!!!!!!!!
				{
				sf_param.remaining_CAP_backoff_periods--;
				sf_param.backoff_period_index++;
				
				/*if(DEBUG_Backoff)
					{ 
						printf("MAC MODULE: node %s. At time %f\n", lr_wpan_node_name, op_sim_time()); 
						printf("\t remaining_CAP_backoff_periods = %d -- backoff_period_index %d\n", sf_param.remaining_CAP_backoff_periods, sf_param.backoff_period_index);
					}
				*/
				if(  ((sf_param.backoff_period_index - 1) % sf_param.backoff_periods_per_slot) == 0)
					sf_param.time_slot_index++;
				op_intrpt_schedule_self(op_sim_time() + LR_WPAN_BACKOFF_PERIOD_DURATION, Wpan_Backoff_Period_Elapsed);
				}
			break;
						
					
			/* Enable the receiver to be ready for the next beacon arrival */
			case Wpan_Beacon_Tracking:
			break;
			
			
			case Wpan_CAP_Period_End:
			sf_param.CAP_PERIOD_ACTIVE = OPC_FALSE;
			break;
	
					
			default:
			strcat (odb_msg, "unknown code");
			break;
			}
		break;
			
			
			
		case OPC_INTRPT_STRM:
		
		switch (intrpt_stream = op_intrpt_strm ())
			{
			case HIGHER_LAYER_DOWN_STRM:
			/* we received a packet from the higher layer */
			higher_layer_pkt_recv ();
			
			global_statistics.Application_generated++;
				
			strcat (odb_msg, "packet from the higher layer");
			break;
				
			case LOWER_LAYER_UP_STRM:
			strcat (odb_msg, "packet from the physical layer: reception completed");
			
			/* we received a packet from the channel */
			lower_layer_pkt_rcv ();
			
			/* schedule the release of TX (Turn Around Time) */
			lr_wpan_schedule_TAT (TX_CODE);
			break;
				
			default:
			strcat (odb_msg, "unknown stream");
			break;
			}
		break;
		
			
		case OPC_INTRPT_ENDSIM:
		//printf("node name %s\n", lr_wpan_node_name);
		if(!strcmp(lr_wpan_node_name,"coordinator"))
			{
			
			printf("Coordinator's turn to endsim\n");

			lr_wpan_collect_stat_global ();
			}
		lr_wpan_collect_stat_nodes ();
		break;
		
		default:
		strcat (odb_msg, "unknown intrpt");
		break;
		}
	
	
	/* print the debugging message */
	ENTER_STATE_ODB_PRINTING (odb_msg);
	FLAG_ODB_PRINTING;
	
	/* define a break point */
	op_prg_odb_bkpt ("wpan_state");
	FOUT;
}


/*
 * Function:	lr_wpan_generate_beacon
 *
 * Description:	create a Beacon packet and send it in
 *				Broadcast to the devices in the same
 *				group
 *
 * No parameters
 */

static void 
lr_wpan_generate_beacon (void)
{
	Packet * beacon_ptr;
	int i, j; // loop variables
	int beacon_size, rx_index, protocol_used;
	double txrx_distance, average_snr, average_traffic;
	Boolean condition;
	Wpan_Node_Param * rxptr;
	Ici * ici_ptr;

	Addressing_Field * address;
	Frame_Ctrl_Field * ctrl_field_ptr;  
	Superframe_Spec_Field * superframe_spec_ptr;
	
	stack_change* stack_ptr;
	stack_change* traffic_snr_ptr;
	
	//Objid rem_node_objid;

	FILE * fp;
	char report_name[128];
	Boolean exist;
	double mac_delay,mac_delay_considering_dropped, G_channel, G_offered;
		
	time_t date;
	char date_str[32];
	
	
	FIN (lr_wpan_generate_beacon ());
	
	
	/* debugging */
	ENTER_STATE_ODB_PRINTING ("Generate the beacon packet.");
	
	/* Check if the MAC address table has been created */
	if (lr_wpan_beacon_param.nb_addresses == 0)
		lr_wpan_mac_error ("lr_wpan_generate_beacon:", "No connexion found.", OPC_NIL);
	
	if (GADGET_enabled)
		{
		
		if (op_sim_time () < GADGET_SMA_LENGTH*(aBaseSuperframeDuration*(pow(2, sf_spec.beacon_order))*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE)) //initialisation
			{
			average_snr = 0.0; 
			average_traffic = 0.0;
			//printf("Initialising moving averages at time %f\n", op_sim_time ());
			}
			
		
		//printf("SF segn %d at time %f\n", Mac_Beacon_Tx_Seqn, op_sim_time ());	
		/*calculate simple moving average*/
			
		if (GADGET_sma_counter == GADGET_SMA_LENGTH)
			{
			
			average_snr = 0.0; 
			average_traffic = 0.0;
			
			for (j=GADGET_SMA_SIZE-2; j>=0; j--)
				{
				GADGET_SMA_SNR_VECT[j+1]=GADGET_SMA_SNR_VECT[j];
				average_snr+= (GADGET_SMA_SNR_VECT[j+1]);
				GADGET_SMA_TRAFFIC_VECT[j+1]=GADGET_SMA_TRAFFIC_VECT[j];
				average_traffic+= (GADGET_SMA_TRAFFIC_VECT[j+1]);
				}
			
			if (GADGET_pkt_per_superframe > 0)
				{
				GADGET_SMA_SNR_VECT[0]=GADGET_snr/GADGET_pkt_per_superframe;
				}
			else
				GADGET_SMA_SNR_VECT[0] = 0;
			
			GADGET_SMA_TRAFFIC_VECT[0]=aBaseSlotDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE*((double) (global_statistics.Data_Pkt_Sent-GADGET_SUPERFRAME_TRAFFIC)/(op_sim_time ()-single_superframe_time_counter));
			
			average_snr+= (GADGET_SMA_SNR_VECT[0]);
			average_traffic+= (GADGET_SMA_TRAFFIC_VECT[0]);
			
			average_snr = average_snr/(double)(GADGET_SMA_SIZE);
			average_traffic = average_traffic/(double)(GADGET_SMA_SIZE);
			
			//printf("GADGET_SMA_SNR_VECT[0] = %f, moving average = %f\n",GADGET_SMA_SNR_VECT[0], average_snr);
			//printf("GADGET_SMA_TRAFFIC_VECT[0] = %f, moving average = %f\n",GADGET_SMA_TRAFFIC_VECT[0], average_traffic);
		
		
			/*collect statistics on channel condition*/
		
			traffic_snr_ptr = (stack_change*) op_prg_mem_alloc( sizeof(stack_change) );
		
			traffic_snr_ptr->time = op_sim_time();
			traffic_snr_ptr->s_aloha_status = (int)s_aloha_enabled;
			traffic_snr_ptr->psma_status = (int)psma_enabled;
			traffic_snr_ptr->observed_traffic = average_traffic;
			traffic_snr_ptr->observed_snr = average_snr;
		
			op_prg_list_insert(list_traffic_snr_ptr, traffic_snr_ptr, OPC_LISTPOS_TAIL);
			
			
			GADGET_sma_counter = 1;
			GADGET_snr = 0.0;
			GADGET_pkt_per_superframe = 0;
			GADGET_SUPERFRAME_TRAFFIC = global_statistics.Data_Pkt_Sent;		
			single_superframe_time_counter = op_sim_time ();
			
			}
		else
			{
			GADGET_sma_counter++;
			average_snr = 0.0; 
			average_traffic = 0.0;
			
			for (j=0; j<GADGET_SMA_SIZE; j++)
				{
				average_snr+= (GADGET_SMA_SNR_VECT[j]);
				average_traffic+= (GADGET_SMA_TRAFFIC_VECT[j]);
				}
			
			average_snr = average_snr/(double)(GADGET_SMA_SIZE);
			average_traffic = average_traffic/(double)(GADGET_SMA_SIZE);
			
			}
		
		
		/*do only if a sufficient amount of time has passed since last protocol change*/
		/* do only if SMA is full*/ 
		if (op_sim_time () > (GADGET_SMA_LENGTH*(GADGET_SMA_SIZE)*(aBaseSuperframeDuration*(pow(2, sf_spec.beacon_order))*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE)+GADGET_SMA_FLUSH_TIME) && ((op_sim_time () > (GADGET_SMA_FLUSH_TIME + GADGET_STABILITY_TIME)) || GADGET_SMA_FLUSH_TIME == 0.0))
			{
			//printf("SF segn %d av SNR = %f, av traffic %f\n", Mac_Beacon_Tx_Seqn, average_snr, average_traffic);
			
			/*compare averages to thresholds*/
			//GADGET_THRESHOLD_VECT[GADGET_THRESHOLD_SET]
			condition = OPC_TRUE;
			j=0;
			while (condition == OPC_TRUE)
				{
				if (GADGET_THRESHOLD_VECT[j] == 0.0)
					{
					//highest traffic
					condition = OPC_FALSE;			//jump out of loop
					protocol_used = GADGET_THRESHOLD_PROTOCOL[j];
					}
				else if(average_traffic <= GADGET_THRESHOLD_VECT[0]) //lowest traffic, thresholds are increasing
					{
					condition = OPC_FALSE;		//jump out of loop
					protocol_used = GADGET_THRESHOLD_PROTOCOL[0];
					}
				else 
					{
					if(average_traffic > GADGET_THRESHOLD_VECT[j] && average_traffic <= GADGET_THRESHOLD_VECT[j+1])
						{
						/*traffic is between threshold j and j+1*/
						//printf("GADGET_THRESHOLD_VECT[%d] = %f, GADGET_THRESHOLD_VECT[%d] = %f moving average = %f\n", j, GADGET_THRESHOLD_VECT[j], j+1, GADGET_THRESHOLD_VECT[j+1], average_traffic);
						condition = OPC_FALSE; //protocol selected, get out of loop
						protocol_used = GADGET_THRESHOLD_PROTOCOL[j+1];
						//printf("s_aloha_enabled %d, psma_enabled %d, protocol_used (SA 0, PSMA 1) %d, time %f\n", (int)s_aloha_enabled, (int)psma_enabled, protocol_used, op_sim_time ());
						}
					else
						j++;
					
					}
				
				}
			
			/*If protocol change occurred */
			if ((s_aloha_enabled && protocol_used != GADGET_USE_S_ALOHA) || (psma_enabled && protocol_used != GADGET_USE_PSMA))
				{
				//printf("Latest SMA_vect = %f, moving average = %f\n",GADGET_SMA_TRAFFIC_VECT[0], average_traffic);
				stack_ptr = (stack_change*) op_prg_mem_alloc( sizeof(stack_change) );	
				
				/* reset backoff parameters */
				lr_wpan_reset_backoff_parameters();
				/* reset the transmission retries counter */
				nb_transmission_retries = 0;
				/*flush moving average if protocol change*/
				
				GADGET_SMA_FLUSH_TIME = op_sim_time ();
				for (j=0; j < GADGET_SMA_SIZE; j++)
					{
					GADGET_SMA_SNR_VECT[j]=0.0;
					//average_snr+= (GADGET_SMA_SNR_VECT[j]/(GADGET_SMA_SIZE));
					GADGET_SMA_TRAFFIC_VECT[j]=0.0;
					//average_traffic+= (GADGET_SMA_TRAFFIC_VECT[j]/(GADGET_SMA_SIZE));
					}
				
				
				if(s_aloha_enabled)
					printf("MAC protocol change at time = %f. Old protocol S_ALOHA, New protocol (S_ALOHA: %d, PSMA: %d): %d\n", op_sim_time (), GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
				else if(psma_enabled)
					printf("MAC protocol change at time = %f. Old protocol PSMA, New protocol (S_ALOHA: %d, PSMA: %d): %d\n", op_sim_time (), GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
				else
					printf("MAC protocol change at time = %f. New protocol Unknown: %d\n", op_sim_time (), protocol_used);
				
				/*set the coordinators own MAC protocol appropriately*/
				if (protocol_used == GADGET_USE_PSMA)
					{
					s_aloha_enabled = OPC_FALSE;	//others are set as OPC_FALSE
					psma_enabled = OPC_TRUE;		//protocol with the best Goodness with highest traffic range is set OPC_TRUE
					}
				else if (protocol_used == GADGET_USE_S_ALOHA)
					{
					s_aloha_enabled = OPC_TRUE;	
					psma_enabled = OPC_FALSE;
					}
				else
					{
					printf("Unknown MAC protocol - %d - at time = %f\n", protocol_used, op_sim_time ());
					s_aloha_enabled = OPC_FALSE;
					psma_enabled = OPC_TRUE; //used psma as default, if problems occur.
					lr_wpan_mac_error ("lr_wpan_generate_beacon:", "Unable to assign appropriate protocol.", OPC_NIL);
					}
				
				stack_ptr->time = op_sim_time();
				stack_ptr->s_aloha_status = (int)s_aloha_enabled;
				stack_ptr->psma_status = (int)psma_enabled;
				stack_ptr->observed_traffic = average_traffic; //latest SMA entry
				stack_ptr->observed_snr =average_snr;
	
				op_prg_list_insert(list_stack_change_ptr, stack_ptr, OPC_LISTPOS_TAIL);
				
				
				/*WARNING! SEVERE CROSS-INTERACTION WITH NODE CHANNEL IN THE top.OFFICE_NETWORK PROJECT*/
				/* determine the object ID of the desired remote queue 
					Id starting at the top level pointing to the MAC of the coordinator */
				/*MAC protocol*/
				op_ima_obj_attr_set_toggle (my_parameters->objid, "PSMA_Enabled", psma_enabled);
				op_ima_obj_attr_set_toggle (my_parameters->objid, "S_Aloha_Enabled", s_aloha_enabled);
				
				//rem_node_objid = op_id_from_hierarchical_name ("Office Network.channel.channel");
				//printf("Channel Object ID: %d\n", (int)rem_node_objid);


				/*Set the protocol to be enabled*/
				//op_ima_obj_attr_set_toggle (rem_node_objid, "psma_enabled", psma_enabled);
				//op_ima_obj_attr_set_toggle (rem_node_objid, "s_aloha_enabled", s_aloha_enabled);
				//printf("Used protocol: PSMA %d, S_ALOHA %d\n", (int)psma_enabled, (int)s_aloha_enabled);
				
				
				/*Recalculate appropriate slot units as per protocol*/
				if(psma_enabled)
					{
					psma_time_to_tx = OPC_FALSE;
			
					aUnitBackoffPeriod = aBaseSlotDuration/2;//symbols
			
					/* backoff time unit (in seconds) */
					LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
					LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
					}
				if(s_aloha_enabled)
					{
					aUnitBackoffPeriod = aBaseSlotDuration;//symbols
			
					/* backoff time unit (in seconds) */
					LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
					LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
					}

				
				}
			/*else
				{
				if (s_aloha_enabled)
					printf("MAC protocol at time = %f. Old protocol S_ALOHA, New protocol (S_ALOHA: %d, PSMA: %d): %d\n", op_sim_time (), GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
				else if (psma_enabled)
					printf("MAC protocol at time = %f. Old protocol PSMA, New protocol (S_ALOHA: %d, PSMA: %d): %d\n", op_sim_time (), GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
				else
					printf("MAC protocol at time = %f. Unknown Old protocol, New protocol (S_ALOHA: %d, PSMA: %d): %d\n", op_sim_time (), GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
				}*/
			
			}
		else //current SMA vector is not full, assign the same MAC protocol as before
			{
			if (s_aloha_enabled)
				protocol_used = GADGET_USE_S_ALOHA;
			else if (psma_enabled)
				protocol_used = GADGET_USE_PSMA;
			else
				{
				protocol_used = GADGET_USE_PSMA; //backup protocol
				printf("MAC protocol change at time = %f.SMA vector not full, New protocol Unknown: %d\n", op_sim_time (), protocol_used);
				}
			}
		}
	/*collect superframe statistics */
	
	
	if (superframe_reporting_counter == 10)
		{
		/* get the date of the day */
		time (&date);
		sprintf (date_str, "%s", ctime (&date));
	
		/* get the report name */
		sprintf (report_name, "%s_superframe.txt", lr_wpan_scenario);
	
		//printf("Report Name: %s\n", report_name);
		
		/* open the report file */
		fp = lr_wpan_open_report_file (report_name, &exist);
	
		/* write a header in the file if it has been created now */
		if (!exist)
			{
			fprintf (fp, "\n\t*** Superframe statistics for the scenario %s ***\n", lr_wpan_scenario);
			fprintf (fp, "\tCreation date: %s\n", date_str);
			fprintf (fp, "\tChannel traffic :\t\tchannel traffic (Ts*pkt_sent/sim_time)\n");
			fprintf (fp, "\tOffered traffic :\t\toffered traffic (taking into account also CCA attempts)\n");
			fprintf (fp, "\tApplication generated :\t\ttotal number of packets generated by the application\n");
			fprintf (fp, "\tPackets enqueued at the MAC :\ttotal number of packets enqueued at the MAC layer \n");
			fprintf (fp, "\tPackets not enqueued at the MAC :total number of packets not enqueued at the MAC layer (because another packets had already being processed)\n\n");
			fprintf (fp, "\tTot sent :\t\ttotal number of packets sent \n");
			fprintf (fp, "\tTot rcvd :\t\ttotal number of packets received \n");
			fprintf (fp, "\tCCA failed :\t\tnumber of times the CCA failed (without counting when a packet is dropped))\n");
			fprintf (fp, "\tTot dropped :\t\ttotal number of packets dropped (maximum number of retransmissions reached or CCA failed)\n");
			fprintf (fp, "\tTot dropped CCA:\ttotal number of packets dropped (CCA failed)\n");
			fprintf (fp, "\tTot dropped retx:\ttotal number of packets dropped (maximum number of retransmissions reached)\n");
			fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmitted packets\n\n");
			fprintf (fp, "\tMac delay:\t\tmac delay per paket received (sec)\n");
			fprintf (fp, "\tMac delay 2:\t\tmac delay per paket received (sec) (considering dropped packets)\n\n");
			fprintf (fp, "\tNumber of backoffs: \t total numbers of slots spent in backoff\n");
			fprintf (fp, "\tBeacon rcv backoff:\t Total number of beacon frames received during backoff\n");
			fprintf (fp, "\tCCA:\t\t Total number of CCA\n");
			fprintf (fp, "\tAckTimeOut:\t\t Total number of maxMacAckWaitTime expired\n\n");
			fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
			fprintf (fp, "Channel traffic\t Offered traffic\t Application generated\t Packets enqueued at the MAC\t Packets not enqueued at the MAC\t Tot sent\t Tot received\t CCA failed\t Tot dropped\t Tot dropped CCA\t Tot dropped retx\t Retransmit pkt\t Mac delay\t Mac delay 2\t Number of backoffs\t Beacon rcv backoff \t\tCCA\t AckTimeOut\t Simulation time\t Last modified date\n\n");
			}
		/*Compute offered traffic*/
		
		
		G_channel = aBaseSlotDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE*((double) (global_statistics.Data_Pkt_Sent-superframe_statistics.Data_Pkt_Sent)/(op_sim_time ()-superframe_time_counter));
		G_offered = aBaseSlotDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE*((double) (global_statistics.Data_Pkt_Sent-superframe_statistics.Data_Pkt_Sent)+(double)(global_statistics.Pkt_Dropped_CCA-superframe_statistics.Pkt_Dropped_CCA)+(double)(Global_CCA_Statistics.First_CCA_Failure_Count-Superframe_CCA_Statistics.First_CCA_Failure_Count))/(op_sim_time ()-superframe_time_counter);
																		
		
		/* compute the MAC average delay */
		mac_delay = (statistic.Data_Pkt_Rcv-Wpan_Superframe_Statistics.Data_Pkt_Rcv) ? (statistic.Total_MAC_Delay-Wpan_Superframe_Statistics.Total_MAC_Delay) / (double) (statistic.Data_Pkt_Rcv-Wpan_Superframe_Statistics.Data_Pkt_Rcv) : -1.0;
		mac_delay_considering_dropped = (statistic.Data_Pkt_Rcv-Wpan_Superframe_Statistics.Data_Pkt_Rcv) ? ((statistic.Total_MAC_Delay-Wpan_Superframe_Statistics.Total_MAC_Delay)+(global_statistics.Total_Delay_Dropped_packets-superframe_statistics.Total_Delay_Dropped_packets)) / (double) (statistic.Data_Pkt_Rcv-Wpan_Superframe_Statistics.Data_Pkt_Rcv) : -1.0;
																			
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s",
			double_to_string (G_channel, strlen ("Channel traffic")),
			double_to_string (G_offered, strlen ("Offered traffic")),
			integer_to_string ((int)(global_statistics.Application_generated-superframe_statistics.Application_generated), 15),
			integer_to_string ((int)(global_statistics.Segment_generated-superframe_statistics.Segment_generated), strlen ("Packets enqueued at the MAC")),
			integer_to_string ((int)(global_statistics.Pkt_not_enqueued-superframe_statistics.Pkt_not_enqueued), strlen ("Packets not enqueued at the MAC")),
			integer_to_string ((int)(global_statistics.Data_Pkt_Sent-superframe_statistics.Data_Pkt_Sent), 8),
			integer_to_string ((int)(global_statistics.Data_Pkt_Rcv-superframe_statistics.Data_Pkt_Rcv), 8),
			integer_to_string ((int)(Global_CCA_Statistics.First_CCA_Failure_Count-Superframe_CCA_Statistics.First_CCA_Failure_Count), 11),
			integer_to_string ((int)(global_statistics.Pkt_Dropped-superframe_statistics.Pkt_Dropped), 11),
			integer_to_string ((int)(global_statistics.Pkt_Dropped_CCA-superframe_statistics.Pkt_Dropped_CCA), 16),
			integer_to_string ((int)(global_statistics.Pkt_Dropped_retx-superframe_statistics.Pkt_Dropped_retx), 16),
			integer_to_string ((int)(global_statistics.Retransmission-superframe_statistics.Retransmission), 10),
			double_to_string (mac_delay, 9),
			double_to_string (mac_delay_considering_dropped, 10),
			integer_to_string ((int)(global_statistics.Total_number_backoff_slots-superframe_statistics.Total_number_backoff_slots), 15),
			integer_to_string ((int)(global_statistics.Total_backoff_wait_for_beacon-superframe_statistics.Total_backoff_wait_for_beacon), strlen ("Beacon rcv backoff")),
			integer_to_string ((int)(Global_CCA_Statistics.First_CCA_count-Superframe_CCA_Statistics.First_CCA_count), 9),
			integer_to_string ((int)(global_statistics.Total_Ack_not_rcv-superframe_statistics.Total_Ack_not_rcv), 10),
			double_to_string ((op_sim_time ()-superframe_time_counter), strlen ("simulation time")),
			date_str);
	
		fclose (fp);																		
		
		
		/* cretae a  .txt file without headers, for Matlab postprocessing */
	
		/* get the report name */
		sprintf (report_name, "%s_superframe_matlab.txt", lr_wpan_scenario);
		/* open the report file */
		fp = lr_wpan_open_report_file (report_name, &exist);
		
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\n",
			double_to_string (G_channel, strlen ("Channel traffic")),
			double_to_string (G_offered, strlen ("Offered traffic")),
			integer_to_string ((int)(global_statistics.Application_generated-superframe_statistics.Application_generated), 10),
			integer_to_string ((int)(global_statistics.Segment_generated-superframe_statistics.Segment_generated), strlen ("Tot seg generated")),
			integer_to_string ((int)(global_statistics.Pkt_not_enqueued-superframe_statistics.Pkt_not_enqueued), strlen ("Tot seg generated")),
			integer_to_string ((int)(global_statistics.Data_Pkt_Sent-superframe_statistics.Data_Pkt_Sent), 8),
			integer_to_string ((int)(global_statistics.Data_Pkt_Rcv-superframe_statistics.Data_Pkt_Rcv), 8),
			integer_to_string ((int)(Global_CCA_Statistics.First_CCA_Failure_Count-Superframe_CCA_Statistics.First_CCA_Failure_Count), 11),
			integer_to_string ((int)(global_statistics.Pkt_Dropped-superframe_statistics.Pkt_Dropped), 11),
			integer_to_string ((int)(global_statistics.Pkt_Dropped_CCA-superframe_statistics.Pkt_Dropped_CCA), 16),
			integer_to_string ((int)(global_statistics.Pkt_Dropped_retx-superframe_statistics.Pkt_Dropped_retx), 16),
			integer_to_string ((int)(global_statistics.Retransmission-superframe_statistics.Retransmission), 10),
			double_to_string (mac_delay, 9),
			double_to_string (mac_delay_considering_dropped, 10),
			integer_to_string ((int)(global_statistics.Total_number_backoff_slots-superframe_statistics.Total_number_backoff_slots), 15),
			integer_to_string ((int)(global_statistics.Total_backoff_wait_for_beacon-superframe_statistics.Total_backoff_wait_for_beacon), strlen ("Beacon rcv backoff")),
			integer_to_string ((int)(Global_CCA_Statistics.First_CCA_count-Superframe_CCA_Statistics.First_CCA_count), 9),
			integer_to_string ((int)(global_statistics.Total_Ack_not_rcv-superframe_statistics.Total_Ack_not_rcv), 10),
			double_to_string ((op_sim_time ()-superframe_time_counter), strlen ("simulation time")));
	
		fclose (fp);
	
		
		superframe_statistics.Data_Pkt_Sent = global_statistics.Data_Pkt_Sent;
		superframe_statistics.Pkt_Dropped_CCA = global_statistics.Pkt_Dropped_CCA;
		Superframe_CCA_Statistics.First_CCA_Failure_Count = Global_CCA_Statistics.First_CCA_Failure_Count;
		superframe_time_counter = op_sim_time ();
		
		Wpan_Superframe_Statistics.Data_Pkt_Rcv = statistic.Data_Pkt_Rcv;
		Wpan_Superframe_Statistics.Total_MAC_Delay = statistic.Total_MAC_Delay;
		superframe_statistics.Total_Delay_Dropped_packets = global_statistics.Total_Delay_Dropped_packets;
		superframe_statistics.Application_generated = global_statistics.Application_generated;
		superframe_statistics.Segment_generated = global_statistics.Segment_generated;
		superframe_statistics.Pkt_not_enqueued = global_statistics.Pkt_not_enqueued;
		superframe_statistics.Data_Pkt_Rcv = global_statistics.Data_Pkt_Rcv;
		superframe_statistics.Pkt_Dropped = global_statistics.Pkt_Dropped;
		superframe_statistics.Pkt_Dropped_retx = global_statistics.Pkt_Dropped_retx;
		superframe_statistics.Retransmission = global_statistics.Retransmission;
		superframe_statistics.Total_number_backoff_slots = global_statistics.Total_number_backoff_slots;
		superframe_statistics.Total_backoff_wait_for_beacon = global_statistics.Total_backoff_wait_for_beacon;
		Superframe_CCA_Statistics.First_CCA_count = Global_CCA_Statistics.First_CCA_count;
		superframe_statistics.Total_Ack_not_rcv = global_statistics.Total_Ack_not_rcv;
		
		
																				
		superframe_reporting_counter = 1;
		}
	else
		superframe_reporting_counter++;
	
	
	
	
		
	
	/* for each device in the group, we create a beacon packet */
	for (i=0; i<lr_wpan_beacon_param.nb_addresses; i++)
		{
		/* init the pointer */

		//if(DEBUG_Tx_Beacon) printf("MAC MODULE: Node %s Tx Beacon at time %f sec\n", lr_wpan_node_name, op_sim_time());
		
		beacon_ptr = OPC_NIL;
		address = NULL;
		ctrl_field_ptr = NULL;
		superframe_spec_ptr = NULL;
		
		/* create a Beacon packet */
		beacon_ptr = op_pk_create_fmt ("lr_wpan_beacon_GADGET");
	
		/* create the address field, frame control, and the superframe specification */
		address = (Addressing_Field *) op_prg_mem_alloc (sizeof (Addressing_Field));
		ctrl_field_ptr = (Frame_Ctrl_Field *) op_prg_mem_alloc (sizeof (Frame_Ctrl_Field));
		superframe_spec_ptr = (Superframe_Spec_Field *) op_prg_mem_alloc (sizeof (Superframe_Spec_Field));		
		
		/* complete the address field */
		address->src_addr = my_parameters->mac_address;
		address->dest_addr = lr_wpan_beacon_param.addr_table[i];
		address->packet_pending = 0;
		
		/* complete the frame control field */
		ctrl_field_ptr->frame_type = WPAN_Beacon;

		
		
		/* complete the superframe specification field */
		superframe_spec_ptr->beacon_order       = sf_spec.beacon_order;
		superframe_spec_ptr->superframe_order   = sf_spec.superframe_order;
		superframe_spec_ptr->final_CAP_slot     = sf_spec.final_CAP_slot;
		superframe_spec_ptr->battery_life_ext   = sf_spec.battery_life_ext;
		superframe_spec_ptr->PAN_coordinator    = sf_spec.PAN_coordinator;
		superframe_spec_ptr->association_permit = sf_spec.association_permit;
		
		
		
		/* complete the address field */
		address->src_addr = my_parameters->mac_address;
		address->dest_addr = lr_wpan_beacon_param.addr_table[i];
		
		/* compute the beacon packet size */
		beacon_size = lr_wpan_get_beacon_size (address);
		
		/* Declare the protocol used if GADGET_enabled */
		if (GADGET_enabled)
			{
			/*set protocol used in beacon*/
			//protocol_used = GADGET_USE_S_ALOHA;
			if (op_pk_nfd_set (beacon_ptr, "protocol used", protocol_used) == OPC_COMPCODE_FAILURE)
				lr_wpan_mac_error ("lr_wpan_generate_beacon:", "Unable to set the Beacon packet.", OPC_NIL);
			}
		

		/* set the fields of the Beacon packet */
		if (op_pk_nfd_set (beacon_ptr, "Addressing field", address, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Addressing_Field)) == OPC_COMPCODE_FAILURE   ||
			op_pk_nfd_set_ptr (beacon_ptr, "Frame Ctrl", ctrl_field_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Frame_Ctrl_Field)) == OPC_COMPCODE_FAILURE  ||
			op_pk_nfd_set (beacon_ptr, "Superframe specification", superframe_spec_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Superframe_Spec_Field)) == OPC_COMPCODE_FAILURE ||
			op_pk_nfd_set (beacon_ptr, "Seqn", Mac_Beacon_Tx_Seqn) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("lr_wpan_generate_beacon:", "Unable to set the Beacon packet.", OPC_NIL);
	
		/* set the size of the packet */
		op_pk_total_size_set (beacon_ptr, beacon_size);
		
		/* search the mac address in the list of node to get the parameters of the destination node */
		if ((rx_index = wpan_search_mac_address (address->dest_addr)) == -1)
			lr_wpan_mac_error ("lr_wpan_generate_beacon:", "The MAC destination address doesn't exist.", OPC_NIL);
	
		/* get the parameter of the destination device */
		rxptr = (Wpan_Node_Param *) op_prg_list_access (wpan_node_param_list, rx_index);

		/* compute the distance between the RX and TX */
		txrx_distance = sqrt ((rxptr->x - my_parameters->x)*(rxptr->x - my_parameters->x) + (rxptr->y - my_parameters->y)*(rxptr->y - my_parameters->y));
		
		/* initialize the ICI structure */
		ici_ptr = OPC_NIL;
		
		/* create ICI pointer */
		ici_ptr = op_ici_create ("ici_channel");
			
		/* set the ICI pointer */
		if (op_ici_attr_set_dbl (ici_ptr, "txrx distance", txrx_distance) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "bit rate", LR_WPAN_BIT_RATE) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "channel", wpan_frequency_center) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "power", my_parameters->power) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_int32 (ici_ptr, "packet type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_int32 (ici_ptr, "dest address", address->dest_addr) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Tx x", my_parameters->x) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Tx y", my_parameters->y) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Rx x", rxptr->x) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Rx y", rxptr->y) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("lr_wpan_generate_beacon:", "Unable to set the ICI pointer.", OPC_NIL);
		
		/* Associate the ICI pointer with the beacon packet */
		op_pk_ici_set (beacon_ptr, ici_ptr);
		
		
		/* send the packet to the channel */
		op_pk_deliver (beacon_ptr, wpan_channel_objid, CHANNEL_UP_STREAM);
		}
	
	/* update the sequence number */
	Mac_Beacon_Tx_Seqn++;
	Mac_Beacon_Tx_Seqn %= MAX_MAC_SEQN;
	
	
	/* update the number of beacons sent */
	statistic.Beacon_Frame_Sent++;
	
	/* schedule the next Beacon packet */
	op_intrpt_schedule_self (op_sim_time () + beacon_interval_time, Wpan_Beacon_To_Send);
	
	if(DEBUG_Tx_Beacon)
	 fprintf (fp_debug, "MAC MODULE: Node %s enters Tx beacon time at %12f s -- Next beacon intrpt %12f s\n", lr_wpan_node_name, op_sim_time(), op_sim_time () + beacon_interval_time);	
	
	FOUT;
}
	

/*
 * Function:	lr_wpan_generate_data_request
 *
 * Description:	create a data request packet and send it
 *				to the master device in the same group
 *
 * ParamIn:		int dest_address
 *				MAC destination address of the master
 */

static void
lr_wpan_generate_data_request (void)
{
	Addressing_Field * address;
	Frame_Ctrl_Field * ctrl_field_ptr;
	int rx_index;
	double txrx_distance;
	Wpan_Node_Param * rxptr;
	Ici * ici_ptr;
	double deltax= 0.0;
	double deltay= 0.0;
	double deltaxSquare= 0.0;
	double deltaySquare= 0.0;
	
	
	FIN (lr_wpan_generate_data_request ());
		
	/* debugging */
	ENTER_STATE_ODB_PRINTING ("Create a data request packet.");
	
	/* init the pointer */
	address = NULL;
	ctrl_field_ptr = NULL;
		
	/* create a data request packet */
	lr_wpan_beacon_param.data_request = op_pk_create_fmt ("lr_wpan_mac");
	
	/* create the address field and the frame Ctrl */
	address = (Addressing_Field *) op_prg_mem_alloc (sizeof (Addressing_Field));
	ctrl_field_ptr = (Frame_Ctrl_Field *) op_prg_mem_alloc (sizeof (Frame_Ctrl_Field));
		
	/* complete the address field */
	address->src_addr = my_parameters->mac_address;
	address->dest_addr = lr_wpan_beacon_param.master_addr;
	
	/* complete the frame control field */
	ctrl_field_ptr->ack_req = Acknowledgement_Enable;
	
	/* set the fields of the Beacon packet */
	if (op_pk_nfd_set (lr_wpan_beacon_param.data_request, "Addressing field", address, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Addressing_Field)) == OPC_COMPCODE_FAILURE ||
		op_pk_nfd_set (lr_wpan_beacon_param.data_request, "Frame Ctrl", ctrl_field_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Frame_Ctrl_Field)) == OPC_COMPCODE_FAILURE ||
		op_pk_nfd_set_int32 (lr_wpan_beacon_param.data_request, "Request", 1) == OPC_COMPCODE_FAILURE)
		lr_wpan_mac_error ("lr_wpan_generate_data_request:", "Unable to set the data request packet.", OPC_NIL);
		
	/* set the size of the packet */
	op_pk_total_size_set (lr_wpan_beacon_param.data_request, WPAN_DATA_REQ_SIZE);
	
	/* search the mac address in the list of node to get the parameters of the destination node */
	if ((rx_index = wpan_search_mac_address (address->dest_addr)) == -1)
		lr_wpan_mac_error ("lr_wpan_generate_data_request:", "The MAC destination address doesn't exist.", OPC_NIL);
	
	/* get the parameter of the destination device */
	rxptr = (Wpan_Node_Param *) op_prg_list_access (wpan_node_param_list, rx_index);
	
	/* compute the distance between the RX and TX */
	deltax=rxptr->x - my_parameters->x;
	deltay=rxptr->y - my_parameters->y;
	
	deltaxSquare= deltax*deltax; //printf("ENQUEUE AT MAC: DeltaxSquare %f m\n", deltaxSquare);
    deltaySquare= deltay*deltay; //printf("ENQUEUE AT MAC: DeltaySquare %f m\n", deltaySquare);
	
	txrx_distance = sqrt(deltaxSquare + deltaySquare);
	//txrx_distance = sqrt ((rxptr->x - my_parameters->x)*(rxptr->x - my_parameters->x) + (rxptr->y - my_parameters->y)*(rxptr->y - my_parameters->y));
	
	/* initialize the ICI structure */
	ici_ptr = OPC_NIL;
	
	/* create ICI pointer */
	ici_ptr = op_ici_create ("ici_channel");
			
	/* set the ICI pointer */
	if (op_ici_attr_set_dbl (ici_ptr, "txrx distance", txrx_distance) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "bit rate", LR_WPAN_BIT_RATE) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "channel", wpan_frequency_center) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "power", my_parameters->power) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_int32 (ici_ptr, "packet type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_int32 (ici_ptr, "dest address", address->dest_addr) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Tx x", my_parameters->x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Tx y", my_parameters->y) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Rx x", rxptr->x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Rx y", rxptr->y) == OPC_COMPCODE_FAILURE)
		lr_wpan_mac_error ("lr_wpan_generate_beacon:", "Unable to set the ICI pointer.", OPC_NIL);
		
	/* Associate the ICI pointer with the beacon packet */
	op_pk_ici_set (lr_wpan_beacon_param.data_request, ici_ptr);
		
	
	FOUT;
}


/*
 * Function:	higher_layer_pkt_recv
 *
 * Description:	receive the packet from the higher
 *				layer and encapsulated the packet
 *				into a MAC packet
 *
 * No parameter
 */

static void 
higher_layer_pkt_recv (void)
{
	Packet * pkptr;
	Packet * higher_layer_pkptr;
	int higher_layer_pksize;
	int last_pksize, pk_number;
	Addressing_Field * address, * address_copy;
	Frame_Ctrl_Field * ctrl_field_ptr, * ctrl_field_copy;
	Wpan_Node_Param * rxptr;
	Ici * ici_ptr;
	int rx_index;
	double txrx_distance;
	int dest_mac_address;
	int i; // loop variable
	double deltax= 0.0;
	double deltay= 0.0;
	double deltaxSquare= 0.0;
	double deltaySquare= 0.0;
	Boolean packet_just_destroyed = OPC_FALSE;
	
	
	FIN (higher_layer_pkt_recv ());
	
	/* get the packet from the stream */
	higher_layer_pkptr = op_pk_get (intrpt_stream);
	
	/* if you enable the below, then messages will not be queued, i.e. nodes accept only one packet at a time.*/
	if(current_queue && ideal_poisson_traffic)	
		{
		if((current_queue->size>0)||((current_queue->size==0)&&(retransmission_ptr != OPC_NIL)))
			{
			op_pk_destroy(higher_layer_pkptr);
			global_statistics.Pkt_not_enqueued++;
			packet_just_destroyed = OPC_TRUE;
			}
		}
	
	//if(!current_queue || (current_queue && current_queue->size == 0 && retransmission_ptr == OPC_NIL))
	if(packet_just_destroyed == OPC_FALSE)
		{
		update_transmissions_list();
	
		if(DEBUG_MAC_Application) fprintf(fp_debug, "MAC MODULE: Node %s higher level pkt recv at time %12f sec\n", lr_wpan_node_name, op_sim_time());
			
		/* get the address of the packet */
		if (bulk_data_source)
			{
			/* if the packet source is a simple source, we just get the destination address from the packet */
			if (op_pk_nfd_get_int32 (higher_layer_pkptr, "Address", &dest_mac_address) == OPC_COMPCODE_FAILURE)
				lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to read the packet address.", OPC_NIL);
			}
		else
			{
			/* if we have the TCP/IP stack, we get the address in the ICI attached with the packet */
			/* Read ICI parameters at the stream interrupt.					*/
			ici_ptr = op_intrpt_ici ();

			/* Retrieve destination address from the ici set by the interface layer.	*/
			if (ici_ptr == OPC_NIL || op_ici_attr_get (ici_ptr, "dest_addr", &dest_mac_address) == OPC_COMPCODE_FAILURE)
				{
				/* Generate error message.	*/
				lr_wpan_mac_error ("higher_layer_pkt_recv:", "Destination address in not valid.", OPC_NIL);
				}
		
			/* update the statistics */
			statistic.tcp_HL_pkt_sent ++;
			statistic.tcp_HL_bit_sent += op_pk_total_size_get (higher_layer_pkptr);
			}
	
		/* create address field */
		address = (Addressing_Field *) op_prg_mem_alloc (sizeof (Addressing_Field));
	
		/* complete the address field */
		address->src_addr = my_parameters->mac_address;
		address->dest_addr = dest_mac_address;
	
		/* Create a frame control field */
		ctrl_field_ptr = (Frame_Ctrl_Field *) op_prg_mem_alloc (sizeof (Frame_Ctrl_Field));
	
		/* complete the frame control field */
		ctrl_field_ptr->ack_req = Acknowledgement_Enable;
		ctrl_field_ptr->frame_type = WPAN_Data;
	
		if ((rx_index = wpan_search_mac_address (dest_mac_address)) == -1)
			lr_wpan_mac_error ("higher_layer_pkt_recv:", "The MAC destination address doesn't exist.", OPC_NIL);
	
		/* get the parameter of the destination device */
		rxptr = (Wpan_Node_Param *) op_prg_list_access (wpan_node_param_list, rx_index);
		
		/* compute the distance between the RX and TX */
		deltax=rxptr->x - my_parameters->x;
		deltay=rxptr->y - my_parameters->y;
	
		deltaxSquare= deltax*deltax; //if(DEBUG_MAC_Application) printf("ENQUEUE AT MAC: DeltaxSquare %f m\n", deltaxSquare);
		deltaySquare= deltay*deltay; //if(DEBUG_MAC_Application) printf("ENQUEUE AT MAC: DeltaySquare %f m\n", deltaySquare);
	
		txrx_distance = sqrt(deltaxSquare + deltaySquare);
	
		//txrx_distance = sqrt ((rxptr->x - my_parameters->x)*(rxptr->x - my_parameters->x) + (rxptr->y - my_parameters->y)*(rxptr->y - my_parameters->y));
	
		//if(DEBUG_MAC_Application) printf("MAC MODULE: Node %s has a packet from the application with Tx-Rx distance = %f \n", lr_wpan_node_name, txrx_distance);
	
	
		/* compute the size of the higher layer packet */
		higher_layer_pksize = (int) op_pk_total_size_get (higher_layer_pkptr);
		/* start the segmentation */
		if (higher_layer_pksize > WPAN_PAYLOAD_MAX_SIZE)
			{
			/* dimension of the last packet */
			last_pksize = higher_layer_pksize%WPAN_PAYLOAD_MAX_SIZE;
		
			/* compute the number of packet */
			pk_number = (higher_layer_pksize - last_pksize)/WPAN_PAYLOAD_MAX_SIZE;
			}
		else
			{
			pk_number = 0;
			last_pksize = higher_layer_pksize;
			}
	
		/* 
		* if the last packet size is null, we decrease the number of packets by one
		* to be able to create the last packet with the address of the real packet
		*/
		if (last_pksize == 0)
			{
			/* decrease the loop number */
			pk_number--;
		
			/* the last packet size will be equal to WPAN_PAYLOAD_MAX_SIZE */
			last_pksize = WPAN_PAYLOAD_MAX_SIZE;
			}
	
		for (i=0; i<pk_number; i++)
			{
			/* initialize the ICI structure */
			ici_ptr = OPC_NIL;
		
			/* create ICI pointer */
			ici_ptr = op_ici_create ("ici_channel");
			
			/* set the ICI pointer */
			if (op_ici_attr_set_dbl (ici_ptr, "txrx distance", txrx_distance) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "bit rate", LR_WPAN_BIT_RATE) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "channel", wpan_frequency_center) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "power", my_parameters->power) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_int32 (ici_ptr, "packet type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_int32 (ici_ptr, "dest address", dest_mac_address) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "Tx x", my_parameters->x) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "Tx y", my_parameters->y) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "Rx x", rxptr->x) == OPC_COMPCODE_FAILURE ||
				op_ici_attr_set_dbl (ici_ptr, "Rx y", rxptr->y) == OPC_COMPCODE_FAILURE)
				lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to set the ICI pointer.", OPC_NIL);
		
			/* create a MAC packet */
			pkptr = op_pk_create_fmt ("lr_wpan_mac");
		
			/* copy the address field and the frame Ctrl */
			address_copy = (Addressing_Field *) op_prg_mem_copy_create (address, sizeof (Addressing_Field));
			ctrl_field_copy = (Frame_Ctrl_Field *) op_prg_mem_copy_create (ctrl_field_ptr, sizeof (Frame_Ctrl_Field));
		
			/* set the fields of the MAC packet */
			if (op_pk_nfd_set_ptr (pkptr, "Frame Ctrl", ctrl_field_copy, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Frame_Ctrl_Field)) == OPC_COMPCODE_FAILURE ||
				op_pk_nfd_set (pkptr, "Addressing field", address_copy, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Addressing_Field)) == OPC_COMPCODE_FAILURE)
				lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to set the MAC packet.", OPC_NIL);
		
			/* set the size of the packet */
			op_pk_total_size_set (pkptr, WPAN_MAC_MAX_SIZE);
		
			/* Associate the ICI pointer with this packet */
			op_pk_ici_set (pkptr, ici_ptr);
				
			/* enqueue the packet */
			lr_wpan_enqueue_packet (dest_mac_address, pkptr);
			}
	
		/* we create the last packet with a pointer to the real higher layer packet */
		/* initialize the ICI structure */
		ici_ptr = OPC_NIL;
		
		/* create ICI pointer */
		ici_ptr = op_ici_create ("ici_channel");
	
		/* set the ICI pointer */
		if (op_ici_attr_set_dbl (ici_ptr, "txrx distance", txrx_distance) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "bit rate", LR_WPAN_BIT_RATE) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "channel", wpan_frequency_center) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "power", my_parameters->power) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_int32 (ici_ptr, "packet type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_int32 (ici_ptr, "dest address", address->dest_addr) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Tx x", my_parameters->x) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Tx y", my_parameters->y) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Rx x", rxptr->x) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (ici_ptr, "Rx y", rxptr->y) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to set the ICI pointer.", OPC_NIL);
		
		/* create a MAC packet */
		pkptr = op_pk_create_fmt ("lr_wpan_mac");
	
	
		/* set the fields of the MAC packet */
		if (op_pk_nfd_set_int32 (pkptr, "Segmentation", 1) == OPC_COMPCODE_FAILURE ||
			op_pk_nfd_set_pkt (pkptr, "Higher Layer Pkt", higher_layer_pkptr) == OPC_COMPCODE_FAILURE ||
			op_pk_nfd_set_ptr (pkptr, "Frame Ctrl", ctrl_field_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Frame_Ctrl_Field)) == OPC_COMPCODE_FAILURE ||
			op_pk_nfd_set (pkptr, "Addressing field", address, op_prg_mem_copy_create, op_prg_mem_free, sizeof (Addressing_Field)) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to set the MAC packet.", OPC_NIL);
	
		/* set the size of the packet */
		op_pk_total_size_set (pkptr, last_pksize + WPAN_HEADER_SIZE);
	
		/* Associate the ICI pointer with this packet */
		op_pk_ici_set (pkptr, ici_ptr);
		
		/* enqueue the packet */
		lr_wpan_enqueue_packet (dest_mac_address, pkptr);
		}
	
	FOUT;
}

static void update_transmissions_list()
{
	tx* elem_ptr;
	//tx* elem_ptr_global;

	FIN (update_transmissions_list())
	
	elem_ptr = (tx*) op_prg_mem_alloc( sizeof(tx) );
	//elem_ptr_global = (tx*) op_prg_mem_alloc( sizeof(tx) );
	
	elem_ptr->time = op_sim_time();
	elem_ptr->transmissions = statistic.Segment_generated + 1;
			
	op_prg_list_insert(statistic_tx_list_ptr, elem_ptr, OPC_LISTPOS_TAIL);
	
	//elem_ptr_global->time = op_sim_time();
	//elem_ptr_global->transmissions = global_statistics.Segment_generated + 1;
	
	//op_prg_list_insert(list_tx_ptr_global, elem_ptr_global, OPC_LISTPOS_TAIL);
	
	FOUT;
}

/*
 * Function:	lower_layer_pkt_rcv
 *
 * description:	Received all the packet from the
 *				lower layer
 *
 * No Parameter
 */

static void
lower_layer_pkt_rcv (void)
{
	Packet * pkptr, *higher_layer_pkptr = NULL;
	char format[32];
	Addressing_Field * addr_field;
	Frame_Ctrl_Field * frame_ctrl_ptr;
	int last_packet;
	int seqn;
	int accept;
	int noise;
	int service_ind=0;
	double service_time_duration;
	Ici * ici_ptr;
	Ici * ici_ptr_coordinator;
	double rx_x, tx_x, rx_y, tx_y, power;
	//int wpan_bulk_data_id;
	
	int packet_size;
	
	double power_packet_w, distance_transmitter, delta_x, delta_y, temp_snr;
	
	
	FIN (lower_layer_pkt_rcv ());
		
	/* get the packet from the stream */
	pkptr = op_pk_get (intrpt_stream);
		
	/* get the accept flag */
	op_pk_nfd_get_int32 (pkptr, "Accept", &accept);
	
	/* get the noise flag */
	op_pk_nfd_get_int32 (pkptr, "Noise", &noise);
	//printf("noise flag is %d\n", noise);
	
	/* get the format of the packet */
	op_pk_format (pkptr, format);
	
	/* 
	* if this is a WPAN MAC data packet, check if a higher layer
	* is in there
	*/
	if (!strcmp (format, "lr_wpan_mac"))
		{
		/* get the higher layer packet if the segmentation flag is true */
		op_pk_nfd_get_int32 (pkptr, "Segmentation", &last_packet);
		
		if (last_packet)
			{
			/*
			* if this is the last segment received,
			* we get the higher layer packet
			*/
			op_pk_nfd_get_pkt (pkptr, "Higher Layer Pkt", &higher_layer_pkptr);
			}
		}
	
	
	if (Rx_Ack_Expected && !strcmp (format, "lr_wpan_ack"))
		if(DEBUG_Rx_Ack) fprintf(fp_debug, "MAC MODULE: Node %s receives Ack at time %12f sec -- accept = %d -- noise = %d -- with tx_idle flag = %d and rx_idle flag = %d\n", lr_wpan_node_name, op_sim_time(), accept, noise, channel_flag.tx_idle, channel_flag.rx_idle);
	
	/*if (!Rx_Ack_Expected && !strcmp (format, "lr_wpan_mac"))
		if(DEBUG_Rx_Data) 
			fprintf(fp_debug, "MAC MODULE: Node %s receives data at time %12f sec -- accept = %d -- noise = %d -- with rx_idle flag = %d\n", lr_wpan_node_name, op_sim_time(), accept, noise, channel_flag.rx_idle);
		*/
		
	/* if the RX flag is not idle or the packet is not accepted, we discard the packet */
	if (!channel_flag.rx_idle || !accept || noise)
		{
		/* debugging */
		if (!channel_flag.rx_idle)
			{
			ENTER_STATE_ODB_PRINTING ("packet is  collided or bad");
			(statistic.Pkt_Collided)++;
			(global_statistics.Pkt_Collided)++;
			
			//if(GADGET_enabled && !strcmp (format, "lr_wpan_mac")) 
			//	GADGET_SUPERFRAME_TRAFFIC++;	//traffic perceived on the channel even though collision or bad
			
			if (!strcmp (format, "lr_wpan_beacon_GADGET"))    
				(statistic.Beacon_Frame_Collided)++;  
				}
		else if (noise)
			{
			ENTER_STATE_ODB_PRINTING ("packet is considered as noise");
			(statistic.Pkt_Noise)++;
			(global_statistics.Pkt_Noise)++;
			
			if (!strcmp (format, "lr_wpan_beacon_GADGET")) 
				(statistic.Beacon_Frame_Noise)++;  
			}
		else if (!accept)
			{
			ENTER_STATE_ODB_PRINTING ("packet is lost due to interference");
			(statistic.Pkt_Lost)++;	
			(global_statistics.Pkt_Lost)++;
			
			//if(GADGET_enabled && !strcmp (format, "lr_wpan_mac"))
			//	GADGET_SUPERFRAME_TRAFFIC++;	//traffic perceived on the channel

			if (!strcmp (format, "lr_wpan_beacon_GADGET"))  
				(statistic.Beacon_Frame_Lost)++;	 
			}
		
		op_prg_odb_bkpt ("collision");
   		/* check if a higher layer packet is set */
		if (higher_layer_pkptr != NULL)
			{
			/* destroy the higher layer packet */
			op_pk_destroy (higher_layer_pkptr);
			}
		
		/* destroy the packet */
		op_pk_destroy (pkptr);
		FOUT;
		}
	
	/*
	 * Check the type of the received packet:
	 *		* if it's a beacon packet, we schedule 
	 */
	if (!strcmp (format, "lr_wpan_beacon_GADGET"))
		{
		/* debugging */
		ENTER_STATE_ODB_PRINTING ("Beacon Frame received.");
			
		/* update the flag */
		lr_wpan_beacon_param.beacon_rcvd = OPC_TRUE;
		
		/* update the number of beacons receievd */
		statistic.Beacon_Frame_Rcv++;

			
		if(my_parameters->slotted_enable && !my_parameters->master_enable)
			lr_wpan_process_rcvd_beacon_frame(pkptr);
	
		/* get the address field */
		if (op_pk_nfd_get_ptr (pkptr, "Addressing field", &addr_field) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("lower_layer_pkt_rcv:", "Unable to get the address field of the Beacon frame.", OPC_NIL);
		
		/* get the MAC address of the master */
		if (lr_wpan_beacon_param.master_addr == -1)
			lr_wpan_beacon_param.master_addr = addr_field->src_addr;
		
		if (addr_field->packet_pending != 0)
			{
			/* schedule a data request to send if some packets are pending */
			op_intrpt_schedule_self (lr_wpan_slotted_boundary_time (), Wpan_Data_Req_To_Send);
			}
		else if (wpan_transmission_required)
			{
			/*
			 * otherwise, if no packets are pending and if we need to send a data,
			 * we schedule the transmission
			 */
			//if(DEBUG_BEACON_RCVD) printf("MAC MODULE: Node %s At time %f sec schedule intrp code %d\n", lr_wpan_node_name,lr_wpan_slotted_boundary_time (), Data_Pkt_To_Send);
			op_intrpt_schedule_self (lr_wpan_slotted_boundary_time (), Data_Pkt_To_Send);
			}
		
		/* destroy the packet */
		op_pk_destroy (pkptr);			
		}
	else if (!Rx_Ack_Expected && !strcmp (format, "lr_wpan_mac"))
		{    
		/* Get the size of the recieved packet*/
		packet_size = (int) op_pk_total_size_get (pkptr);
		
		if(GADGET_enabled)
			{
			/*SNR recalculation from channel*/
			/* compute snr*/
			if(!strcmp(lr_wpan_node_name,"coordinator"))
				{
			
				/* get the received ICI */
				if ((ici_ptr_coordinator = op_pk_ici_get (pkptr)) == OPC_NIL)
					printf ("lr_wpan_chan_buffer_insert, No ICI associates with the current packet\n");
	
				if (ici_ptr_coordinator == NULL || ici_ptr_coordinator == OPC_NIL)
					printf ("lr_wpan_chan_buffer_insert: Invalid ICI\n");
	
			
				/* get information from the ici */
				if (op_ici_attr_get (ici_ptr_coordinator, "power", &power) == OPC_COMPCODE_FAILURE ||
					op_ici_attr_get (ici_ptr_coordinator, "Tx x", &tx_x) == OPC_COMPCODE_FAILURE ||
					op_ici_attr_get (ici_ptr_coordinator, "Tx y", &tx_y) == OPC_COMPCODE_FAILURE ||
					op_ici_attr_get (ici_ptr_coordinator, "Rx x", &rx_x) == OPC_COMPCODE_FAILURE ||
					op_ici_attr_get (ici_ptr_coordinator, "Rx y", &rx_y) == OPC_COMPCODE_FAILURE)
					printf ("lr_wpan_chan_buffer_insert cannot read the ICI attributes\n");
	
				//op_ici_attr_get (ici_ptr, "piconet number", &piconet_number) == OPC_COMPCODE_FAILURE)
				//lr_wpan_chan_error ("lr_wpan_chan_buffer_insert", "cannot read the ICI attributes", OPC_NIL);
			
			
				delta_x = rx_x - tx_x;
				delta_y = rx_y - tx_y;
				distance_transmitter = sqrt (delta_x * delta_x + delta_y * delta_y);
		
				power_packet_w = power;
	
				//It gives the SNR in dB, without implementation loss
				//snr = snr_15_4a (info_packet->frequency, power_packet_w, distance_transmitter);
				//With imolementation loss
				temp_snr = snr_15_4a (wpan_frequency_center, power_packet_w, distance_transmitter) - IMPLEMENTATION_LOSS;
			
				//to compute average snr
				GADGET_snr = GADGET_snr + temp_snr;
				GADGET_pkt_per_superframe++;
	
				//debug SNR
				//printf ("packet SNR = %f, packets in superframe = %d\n", GADGET_snr, GADGET_pkt_per_superframe);
				}
			//GADGET_SUPERFRAME_TRAFFIC++;
			}
		/*------------------------------------------------*/
		
		
		//if(DEBUG_Rx_Data)printf("MAC MODULE: Node %s receives data at time %f sec\n", lr_wpan_node_name, op_sim_time());

		
		/* get the sequence number of the Data packet */
		op_pk_nfd_get_int32 (pkptr, "Seqn", &seqn);
		
		/* look if the packet is a data request */
		op_pk_nfd_get_int32 (pkptr, "Request", &lr_wpan_beacon_param.data_req_rcvd);
		
		/* get the address field of the packet */
		op_pk_nfd_get_ptr (pkptr, "Addressing field", &addr_field);
		
		
		/* get the frame control field */
		op_pk_nfd_get_ptr (pkptr, "Frame Ctrl", &frame_ctrl_ptr);
		
		
		/* get the source MAC address of the packet for the acknowledgment */
		Ack_Dest_Addr = addr_field->src_addr;
		
		/* schedule the acknowledgment transmission */
		Tx_Ack_Require = frame_ctrl_ptr->ack_req;
		
		
		if(DEBUG_Rx_Data) 
			fprintf(fp_debug, "Node %s: Packet received from node %d at time %f\n", lr_wpan_node_name, addr_field->src_addr, op_sim_time());
		
		
		/* if the packet sequence number is correct */
		if (seqn != lr_wpan_get_rx_seqn (addr_field->src_addr))
			{
			/* update the sequence number */
			lr_wpan_set_rx_seqn (addr_field->src_addr, seqn);
			
					
			/* update the statistic */
			statistic.Data_Pkt_Rcv ++;
			
			
			op_stat_write(nb_pkt_recv, statistic.Data_Pkt_Rcv);
			
			
			global_statistics.Data_Pkt_Rcv ++;  
			global_statistics.Total_Bits_Rcv += packet_size;
			
			
			
			statistic.Total_MAC_Delay += op_sim_time () - op_pk_stamp_time_get (pkptr);
			
			/*evaluate frame service time*/
			if (s_aloha_enabled)
				{
				service_time_duration = op_pk_stamp_time_get (pkptr);
				service_ind = ceil((op_sim_time () - service_time_duration)/(aBaseSlotDuration/LR_WPAN_BIT_RATE));
				if (service_ind >= MAX_SERV_TIME)
					service_ind = (MAX_SERV_TIME-1);
				frame_service_time[service_ind]++;
				}
			else if (psma_enabled)
				{
				service_time_duration = op_pk_stamp_time_get (pkptr);
				service_ind = ceil((op_sim_time () - service_time_duration)/(aBaseSlotDuration/(2*LR_WPAN_BIT_RATE)));
				if (service_ind >= MAX_SERV_TIME)
					service_ind = (MAX_SERV_TIME-1);
				frame_service_time[service_ind]++;
				}
			else
				printf("Lower Layer Packet Receive: No recognised MAC protocol enabled\n");
			
			//fprintf(fp_debug, "%s Service time in slots %f\n", lr_wpan_node_name, (op_sim_time () - service_time_duration)/(aBaseSlotDuration/LR_WPAN_BIT_RATE));
			
			//printf("Cumulative Delay per data pkt rcv= %f sec\n", statistic.Total_MAC_Delay);
			
			/*
			* if we have a higher layer packet in there,
			* we forward it to the higher layer
			*/
			if (higher_layer_pkptr != NULL)
				{
				/* check if we have a simple source */
				if (bulk_data_source)
					{
					/* forward the packet to the higher layer */
					op_pk_send (higher_layer_pkptr, HIGHER_LAYER_UP_STRM);
					}
				else
					{
					/* create an ICI for the LLC layer */
					ici_ptr = op_ici_create ("wlan_mac_ind");
					
					/* set the ICI */
					if (op_ici_attr_set_int32 (ici_ptr, "dest_addr", my_parameters->mac_address) == OPC_COMPCODE_FAILURE ||
						op_ici_attr_set_int32 (ici_ptr, "src_addr", addr_field->src_addr) == OPC_COMPCODE_FAILURE)
						lr_wpan_mac_error ("lower_layer_pkt_rcv:", "Unable to set the LLC ICI pointer.", OPC_NIL);
					
					/* update the statistics */
					statistic.tcp_HL_pkt_rcvd ++;
					statistic.tcp_HL_bit_rcvd += op_pk_total_size_get (higher_layer_pkptr);
					
					/* install the ici */
					op_ici_install (ici_ptr);
					
					/* forward the packet to the higher layer */
					op_pk_send (higher_layer_pkptr, HIGHER_LAYER_UP_STRM);
					
					/* de-install the ici */
					op_ici_install (OPC_NIL);
					}
				}
			}
		else
			{
			/* debugging */
			ENTER_STATE_ODB_PRINTING ("Bad Sequence number.");
		
			if (higher_layer_pkptr != NULL)
				{
				/* discard the higher layer packet */
				op_pk_destroy (higher_layer_pkptr);
				}
			}
				
		/* free the memory */
		op_prg_mem_free (addr_field);
		op_prg_mem_free (frame_ctrl_ptr);
		
		/* destroy the packet */
		op_pk_destroy (pkptr);
		
		}
	else if (Rx_Ack_Expected && !strcmp (format, "lr_wpan_ack"))
		{
		
		//if(DEBUG_Rx_Ack) printf("MAC MODULE: Node %s receives Ack at time %f sec\n", lr_wpan_node_name, op_sim_time());
		
		/* destroy the packet */
		op_pk_destroy (pkptr);
		
		/* update the flag */
		Rx_Ack_Expected = OPC_FALSE;
		
		/* destroy the retransmission packet */
		lr_wpan_destroy_retransmission ();
		
		/* update the sequence number */
		Mac_Data_Tx_Seqn++;
		Mac_Data_Tx_Seqn %= MAX_MAC_SEQN;
		
		/* reset backoff parameters */
		lr_wpan_reset_backoff_parameters();
		
		/* schedule the exit of the state */
		op_intrpt_schedule_self (op_sim_time (), Ack_Received);
		
		/* update the statistic */
		statistic.Ack_Pkt_Rcv ++;
		
		op_stat_write(nb_ack_stat_handle, statistic.Ack_Pkt_Rcv);
		

			node_statistics.Data_Bits_Correctly_Sent  = node_statistics.Data_Bits_Correctly_Sent + last_transmitted_pkt_size - WPAN_HEADER_SIZE; 
			last_transmitted_pkt_size = 0;
			node_statistics.Data_Delay = node_statistics.Data_Delay + op_sim_time () - last_tx_pkt_time_generation - last_transmitted_pkt_size/LR_WPAN_BIT_RATE ;
			last_tx_pkt_time_generation = 0;
		
		
		}
	else
		{
		/* debugging */
		ENTER_STATE_ODB_PRINTING ("WPAN Packet not accepted by the MAC layer.");
		
		/* check if a higher layer packet is set */
		if (higher_layer_pkptr != NULL)
			{
			/* discard the higher layer packet */
			op_pk_destroy (higher_layer_pkptr);
			}
		
		/* discard the packet */
		op_pk_destroy (pkptr);
		}
	
	FOUT;
}



/* 
 * Function: lr_wpan_process_rcvd_beacon_frame
 *
 * Description: Process a received beacon frame 
 *
 */

static void lr_wpan_process_rcvd_beacon_frame(Packet * wpan_rcvd_frame_ptr)
	{	
	
	int rcvd_sequence_number;
	int rcvd_beacon_length;
	int protocol_used;
	int i = 0;
	int j = 0;
	Frame_Ctrl_Field *frame_ctrl_field;
	Superframe_Spec_Field *superframe_spec_field;
	double beacon_transmission_time;
	int backoff_periods_per_beacon;
	
	FIN (lr_wpan_process_rcvd_beacon_frame(Packet *wpan_rcvd_frame_ptr));
	
	superframe_spec_field = (Superframe_Spec_Field *) op_prg_mem_alloc (sizeof (Superframe_Spec_Field));
	frame_ctrl_field = (Frame_Ctrl_Field *) op_prg_mem_alloc (sizeof (Frame_Ctrl_Field ));
	
		
	/* Get the length of the beacon in bits */
	  rcvd_beacon_length = op_pk_total_size_get(wpan_rcvd_frame_ptr);
	/* get frame control fields */ 
	if (op_pk_nfd_get_ptr (wpan_rcvd_frame_ptr, "Frame Ctrl", &frame_ctrl_field) == OPC_COMPCODE_FAILURE)
			lr_wpan_mac_error ("process_rcvd_beacon_frame:", "Unable to get the frame control field of the Beacon frame.", OPC_NIL);
	/* get the superframe specification field */
	if (op_pk_nfd_get_ptr (wpan_rcvd_frame_ptr, "Superframe specification", &superframe_spec_field) == OPC_COMPCODE_FAILURE)
		lr_wpan_mac_error ("process_rcvd_beacon_frame:", "Unable to get the superframe specification field of the Beacon frame.", OPC_NIL);
	sf_spec.beacon_order     = superframe_spec_field->beacon_order;
	sf_spec.superframe_order = superframe_spec_field->superframe_order;
	sf_spec.final_CAP_slot   = superframe_spec_field->final_CAP_slot;
	sf_spec.battery_life_ext = superframe_spec_field->battery_life_ext;
	sf_spec.PAN_coordinator  = superframe_spec_field->PAN_coordinator;
	
	/* Sequence number */
	op_pk_nfd_get(wpan_rcvd_frame_ptr, "Seqn", &rcvd_sequence_number);
	
	/*Get protocol used if GADGET_enabled*/
	if (GADGET_enabled)
		{
		op_pk_nfd_get(wpan_rcvd_frame_ptr, "protocol used", &protocol_used);
		/*if(!strcmp(lr_wpan_node_name, "dev80"))
			printf("%s: Protocol to be used (Slotted ALOHA %d PSMA %d): %d\n", lr_wpan_node_name, GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);*/
		/*Check if protocol need changing*/
		if ((s_aloha_enabled && protocol_used != GADGET_USE_S_ALOHA) || (psma_enabled && protocol_used != GADGET_USE_PSMA))
			{
			/*change is required*/
			/*set the coordinators own MAC protocol appropriately*/
			if(!strcmp(lr_wpan_node_name, "dev80"))
				printf("%s: Protocol change! New (Slotted ALOHA %d PSMA %d): %d\n", lr_wpan_node_name, GADGET_USE_S_ALOHA, GADGET_USE_PSMA, protocol_used);
			if (protocol_used == GADGET_USE_PSMA)
				{
				s_aloha_enabled = OPC_FALSE;	//others are set as OPC_FALSE
				psma_enabled = OPC_TRUE;		//protocol with the best Goodness with highest traffic range is set OPC_TRUE
				}
			else if (protocol_used == GADGET_USE_S_ALOHA)
				{
				s_aloha_enabled = OPC_TRUE;	
				psma_enabled = OPC_FALSE;
				}
			else
				{
				printf("Unknown MAC protocol - %d - at time = %f\n", protocol_used, op_sim_time ());
				s_aloha_enabled = OPC_FALSE;
				psma_enabled = OPC_TRUE; //used psma as default, if problems occur.
				}
			
			/*reset MAC backoff parameters and begin the current frame in buffer anew*/
			if(!strcmp(lr_wpan_node_name, "dev80"))
				printf("%s: Resetting backoff, old values: nb_retries = %d, BE = %d, N_backoff %d\n", lr_wpan_node_name, nb_transmission_retries, csma_parameters.Be , csma_parameters.nb_backoff);
			lr_wpan_reset_backoff_parameters();
			/* reset the transmission retries counter */
			nb_transmission_retries = 0;
			
			/*Recalculate appropriate slot units as per protocol*/
			if(psma_enabled)
				{
				psma_time_to_tx = OPC_FALSE;
			
				aUnitBackoffPeriod = aBaseSlotDuration/2;//symbols
			
				/* backoff time unit (in seconds) */
				LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
				LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
				}
			if(s_aloha_enabled)
				{
				aUnitBackoffPeriod = aBaseSlotDuration;//symbols
			
				/* backoff time unit (in seconds) */
				LR_WPAN_BACKOFF_UNIT = (aUnitBackoffPeriod*LR_WPAN_BITS_PER_SYMBOL)/LR_WPAN_BIT_RATE;
				LR_WPAN_BACKOFF_PERIOD_DURATION = LR_WPAN_BACKOFF_UNIT;
				}

			}
		
		}
	 	
	  sf_param.beacon_interval_symbols  = aBaseSuperframeDuration*(pow(2, sf_spec.beacon_order));
	  sf_param.beacon_interval_seconds  = sf_param.beacon_interval_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;  
      sf_param.superframe_duration_symbols = aBaseSuperframeDuration*(pow(2, sf_spec.superframe_order));  
	  sf_param.superframe_duration_seconds = sf_param.superframe_duration_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE; 
	  sf_param.superframe_start_time = op_sim_time() - (rcvd_beacon_length + LR_WPAN_PHY_OVERHEAD)/LR_WPAN_BIT_RATE;								  
	  sf_param.inactive_period_symbols = sf_param.beacon_interval_symbols - sf_param.superframe_duration_symbols;
	  sf_param.inactive_period_seconds = sf_param.inactive_period_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;
	  sf_param.slot_duration_symbols = aBaseSlotDuration*(pow(2, sf_spec.superframe_order));  	
 	  sf_param.slot_duration_seconds = sf_param.slot_duration_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;  
	  sf_param.backoff_periods_per_superframe = sf_param.beacon_interval_symbols/aUnitBackoffPeriod;
	  sf_param.backoff_periods_per_slot = sf_param.slot_duration_symbols/aUnitBackoffPeriod;
	  sf_param.CAP_period_length_symbols = (sf_spec.final_CAP_slot+1)*sf_param.slot_duration_symbols;
	  sf_param.CAP_period_length_seconds =  sf_param.CAP_period_length_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE;  
	  sf_param.GTS_period_length_symbols = sf_param.superframe_duration_symbols - sf_param.CAP_period_length_symbols;
	  sf_param.GTS_period_length_seconds = sf_param.GTS_period_length_symbols*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE; 
   	  sf_param.backoff_periods_per_CAP   = sf_param.CAP_period_length_symbols/aUnitBackoffPeriod;
	  sf_param.end_of_the_CAP_period = sf_param.superframe_start_time + sf_param.CAP_period_length_seconds;
	  sf_param.CAP_start_time = op_sim_time();
		  	
	  Wpan_CAP_Period_End_evh = op_intrpt_schedule_self(sf_param.superframe_start_time + sf_param.CAP_period_length_seconds, Wpan_CAP_Period_End);
	  
	  beacon_transmission_time = (op_sim_time() - sf_param.superframe_start_time)/LR_WPAN_BACKOFF_PERIOD_DURATION;
   	  backoff_periods_per_beacon = ceil (beacon_transmission_time);
	  sf_param.remaining_CAP_backoff_periods = sf_param.backoff_periods_per_CAP - backoff_periods_per_beacon;
	 	  
	  op_intrpt_schedule_self(sf_param.superframe_start_time + backoff_periods_per_beacon*LR_WPAN_BACKOFF_PERIOD_DURATION, Wpan_Backoff_Period_Elapsed);
	
	if(DEBUG_BEACON_RCVD)
	 fprintf (fp_debug, "MAC MODULE: Node %s -- Beacon reception time = %.12f -- Next backoff boundary at %.12f s\n", lr_wpan_node_name, op_sim_time(), (sf_param.superframe_start_time + backoff_periods_per_beacon*LR_WPAN_BACKOFF_PERIOD_DURATION));	

	  for(i=0; i < sf_param.backoff_periods_per_superframe; i++)
		  {
		  sf_param.backoff_period_boundary_symbols[i] = aUnitBackoffPeriod*(i+1);
		  if( ( ((aUnitBackoffPeriod*(i+1)) % sf_param.backoff_periods_per_slot) == 0) && j < 16 )
			  {
			  sf_param.time_slot_boundary_symbols[j] = aUnitBackoffPeriod*(i+1);
			  j++;
			  }
		  }
	
	  sf_param.backoff_period_index = backoff_periods_per_beacon -1;
	  sf_param.time_slot_index = 0;
		
	  if(sf_param.GTS_period_length_symbols > 0)
		  {

		  sf_param.has_GTS_period = OPC_TRUE;
		  }
	  else 
		  sf_param.has_GTS_period = OPC_FALSE;
		  
	  if(sf_param.inactive_period_seconds > 0)
		  sf_param.has_inactive_period = OPC_TRUE;
	  else 
		  sf_param.has_inactive_period = OPC_FALSE;
	  
  	  sf_param.CAP_PERIOD_ACTIVE = OPC_TRUE;
	  sf_param.GTS_PERIOD_ACTIVE = OPC_FALSE;
  	  sf_param.INACTIVE_PERIOD   = OPC_FALSE;
	  csma_operation_param.wait_for_the_next_superframe = OPC_FALSE;
	  
	/*	 
      if(DEBUG_BEACON_RCVD)
      {
     	//if(!strcmp(lr_wpan_node_name, "node_0"))
		{
		printf("(%s) Beacon_interval (seconds) = %f \n",    	lr_wpan_node_name , sf_param.beacon_interval_seconds );	 
	    printf("(%s) Superframe duration (seconds) = %f \n", 	lr_wpan_node_name , sf_param.superframe_duration_seconds );  
	    printf("(%s) CAP period length (seconds) = %f \n", 	lr_wpan_node_name , sf_param.CAP_period_length_seconds ); 
	    printf("(%s) Superframe start time = %f \n",   		lr_wpan_node_name , sf_param.superframe_start_time );
	    printf("(%s) Current time = %f \n",   				lr_wpan_node_name , op_sim_time() );
		printf("(%s) Slot duration (symbols) = %d \n",   		lr_wpan_node_name , aBaseSlotDuration );
		printf("(%s) Slot duration (seconds) = %f \n",   		lr_wpan_node_name , sf_param.slot_duration_seconds );
		printf("(%s) LR_WPAN_BACKOFF_UNIT (seconds) = %f \n",   lr_wpan_node_name , LR_WPAN_BACKOFF_UNIT );
		printf("(%s) LR_WPAN_BACKOFF_PERIOD_DURATION (seconds) = %f \n",   	lr_wpan_node_name , LR_WPAN_BACKOFF_PERIOD_DURATION );
	    printf("(%s) Backoff periods per slot = %d \n",   		lr_wpan_node_name , sf_param.backoff_periods_per_slot ); 
	    printf("(%s) Backoff periods per CAP = %d \n",   		lr_wpan_node_name , sf_param.backoff_periods_per_CAP );
		printf("(%s) Beacon transmission time (seconds) = %f \n",   		lr_wpan_node_name , (op_sim_time() - sf_param.superframe_start_time) );
		printf("(%s) Backoff periods per beacon = %d \n",   		lr_wpan_node_name , backoff_periods_per_beacon );
	    printf("(%s) Remaining backoff periods = %d \n",   		lr_wpan_node_name , sf_param.remaining_CAP_backoff_periods); 
	    printf("(%s) End of the CAP periods = %f \n",   		lr_wpan_node_name , sf_param.end_of_the_CAP_period); 
	    printf("(%s) CAP period active = %s \n",   		lr_wpan_node_name , sf_param.CAP_PERIOD_ACTIVE ? "OPC_TRUE" : "OPC_FLASE");
		printf("MAC MODULE: Node %s At time %f sec schedule intrp code %d (Wpan_CAP_Period_End)\n", lr_wpan_node_name,sf_param.superframe_start_time + sf_param.CAP_period_length_seconds, Wpan_CAP_Period_End);
		printf("MAC MODULE: Node %s At time %f sec schedule intrp code %d (Wpan_Backoff_Period_Elapsed)\n", lr_wpan_node_name,sf_param.superframe_start_time + backoff_periods_per_beacon*LR_WPAN_BACKOFF_PERIOD_DURATION, Wpan_Backoff_Period_Elapsed);

		}
	  }	
	*/

	  op_prg_mem_free (superframe_spec_field );
	  op_prg_mem_free (frame_ctrl_field );

	  FOUT;
	}


/*
 * Function:	unacknowlegement_reset
 */

static void
unacknowlegement_reset (void)
{
/* 
 * if we are in unacknowledgement mode, we turn the LIFS on 
 * and we destroy the retransmission packet 
 */
	FIN (unacknowlegement_reset ());
	
	/* The transmission of the data is finished */
	channel_flag.data_is_sending = OPC_FALSE;
	
	/* turn on the LIFS period */
	channel_flag.LIFS_on = OPC_TRUE;
	
	/* schedule when the LIFS will be over */
	op_intrpt_schedule_self (op_sim_time () + WPAN_LIFS_DURATION, Wpan_LIFS_Over);
	
	/* destroy the retransmission packet */
	lr_wpan_destroy_retransmission ();
	
	/* update the sequence number */
	Mac_Data_Tx_Seqn++;
	Mac_Data_Tx_Seqn %= MAX_MAC_SEQN;
	
		
	FOUT;
}

	
/*
 * Function:	lr_wpan_packet_to_transmit
 *
 * Description:	set and transmit the MAC packet to the channel
 *
 * No parameter
 */

static void lr_wpan_packet_to_transmit (void)
{
	Packet * pkptr;
	int      pktsize=0;
	double   time_intrpt = 0.0;
	
	FIN (lr_wpan_packet_to_transmit ());
	
	if(DEBUG_Data_Tx) fprintf(fp_debug, "MAC Module: Node %s lr_wpan_packet_to_transmit function at time %12f\n", lr_wpan_node_name, op_sim_time());

	if (lr_wpan_beacon_param.data_request != OPC_NIL)
		{
		/* set the packet to send  */
		pkptr = lr_wpan_beacon_param.data_request; 
		
		pktsize= (int) op_pk_total_size_get (pkptr);
		
		/* reset the pointer without destroying the packet to send */
		lr_wpan_beacon_param.data_request = OPC_NIL;
		}
	else if (retransmission_ptr == OPC_NIL)
		{
		/* debugging */
		ENTER_STATE_ODB_PRINTING ("transmit a packet");
		
		/* check if the subqueue is not empty */
		if (!current_queue->size)
			lr_wpan_mac_error ("lr_wpan_packet_to_transmit:", "The higher layer subqueue is empty.", OPC_NIL);
		
		/* dequeue the higher layer packet to transmit */
		if ((pkptr = op_prg_list_remove (current_queue->subqueue, OPC_LISTPOS_HEAD)) == OPC_NIL)
			lr_wpan_mac_error ("lr_wpan_packet_to_transmit:", "Unable to get the packet from the subqueue.", OPC_NIL);
		
		
		pktsize= (int) op_pk_total_size_get (pkptr);
		
		
		/* update the size of the list */
		current_queue->size = op_prg_list_size (current_queue->subqueue);
		
		/* Set the sequence number of the packet */
		op_pk_nfd_set_int32 (pkptr, "Seqn", Mac_Data_Tx_Seqn);
		
		last_transmitted_pkt_size = (int) op_pk_total_size_get (pkptr);	
		last_tx_pkt_time_generation = op_pk_stamp_time_get (pkptr);
		
		
		/* get a copy of the packet in case of retransmission */
		retransmission_ptr = op_pk_copy (pkptr);
		}
	else
		{
		/* debugging */
		ENTER_STATE_ODB_PRINTING ("retransmit a packet");

		/* compute the retransmission packet */
		(statistic.Retransmission)++;
		(global_statistics.Retransmission)++;
		
		/* set a break point for the retransmission */
		op_prg_odb_bkpt ("retransmission");
		
		/* get the packet to retransmit */
		pkptr = op_pk_copy (retransmission_ptr);
		
		pktsize=(int) op_pk_total_size_get (pkptr);
		}
	
	
	if(DEBUG_Data_Tx) fprintf(fp_debug, "MAC MODULE: Node %s delivers to the channel the packet at time %12f sec\n", lr_wpan_node_name, op_sim_time());
	
	/* send the packet to the channel */
	op_pk_deliver (pkptr, wpan_channel_objid, CHANNEL_UP_STREAM);


	
	/* update the statistics */
	statistic.Data_Pkt_Sent ++;
	node_statistics.Data_Bits_Sent = node_statistics.Data_Bits_Sent + op_pk_total_size_get (pkptr) - WPAN_HEADER_SIZE;
	
	op_stat_write(nb_pkt_send, statistic.Data_Pkt_Sent);
	
	global_statistics.Data_Pkt_Sent ++;
	
	time_intrpt=(pktsize + (double) LR_WPAN_PHY_OVERHEAD)/LR_WPAN_BIT_RATE; 
	
	/* schedule the end of the transmission */
	op_intrpt_schedule_self (op_sim_time () + time_intrpt, End_Of_Transmission);
	
	/* set the TX and RX to busy */
	channel_flag.tx_idle = OPC_FALSE;
	channel_flag.rx_idle = OPC_FALSE;

	
	/* if a turn around time is schedule, we cancel it */
	lr_wpan_cancel_TAT (TXRX_CODE);
	
	/* we expected to received an acknowledgment */
	Rx_Ack_Expected = Acknowledgement_Enable;
	
	/* We are sending a data packet */
	channel_flag.data_is_sending = OPC_TRUE;
	
	if(psma_enabled)
		{
		psma_time_to_tx = OPC_FALSE;
		channel_is_idle = OPC_FALSE;
		}
	
	// update statistic list for retransmissions
	if (nb_transmission_retries != 0)
		{
		update_retransmissions_list();
		}
	
	FOUT;
}

 

static void update_retransmissions_list()
{
	retx* elem_ptr;
	//retx* elem_ptr_global;

	FIN (update_retransmissions_list())
	
	elem_ptr = (retx*) op_prg_mem_alloc( sizeof(retx) );
	//elem_ptr_global = (retx*) op_prg_mem_alloc( sizeof(retx) );
	
	elem_ptr->time = op_sim_time();
	elem_ptr->retransmissions = statistic.Retransmission;
		
	op_prg_list_insert(statistic_retx_list_ptr, elem_ptr, OPC_LISTPOS_TAIL);
	
	//elem_ptr_global->time = op_sim_time();
	//elem_ptr_global->retransmissions = global_statistics.Retransmission;
	
	//op_prg_list_insert(list_retx_ptr_global, elem_ptr_global, OPC_LISTPOS_TAIL);
	
	FOUT;
}



/*
 * Function:	lr_wpan_ack_to_transmit
 *
 * Description:	Transmit an Ack packet
 *
 * No Parameters
 */

static void lr_wpan_ack_to_transmit ()
{
	Packet * Ack_Pkptr;
	Ici * ici_ptr;
	double txrx_distance;
	int rx_index, rx_seqn;
	Wpan_Node_Param * rxptr;
	double deltax= 0.0;
	double deltay= 0.0;
	double deltaxSquare= 0.0;
	double deltaySquare= 0.0;
	
	
	FIN (lr_wpan_ack_to_transmit ());
	
	if(DEBUG_Tx_Ack) 
			fprintf(fp_debug, "MAC MODULE: Node %s transmitting an Ack to node %d at time %12f\n", lr_wpan_node_name, Ack_Dest_Addr, op_sim_time());
	
	/* create an Ack packet */
	Ack_Pkptr = op_pk_create_fmt ("lr_wpan_ack");
	
	/* get the sequence number */
	if ((rx_seqn = lr_wpan_get_rx_seqn (Ack_Dest_Addr)) == -1)
		lr_wpan_mac_error ("lr_wpan_ack_to_transmit:", "Unable to get the sequence number.", OPC_NIL);
	
	/* fill out the field of the packet */
	if (op_pk_nfd_set_int32 (Ack_Pkptr, "Seqn", rx_seqn) == OPC_COMPCODE_FAILURE)
		lr_wpan_mac_error ("lr_wpan_ack_to_transmit:", "Unable to fill out the packet's fields.", OPC_NIL);
		
	if ((rx_index = wpan_search_mac_address (Ack_Dest_Addr)) == -1)
		lr_wpan_mac_error ("lr_wpan_ack_to_transmit:", "The MAC destination address doesn't exist.", OPC_NIL);
	
	/* get the parameter of the destination device */
	rxptr = (Wpan_Node_Param *) op_prg_list_access (wpan_node_param_list, rx_index);
	
	/* compute the distance between the RX and TX */
	//if(DEBUG_Tx_Ack) printf("MAC MODULE: Node %s transmitting an Ack. Destination node coordinates: x = %f y = %f \n", lr_wpan_node_name, rxptr->x, rxptr->y);
	//if(DEBUG_Tx_Ack) printf("MAC MODULE: Node %s transmitting an Ack. My coordinates: x = %f y = %f \n", lr_wpan_node_name, my_parameters->x, my_parameters->y);
	
	deltax=rxptr->x - my_parameters->x;
	deltay=rxptr->y - my_parameters->y;
	
	deltaxSquare= deltax*deltax; //if(DEBUG_Tx_Ack) printf("DeltaxSquare %f \n", deltaxSquare);
    deltaySquare= deltay*deltay; //if(DEBUG_Tx_Ack) printf("DeltaySquare %f \n", deltaySquare);
	
	txrx_distance = sqrt(deltaxSquare + deltaySquare);
	
	/*
	printf("X diff %f\n", rxptr->x - my_parameters->x);
	printf("X power %f\n", pow(rxptr->x - my_parameters->x,2));
	printf("X:  %f\n", (rxptr->x - my_parameters->x)*(rxptr->x - my_parameters->x));
	printf("Y: %f\n", (rxptr->y - my_parameters->y)*(rxptr->y - my_parameters->y));
	txrx_distance = sqrt((rxptr->x - my_parameters->x)*(rxptr->x - my_parameters->x) + (rxptr->y - my_parameters->y)*(rxptr->y - my_parameters->y));
    */
	//if(DEBUG_Tx_Ack) printf("MAC MODULE: Node %s transmitting an Ack with Tx-Rx distance = %f m\n", lr_wpan_node_name, txrx_distance);
	
	/* create a new ICI */
	ici_ptr = op_ici_create ("ici_channel");
	
	/* set the ICI pointer */
	if (op_ici_attr_set_dbl (ici_ptr, "txrx distance", txrx_distance) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "bit rate", LR_WPAN_BIT_RATE) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "channel", wpan_frequency_center) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "power", my_parameters->power) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_int32 (ici_ptr, "packet type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_int32 (ici_ptr, "dest address", Ack_Dest_Addr) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Tx x", my_parameters->x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Tx y", my_parameters->y) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Rx x", rxptr->x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_set_dbl (ici_ptr, "Rx y", rxptr->y) == OPC_COMPCODE_FAILURE)
		lr_wpan_mac_error ("higher_layer_pkt_recv:", "Unable to set the ICI pointer.", OPC_NIL);
	
	/* Associate the ICI pointer with this packet */
	op_pk_ici_set (Ack_Pkptr, ici_ptr);
	
	
	/* send the packet to the channel */
	op_pk_deliver (Ack_Pkptr, wpan_channel_objid, CHANNEL_UP_STREAM);
	
	/* update the statistics */
	statistic.Ack_Pkt_Sent ++;	
	
	/* schedule the end of the transmission */
	op_intrpt_schedule_self (op_sim_time () + op_pk_total_size_get (Ack_Pkptr)/LR_WPAN_BIT_RATE, End_Of_Transmission);
	
	/* set the transmitter busy */
	channel_flag.tx_idle = OPC_FALSE;
	channel_flag.rx_idle = OPC_FALSE;

	
	/* if a turn around time is schedule, we cancel it */
	lr_wpan_cancel_TAT (TXRX_CODE);
	
	FOUT;
}


/*
 * Function:	lr_wpan_drop_higher_layer_pkt
 *
 * Description: 
 *
 * No parameters
 */

static void	lr_wpan_drop_higher_layer_pkt (void)
{
	Packet * pkptr;
	Packet * higher_layer_pkptr;
	int last_packet = 0;
	Ici * ici_ptr;
	char error_msg[256];
	
	
	FIN (lr_wpan_drop_higher_layer_pkt ());
	
	while (!last_packet)
		{
		/* dequeue the packets from the current queue */
		if ((pkptr = op_prg_list_remove (current_queue->subqueue, OPC_LISTPOS_HEAD)) == OPC_NIL)
			{
			sprintf (error_msg, "Queue size: %d; list size: %d\n", current_queue->size, op_prg_list_size (current_queue->subqueue));
			lr_wpan_mac_error ("lr_wpan_drop_higher_layer_pkt:", "Unable to get the packet from the subqueue.", error_msg);
			}
	
		/* get the ICI associate with the packet */
		if ((ici_ptr = op_pk_ici_get (pkptr)) == OPC_NIL)
			lr_wpan_mac_error ("lr_wpan_drop_higher_layer_pkt", "No ICI associates with the current packet", OPC_NIL);
		
		/* destroy the ICI */
		op_ici_destroy (ici_ptr);
				
		/* get the higher layer packet if the segmentation flag is true */
		op_pk_nfd_get_int32 (pkptr, "Segmentation", &last_packet);
		
		if (last_packet)
			{
			/*
			* if this is the last segment of the higher
			* layer packet, we get it and destroy it
			*/
			op_pk_nfd_get_pkt (pkptr, "Higher Layer Pkt", &higher_layer_pkptr);
			
			// update statistic of delay for dropped packets
			global_statistics.Total_Delay_Dropped_packets += op_sim_time () - op_pk_stamp_time_get (higher_layer_pkptr);
			
			/* destroy the higher layer packet */
			op_pk_destroy (higher_layer_pkptr);
			}
		
		/* destroy the packet */
		op_pk_destroy (pkptr);
		
		/* update the statistic */
		statistic.Segment_Dropped ++;
		}
	
	/* update the size of the queue */
	current_queue->size = op_prg_list_size (current_queue->subqueue);
		
	FOUT;
}


/*
 * Function:	lr_wpan_destroy_retransmission
 *
 * Description:	
 *
 * ParamOut:	int last_packet
 *				return the value 1 if the retransmission packet
 *				was the last segment of the higher layer packet,
 *				otherwise, we return 0
 */

static int	lr_wpan_destroy_retransmission (void)
{
	Packet * higher_layer_pkptr;	
	Ici * ici_ptr;
	int last_packet;
	
	FIN (lr_wpan_destroy_retransmission ());
	
	/* get the ICI associates with the retransmission packet */
	if ((ici_ptr = op_pk_ici_get (retransmission_ptr)) == OPC_NIL)
		lr_wpan_mac_error ("lr_wpan_destroy_retransmission:", "Unable to get the ICI pointer.", OPC_NIL);
		
	/* destroy the ICI structure */
	op_ici_destroy (ici_ptr);
	
	/* get the segmentation flag */
	op_pk_nfd_get_int32 (retransmission_ptr, "Segmentation", &last_packet);
	
	if (last_packet)
		{
		/*
		* if this is the last segment of the higher
		* layer packet, we get it and destroy it
		*/
		op_pk_nfd_get_pkt (retransmission_ptr, "Higher Layer Pkt", &higher_layer_pkptr);
		
		
		// update statistic of delay in case we are dropping a packet
		if(nb_transmission_retries > max_frame_retries||csma_parameters.nb_backoff > csma_parameters.max_backoff)
			global_statistics.Total_Delay_Dropped_packets += op_sim_time () - op_pk_stamp_time_get (higher_layer_pkptr);
		
		
		/* destroy the higher layer packet */
		op_pk_destroy (higher_layer_pkptr);
		}
	
	/* destroy the retransmission packet */
	op_pk_destroy(retransmission_ptr);
	retransmission_ptr = OPC_NIL;
	
	/* reset the transmission retries counter */
	nb_transmission_retries = 0;
	
	FRET (last_packet);
}


/*
 * Function:	lr_wpan_enqueue_packet
 *
 * Description:	subqueue mechanism:
 *				each packet is enqueue according to its destination
 *				MAC address. A structure has been made to record
 *				these information: "Wpan_queue"
 *				this function enqueue a packet according to its
 *				destination MAC address. If no subqueue exists for
 *				the current MAC address, we create a new one.
 *
 * ParamIn:		int mac_address
 *				Destination MAC address of the packet
 *
 *				Packet * pkptr
 *				pointer to the packet to enqueue
 *				
 */

static void lr_wpan_enqueue_packet (int mac_address, Packet * pkptr)
{
	Wpan_Queue * queue; // = wpan_queue;
	
	FIN (lr_wpan_enqueue_packet (mac_address, pkptr));
	
	queue = wpan_queue;
	
	/* update the statistic */
	statistic.Segment_generated ++;
	node_statistics.Segments_Bits_Generated = node_statistics.Segments_Bits_Generated + op_pk_total_size_get (pkptr)  - WPAN_HEADER_SIZE;

	global_statistics.Segment_generated ++ ; 
	
	/* consider all the possibilities */
	if (wpan_queue == NULL)
		{
		/* if the structure is not yet created */
		wpan_queue = lr_wpan_allocate_subqueue (mac_address, pkptr);
		
		/* we make a loop */
		wpan_queue->next = wpan_queue;
		
		
		/* initialize the round robin if any */
		current_queue = wpan_queue;

		FOUT;
		}
	
	while (queue != NULL)
		{
		/* */
		if (queue->mac_address == mac_address)
			{
			op_prg_list_insert (queue->subqueue, pkptr, OPC_LISTPOS_TAIL);
			queue->size = op_prg_list_size (queue->subqueue);
			FOUT;
			}
		
		if (queue->next == wpan_queue)
			{
			/* we are at the end of the chain */
			queue->next = lr_wpan_allocate_subqueue (mac_address, pkptr);
			
			/* increase the number of elements */
			wpan_queue->nb_element ++;
			FOUT;
			}
		
		queue = queue->next;
		}
	
	/* we shouldn't be here, so we print out an error message */
	lr_wpan_mac_error ("lr_wpan_enqueue_packet:", "Unable to enqueue the packet", OPC_NIL);
}


/*
 * Function:	lr_wpan_allocate_subqueue
 *
 * Description:	allocate a new subqueue for a new destination
 *				MAC address
 *
 * ParamIn:		int mac_address
 *				Destination MAC address of the packets in the subqueue
 *
 *				Packet * pkptr
 *				pointer to the packet to enqueue
 *
 * ParamOut:	Wpan_queue * queue
 *				New queue structure with the first pascket enqueue
 */

static Wpan_Queue * lr_wpan_allocate_subqueue (int mac_address, Packet * pkptr)
{
	Wpan_Queue * queue;
	
	FIN (lr_wpan_allocate_subqueue ());
	
	/* allocate the memory for the cell */
	queue = (Wpan_Queue *) op_prg_mem_alloc (sizeof (Wpan_Queue));
	
	/* create a the list attribute */
	queue->subqueue = op_prg_list_create ();
	
	/* enqueue the packet */
	op_prg_list_insert (queue->subqueue, pkptr, OPC_LISTPOS_TAIL);
	
	/* initialize the other fields */
	queue->mac_address = mac_address;
	queue->size = 1;
	queue->nb_element = 1;
	queue->next = wpan_queue;
	
	FRET (queue);
}


/*
 * Function:	lr_wpan_print_queue
 *
 * Description:	print the whole queue of the node
 *
 * No parameter
 */

static void
lr_wpan_print_queue (void)
{
	Wpan_Queue * queue; // = wpan_queue;
	int i;
	
	FIN (lr_wpan_print_queue ());
	
	queue = wpan_queue;
	
	/* */
	printf ("\n|-----------------------------------------------------\n");
	printf ("| Node %s:\n", lr_wpan_node_name);
	if (queue != NULL)
		{
		for (i=0; i<wpan_queue->nb_element; i++)
			{
			printf ("|\tMac address: %d\n", queue->mac_address);
			printf ("|\tsize: %d\n|\n", queue->size);
			queue = queue->next;
			}
		}
	else
		printf ("|\tNo subqueues\n");

	printf ("|-----------------------------------------------------\n");

	FOUT;
}


/*
 * Function:	lr_wpan_get_beacon_size
 *
 * Description:	compute the size of a Beacon packet
 *
 * ParamOut:	int beacon_size
 *				size of the beacon packet
 */

static int
lr_wpan_get_beacon_size (Addressing_Field * address)
{
	Wpan_Queue * queue; // = wpan_queue;
	int i;
	int beacon_size, nbPacket = 0;
	
	const int address_size = 16; // size of the address field in bits
	const int maximum_nbpacket = 7; // maximum number of packet
	
	FIN (lr_wpan_get_beacon_size ());
	
	queue = wpan_queue;
	
	/* count the number of packets */
	if (queue != NULL)
		{
		for (i=0; i<wpan_queue->nb_element; i++)
			{
			/* increase the number of total packet */
			nbPacket += queue->size;
			
			/* if we have a packet for the particular source address */
			if (address->src_addr == queue->mac_address)
				address->packet_pending = queue->size;
			
			/* get the next queue */
			queue = queue->next;
			}
		}
	
	/* compute the Beacon packet size */
	if (nbPacket < maximum_nbpacket)
		beacon_size = 104 + nbPacket * address_size;
	else
		beacon_size = 104 + maximum_nbpacket * address_size;

	
	FRET (beacon_size);
}


/*
 * Function:	lr_wpan_subq_checking
 */

static void lr_wpan_subq_checking ()
{
	int i = 0;
	Wpan_Queue * queue;// = current_queue;
	Boolean subq_empty;
	
	FIN (lr_wpan_subq_checking ());
	
	queue = current_queue;
	
	/*
 	 * if no transmission is already scheduled, we check
	 * the subqueues for the next transmission
	 */
	/* initialize the flag subqueue empty */
	if (queue != NULL)
		{
		queue = queue->next;
		subq_empty = (queue->size == 0);
		}
	else
		{
		FOUT;
		}
	
	/* check the subqueues */
	while (subq_empty && queue->next != current_queue)
		{
		/* get the next subqueue index */
		queue = queue->next;
		
		/* check if the subqueue is empty */
		subq_empty = (queue->size == 0);
		}
	
	if (!subq_empty)
		{
		/* schedule an interuption for the next transmission */
		op_intrpt_schedule_self (op_sim_time (), Data_Pkt_To_Send);
		
		/* get the subqueue */
		current_queue = queue;
		}
	
	FOUT;
}


/*
 * Function:	lr_wpan_get_rx_seqn
 */

static int lr_wpan_get_rx_seqn (int mac_address)
{
	Mac_Data_Seqn * element;
	int list_size; // = op_prg_list_size (Mac_Data_Rx_Seqn);
	int i; // loop variable
	
	
	FIN (lr_wpan_get_rx_seqn (mac_address));
	
	list_size = op_prg_list_size (Mac_Data_Rx_Seqn);
	
	for (i=0; i<list_size; i++)
		{
		/* get the ith element */
		element = op_prg_list_access (Mac_Data_Rx_Seqn, i);
		
		if (element->mac_address == mac_address)
			FRET (element->seqn);
		}
	
	/* if the MAC address is not present, we initialize it */
	lr_wpan_set_rx_seqn (mac_address, -1);
	
	FRET (-1);
}


/*
 * Function:	lr_wpan_set_rx_seqn
 */

static void lr_wpan_set_rx_seqn (int mac_address, int seqn)
{
	Mac_Data_Seqn * element;
	int list_size; // = op_prg_list_size (Mac_Data_Rx_Seqn);
	int i; // loop variable
	
	FIN (lr_wpan_set_rx_seqn (mac_address, seqn));
	
	list_size = op_prg_list_size (Mac_Data_Rx_Seqn);
	
	/* search for an existing element */
	for (i=0; i<list_size; i++)
		{
		/* get the ith element */
		element = op_prg_list_access (Mac_Data_Rx_Seqn, i);
		
		if (element->mac_address == mac_address)
			{
			element->seqn = seqn;
			FOUT;
			}
		}
	
	/* if we are here, no sequence number exist yet */
	/* we create a new one */
	element = (Mac_Data_Seqn *) op_prg_mem_alloc (sizeof (Mac_Data_Seqn));
	
	element->mac_address = mac_address;
	element->seqn = seqn;
	
	/* insert this element into the list */
	op_prg_list_insert (Mac_Data_Rx_Seqn, element, OPC_LISTPOS_TAIL);
	
	FOUT;
}


/*
 * Function:	s_aloha_set_flags
 */

static void 		s_aloha_set_flags()
{
	FIN (s_aloha_set_flags());
	
	channel_flag.rx_idle = OPC_FALSE;
	channel_flag.tx_idle = OPC_TRUE;
	
	if(my_parameters->slotted_enable == OPC_TRUE)
	{
	csma_operation_param.evaluate_after_backoff	= OPC_FALSE;
	csma_operation_param.can_proceed = OPC_FALSE;	
	csma_operation_param.pending_backoff_periods = 0;
	csma_operation_param.CCA_evaluation_pending	= OPC_FALSE;
	csma_operation_param.backoff_countdown_is_paused = OPC_FALSE;
	}
	
	FOUT;
}


/*
 * Function:	lr_wpan_collect_stat
 *
 * Description:	collect data at the end of the simulation
 *				4 files are created during this function:
 *	
 *				* {basename}_pkt_rcv.txt: record the number
 *				  of packets received and packets loss
 *
 *				* {basename}_pkt_sent.txt: record the number
 *				  of packets sent during the simulation
 *
 *				* {basename}_node_status.txt: record the number
 *				  of packets present in the subqueues
 *
 *				* {basename}_pkt_delay.txt: record the MAC delay
 *               ----------------------------------------------------
 *				* {basename}_beacon_frame_sent.txt: record the number
 *				  of beacon frame sent
 *
 *				* {basename}_beacon_frame_rcv.txt: record the number
 *				  of beacon frame received	
 * No parameter
 */

static void lr_wpan_collect_stat ()
{
	FILE * fp;
	char report_name[128];
	Boolean exist;
	//double packet_loss;
	double mac_delay,throughput1,throughput2;
	
	const char * packet_rcv        = "_pkt_rcv.txt";
	const char * packet_sent       = "_pkt_sent.txt";
	const char * node_status       = "_node_status.txt";
	const char * packet_delay      = "_pkt_delay.txt";
	
	const char * beacon_frame_sent = "_beacon_frame_sent.txt";
	const char * beacon_frame_rcv  = "_beacon_frame_rcv.txt";	
	
	Wpan_Queue * queue;
	int i; // loop variable
	time_t date;
	char date_str[32];
	
	
	FIN (lr_wpan_collect_stat ());
	
	/* get the date of the day */
	time (&date);
	sprintf (date_str, "%s", ctime (&date));
	
	// print BACKOFF printf("%f\n",statistic.total_backoff_time);
	//printf(" (%s) total backoff %d\n", lr_wpan_node_name, statistic.total_backoff);
	
	/* start printing report */
	/* get the report name */
	
	
	sprintf (report_name, "%s%s", lr_wpan_node_name, packet_rcv);
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	if (!exist)
		{
		/* write a header in the file */
		fprintf (fp, "\n\t*** Packet received at the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tTotal pkt received :\tnumber of  total pkt received \n");
		fprintf (fp, "\tTotal seg generated :\tnumber of  total seg generated \n");
		fprintf (fp, "\tThruput1:\t\tnumber of received packets over segments generated\n");
        fprintf (fp, "\tThruput2:\t\tnumber of received packets over sent packets\n");
		fprintf (fp, "\tData pkt rcv:\t\tnumber of MAC data packets received\n");
		fprintf (fp, "\tAck pkt rcv:\t\tnumber of acknowledgment packets received\n");
		//fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmission packet sent\n");
		fprintf (fp, "\tMac delay:\t\tmac delay per paket received\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Tot rcvd\t Tot generated\t Thruput1\t Thruput2\t Data pkt rcv\t Ack pkt rcv\t Mac delay\t Simulation time\t Last modified date\n");
		}
	
	/* compute the packet loss */
	//if (statistic.Data_Pkt_Rcv + statistic.Pkt_Lost + statistic.Pkt_Collided + statistic.Pkt_Noise  == 0)
	//	packet_loss = -1.0;
	//else
	//	packet_loss = (double)( statistic.Pkt_Lost + statistic.Pkt_Collided + statistic.Pkt_Noise) / ((double) statistic.Data_Pkt_Rcv + (double) statistic.Pkt_Lost + (double) statistic.Pkt_Collided + (double)statistic.Pkt_Noise);
	
	/*FRANCESCO  Compute the MAC everage delay */
		mac_delay = (double) statistic.Total_MAC_Delay;
			// (double) statistic.Data_Pkt_Rcv;
	
		/* FRANCESCO Compute throughput */
		throughput1 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Data_Pkt_Sent + (double)global_statistics.Pkt_Dropped);
		throughput2 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Data_Pkt_Sent);
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s",integer_to_string ((int)global_statistics.Data_Pkt_Rcv, 10),
		double_to_string ((double) global_statistics.Data_Pkt_Sent + (double)global_statistics.Pkt_Dropped, 10),
		double_to_string (throughput1, 10),
		double_to_string (throughput2, 10),
		integer_to_string (statistic.Data_Pkt_Rcv, 10),
		integer_to_string (statistic.Ack_Pkt_Rcv, 9),
		double_to_string (mac_delay, 7),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	/*original
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.Pkt_Collided, 9),
		integer_to_string (statistic.Pkt_Lost, 8),
		double_to_string (throughput1, 10),
		double_to_string (throughput2, 10),
		integer_to_string (statistic.Data_Pkt_Rcv, 10),
		integer_to_string (statistic.Ack_Pkt_Rcv, 9),
		integer_to_string (statistic.Nb_Time_Out, 7),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	original end*/
	
	fclose (fp);
	
	/* get the report name */
	sprintf (report_name, "%s%s", lr_wpan_node_name, packet_sent);
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	if (!exist)
		{
		/* write a header in the file */
		fprintf (fp, "\n\t*** Packet sent from the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tSgmt generated:\t\tdata segment generated in the MAC layer\n");
		fprintf (fp, "\tData pkt sent:\t\ttotal number of data packets sent\n");
		fprintf (fp, "\tAck pkt sent:\t\ttotal number of acknowledgement packets sent\n");
		fprintf (fp, "\tPkt dropped:\t\tnumber of higher layer packets dropped by the CCA\n");
		fprintf (fp, "\tSgmt dropped:\t\tnumber of segments dropped by the CCA\n");
		fprintf (fp, "\tPkt sent total \t\tnumber of packets sent in total \n");
		fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmission packet sent\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Sgmt generated\t Data pkt sent\t Ack pkt sent\t Pkt dropped\t Seg dropped\t Pkt sent total\t Retransmit pkt\t Simulation time\t last modified date\n");
		}
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.Segment_generated, strlen ("Sgmt generated")),
		integer_to_string (statistic.Data_Pkt_Sent, 10),  
		integer_to_string (statistic.Ack_Pkt_Sent, 10),    
		integer_to_string (statistic.Pkt_Dropped, 8),      
		integer_to_string (statistic.Segment_Dropped, 8),  
		double_to_string ((double) global_statistics.Data_Pkt_Sent, 8),
		integer_to_string (statistic.Retransmission, 8),   
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);

		
	/*ORIGINAL sprintf (report_name, "%s%s", lr_wpan_node_name, packet_rcv);
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	if (!exist)
		{
		/* write a header in the file 
		fprintf (fp, "\n\t*** Packet received at the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tNb pkt collided:\tnumber of packet collided, protocol issue\n");
		fprintf (fp, "\tNb pkt lost:\t\tnumber of packet lost by collisions\n");
		fprintf (fp, "\tNb pkt noise:\t\tnumber of packet lost by noise\n");
		fprintf (fp, "\tData pkt rcv:\t\tnumber of MAC data packets received\n");
		fprintf (fp, "\tAck pkt rcv:\t\tnumber of acknowledgment packets received\n");
		fprintf (fp, "\tPkt loss:\t\tratio between the number of data packet received and the total number of packet sent (except the Ack)\n");
		fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmission packet sent\n");
		fprintf (fp, "\tNb Time Out:\t\tnumber of time out reached in the Acknowledgement state\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Nb pkt collided\t Nb pkt lost\t Nb pkt Noise\t Data pkt rcv\t Ack pkt rcv\t Pkt loss\t Nb Time Out\t simulation time\t last modified date\n");
		}
	
	/* compute the packet loss 
	if (statistic.Data_Pkt_Rcv + statistic.Pkt_Lost + statistic.Pkt_Collided + statistic.Pkt_Noise  == 0)
		packet_loss = -1.0;
	else
		packet_loss = (double)( statistic.Pkt_Lost + statistic.Pkt_Collided + statistic.Pkt_Noise) / ((double) statistic.Data_Pkt_Rcv + (double) statistic.Pkt_Lost + (double) statistic.Pkt_Collided + (double)statistic.Pkt_Noise);
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.Pkt_Collided, 9),
		integer_to_string (statistic.Pkt_Lost, 8),
		integer_to_string (statistic.Pkt_Noise, 9),
		integer_to_string (statistic.Data_Pkt_Rcv, 10),
		integer_to_string (statistic.Ack_Pkt_Rcv, 9),
		double_to_string (packet_loss, 7),
		integer_to_string (statistic.Nb_Time_Out, 7),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
	
	
	/* get the report name 
	sprintf (report_name, "%s%s", lr_wpan_node_name, packet_sent);
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	if (!exist)
		{
		/* write a header in the file 
		fprintf (fp, "\n\t*** Packet sent from the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tSgmt generated:\t\tdata segment generated in the MAC layer\n");
		fprintf (fp, "\tData pkt sent:\t\ttotal number of data packets sent\n");
		fprintf (fp, "\tAck pkt sent:\t\ttotal number of acknowledgement packets sent\n");
		fprintf (fp, "\tPkt dropped:\t\tnumber of higher layer packets dropped by the CCA\n");
		fprintf (fp, "\tSgmt dropped:\t\tnumber of segments dropped by the CCA\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Sgmt generated\t Data pkt sent\t Ack pkt sent\t Pkt dropped\t Sgmt dropped\t Retransmit pkt\t Simulation time\t last modified date\n");
		}
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.Segment_generated, strlen ("Sgmt generated")),
		integer_to_string (statistic.Data_Pkt_Sent, 10),  
		integer_to_string (statistic.Ack_Pkt_Sent, 10),    
		integer_to_string (statistic.Pkt_Dropped, 8),      
		integer_to_string (statistic.Segment_Dropped, 8),  
		integer_to_string (statistic.Retransmission, 8),   
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
     ORIGINAL END*/
	
	
	/* get the total report name */
	if (wpan_queue != NULL)
		{
		/* get the report name */
		sprintf (report_name, "%s%s", lr_wpan_node_name, node_status);
		
		fp = lr_wpan_open_report_file (report_name, &exist);
		
		/* Print the header of the file */
		if (!exist)
			{
			/* write a header in the file */
			fprintf (fp, "\t*** Status of the node queues for %s ***\n", lr_wpan_node_name);
			fprintf (fp, "\tCreation date: %s\n", date_str);
			fprintf (fp, "\tSubq n length:\tsize of the subqueue n\n");
			fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
			
			for (i=0; i < wpan_queue->nb_element; i++)
				fprintf (fp, "Subq %d length, ", i);
			
			/* print the return char */
			fprintf (fp, "simulation time, last modified date\n");
			}
		
		/* print the results */
		for (i=0, queue = wpan_queue; i < wpan_queue->nb_element; i++)
			{
			fprintf (fp, "%s, ", integer_to_string (queue->size, 13));
			queue = queue->next;
			}
		
		/* print the return char */
		fprintf (fp, "%s, %s", double_to_string (op_sim_time (), strlen ("simulation time")), date_str);
		
		fclose (fp);
		}
	
	
	/* get the report name */
	sprintf (report_name, "%s%s", lr_wpan_node_name, packet_delay);
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* Print the header of the file */
	if (!exist)
		{
		/* write a header in the file */
		fprintf (fp, "\t*** Packet delay at the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tTotal MAC delay:\t\tsum of all the delay collected at the MAC level\n");
		fprintf (fp, "\tnb data pkt:\t\ttotal number of data packets received\n");
		fprintf (fp, "\tMAC delay (everage):\teverage of the MAC delay for one packet\n");
		fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Total MAC dela\t nb data pkt\t MAC delay (everage)\t simulation time\t last modified date\n");
		}
	
	/* compute the MAC everage delay */
	mac_delay = (statistic.Data_Pkt_Rcv) ? statistic.Total_MAC_Delay / (double) statistic.Data_Pkt_Rcv : -1.0;
	
	/* print the results */
	fprintf (fp, "%s\t %s\t %s\t %s\t %s", double_to_string (statistic.Total_MAC_Delay, 11), 
		integer_to_string (statistic.Data_Pkt_Rcv, 11),
		double_to_string (mac_delay, 15),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
	if (!bulk_data_source)
		{
		/* 
		 * we don't have the simple source but the TCP/IP stack, so we must
		 * generate a report for the upper layer
		 */
		/* get the report name */
		sprintf (report_name, "%s_higher_layer.txt", lr_wpan_node_name);
	
		fp = lr_wpan_open_report_file (report_name, &exist);
	
		/* Print the header of the file */
		if (!exist)
			{
			/* write a header in the file */
			fprintf (fp, "\t*** Packet delay at the node %s ***\n", lr_wpan_node_name);
			fprintf (fp, "\tCreation date: %s\n", date_str);
			fprintf (fp, "\tnb pkt rcvd:\t\ttotal number of higher layer packets received\n");
			fprintf (fp, "\tnb bits rcvd:\t\ttotal number of higher layer bits received\n");
			fprintf (fp, "\tnb pkt sent:\t\ttotal number of higher layer packets sent\n");
			fprintf (fp, "\tnb bits sent:\t\ttotal number of higher layer bits sent\n");			
			fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
			fprintf (fp, "nb packets rcvd\t nb bits rcvd\t nb packets sent\t nb bits sent\t simulation time\t last modified date\n");
			}
				
		/* print the results */
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.tcp_HL_pkt_rcvd, strlen ("nb pkt rcvd")),
			integer_to_string (statistic.tcp_HL_bit_rcvd, strlen ("nb bits rcvd")),
			integer_to_string (statistic.tcp_HL_pkt_sent, strlen ("nb pkt sent")),
			integer_to_string (statistic.tcp_HL_bit_sent, strlen ("nb bits sent")),
			double_to_string (op_sim_time (), strlen ("simulation time")),
			date_str);
		
		fclose (fp);
		}
	
	/***************************************************************************************************/	
	/* Report the number of beacons sent */
	/* get the report name */
	sprintf (report_name, "%s%s", lr_wpan_node_name, beacon_frame_sent);
	fp = lr_wpan_open_report_file (report_name, &exist);
	if (!exist)
		{
		/* write a header in the file */
		fprintf (fp, "\t*** Beacon frame sent from the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\t Beacon frame sent:\t\ttotal number of beacon frame sent\n");
		fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Beacon frame sent\t Simulation time\t last modified date\n");
		}
	fprintf (fp, "%s\t %s\t %s", integer_to_string (statistic.Beacon_Frame_Sent, strlen ("Beacon frame sent")),
		double_to_string (op_sim_time (), strlen ("simulation time")), date_str);
	fclose (fp);

	
	/* Report the number of beacons received */
	/* get the report name */
	sprintf (report_name, "%s%s", lr_wpan_node_name, beacon_frame_rcv);
	fp = lr_wpan_open_report_file (report_name, &exist);
	if (!exist)
		{
		/* write a header in the file */
		fprintf (fp, "\t*** Beacon frame rerceived by the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\t Beacon frame received:\t\ttotal number of beacon frame received\n");
		fprintf (fp, "Beacon frame Collided\t total number of beacon frame collided\n");
		fprintf (fp, "\t Beacon frame Noise:\t\ttotal number of beacon frame noise\n");
		fprintf (fp, "\t Beacon frame Lost:\t\ttotal number of beacon frame lost\n");
		fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Beacon frame received\t Beacon Frame Collided\t Beacon Frame Noise\t Beacon Frame Lost\t Simulation time\t last modified date\n");			
		
		}
	fprintf (fp, "%s\t %s\t %s\t %s\t  %s\t %s ", 
		integer_to_string (statistic.Beacon_Frame_Rcv, strlen ("Beacon frame received")),
		integer_to_string (statistic.Beacon_Frame_Collided, strlen ("Beacon Frame Collided")),
		integer_to_string (statistic.Beacon_Frame_Noise, strlen ("Beacon Frame Noise")),
		integer_to_string (statistic.Beacon_Frame_Lost, strlen ("Beacon Frame Lostt")),
		double_to_string  (op_sim_time (), 
		strlen ("simulation time")), date_str);
	fclose (fp);

	FOUT;
}


static void lr_wpan_collect_performance_info1 ()
{
	FILE * fp;
	char report_name[128];
	Boolean exist;
	double global_packet_loss, mac_delay; // mac_delay_2;
	double throughput1; /*computed as the (Recvd data packets)/(Generated data packets) */ 
	double throughput2;	/*computed as the (Recvd data packets)/(sent data packets) */
	
	double data_rate_tput;	/*computed as the data rate (throughput) in terms of kbps */

	
	//Wpan_Queue * queue;
	//int i; // loop variable
	time_t date;
	char date_str[32];
	double alpha_global, beta_global ;
	
	FIN (lr_wpan_collect_performance_info1 ());
	
		
	/* get the date of the day */
	time (&date);
	sprintf (date_str, "%s", ctime (&date));
	
	
	/* Report the the global MAC statistics */
	
	
	if(!strcmp(lr_wpan_node_name,"coordinator"))
		{

		/* Report alpha, beta, and throughput */
		alpha_global = (double) (1.0 - (double) (Global_CCA_Statistics.First_CCA_Success_Count/ ((double) Global_CCA_Statistics.First_CCA_count)));
		beta_global =  (double) (1.0 - (double) (Global_CCA_Statistics.Second_CCA_Success_Count/ ((double)Global_CCA_Statistics.Second_CCA_count)));

		
		/* compute the global packet loss */
		if (global_statistics.Data_Pkt_Rcv + global_statistics.Pkt_Lost + global_statistics.Pkt_Collided + global_statistics.Pkt_Noise  == 0)
			global_packet_loss = -1.0;
		else
			global_packet_loss = (double)( global_statistics.Pkt_Lost + global_statistics.Pkt_Collided + global_statistics.Pkt_Noise) / ((double) global_statistics.Data_Pkt_Rcv + (double) global_statistics.Pkt_Lost + (double) global_statistics.Pkt_Collided + (double)global_statistics.Pkt_Noise);
	
		
		/* Compute the MAC everage delay */
		mac_delay = (statistic.Data_Pkt_Rcv) ? statistic.Total_MAC_Delay / (double) statistic.Data_Pkt_Rcv : -1.0;
	
		/* Compute throughput */
		throughput1 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Segment_generated);
		throughput2 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Data_Pkt_Sent);
		
		data_rate_tput = ((double) global_statistics.Total_Bits_Rcv) / (op_sim_time ()*1000.0);
		
	
		sprintf (report_name, "%s.txt", lr_wpan_scenario);
		fp = lr_wpan_open_report_file (report_name, &exist);
		
		if (!exist)
		{
			/* write a header in the file */
			fprintf (fp, "data_rate_tput\t throughput1\t throughput2t\t global_packet_loss\t alpha_global\t beta_global\t mac_delay\t Simulation time\t last modified date\n");
		}
	
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", 
			double_to_string (data_rate_tput, 14),
			double_to_string (throughput1, 11),
			double_to_string (throughput2, 11),			
			double_to_string (global_packet_loss,  18),					
			double_to_string (alpha_global, 12),
			double_to_string (beta_global,  11),
			double_to_string (mac_delay,   9),
			double_to_string (op_sim_time (), strlen ("simulation time")),
			date_str
			);
		
		fclose (fp);

	}

	FOUT;
}




static void lr_wpan_collect_performance_info2 ()
{
	FILE * fp;
	char report_name[128];
	Boolean exist;
	double packet_loss, mac_delay, global_packet_loss, global_mac_delay;
	double throughput1,global_throughput1 ; /*computed as the (Recvd data packets)/(Generated data packets) */ 
	double throughput2, global_throughput2;	/*computed as the (Recvd data packets)/(sent data packets) */
	double data_rate_tput, global_data_rate_tput;	/*computed as the data rate (throughput) in terms of kbps */

	//time_t date;
	//char date_str[32];
	
	FIN (lr_wpan_collect_performance_info2  ());
	
	/* Report the devices MAC statistics */
		
		/* Compute throughput */
		throughput1 = ((double) node_statistics.Data_Bits_Correctly_Sent) / ((double) (node_statistics.Data_Bits_Sent) );
		throughput2 = ((double) node_statistics.Data_Bits_Correctly_Sent) / ((double)  node_statistics.Segments_Bits_Generated);
		data_rate_tput = ((double) node_statistics.Data_Bits_Correctly_Sent) / (op_sim_time ());
		/* Compute the MAC everage delay */
		mac_delay = (statistic.Data_Pkt_Sent) ? node_statistics.Data_Delay / (double) (statistic.Data_Pkt_Sent - statistic.Retransmission): -1.0;

	/* compute the packet loss */
	if (statistic.Data_Pkt_Sent  == 0)
		packet_loss = -1.0;
	else
		packet_loss = (double)( statistic.Data_Pkt_Sent - statistic.Ack_Pkt_Rcv) / ((double)statistic.Data_Pkt_Sent);
		
	sprintf (report_name, "%s%s%s", lr_wpan_node_name, "_",lr_wpan_scenario);
		fp = lr_wpan_open_report_file (report_name, &exist);
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\n", 
			double_to_string (throughput1, 10),
			double_to_string (throughput2, 10),	
			double_to_string (data_rate_tput, 10),
			double_to_string (packet_loss,  7),					
			double_to_string (mac_delay,   10)			
			);
	fclose (fp);
	
	/* Report the global statistics (By the PNC)*/
	
	if(!strcmp(lr_wpan_node_name,"pnc"))
	{
		
		/* compute the global packet loss */
		if (global_statistics.Data_Pkt_Rcv + global_statistics.Pkt_Lost + global_statistics.Pkt_Collided + global_statistics.Pkt_Noise  == 0)
			global_packet_loss = -1.0;
		else
			global_packet_loss = (double)( global_statistics.Pkt_Lost + global_statistics.Pkt_Collided + global_statistics.Pkt_Noise) / ((double) global_statistics.Data_Pkt_Rcv + (double) global_statistics.Pkt_Lost + (double) global_statistics.Pkt_Collided + (double)global_statistics.Pkt_Noise);
		
		/* Compute the MAC everage delay */
		global_mac_delay = (statistic.Data_Pkt_Rcv) ? statistic.Total_MAC_Delay / (double) statistic.Data_Pkt_Rcv : -1.0;
	
		/* Compute throughput */
		global_throughput1 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Segment_generated);
		global_throughput2 = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Data_Pkt_Sent);
		global_data_rate_tput = (double) (global_statistics.Total_Bits_Rcv - statistic.Data_Pkt_Rcv*WPAN_HEADER_SIZE) / op_sim_time ();
			
		sprintf (report_name, "%s%s", "global_stat_",lr_wpan_scenario);
		fp = lr_wpan_open_report_file (report_name, &exist);
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\n", 
			double_to_string (global_throughput1, 10),
			double_to_string (global_throughput2, 10),			
			double_to_string (global_packet_loss,  7),		
			double_to_string (global_data_rate_tput, 10),
			double_to_string (global_mac_delay,   10)			
			);

		fclose (fp);
	}
	
	FOUT;
}

/*
 * Function:	lr_wpan_collect_stat_nodes (coded by Flavia Martelli)
 *
 * Description:	collect data at the end of the simulation for each node
 *
 *				6 files are created during this function:
 *	
 *				* {basename}_pkt_rcv.txt: record the number
 *				  of packets received and packets loss
 *
 *				* {basename}_pkt_sent.txt: record the number
 *				  of packets sent during the simulation
 *
 *				* {basename}_node_status.txt: record the number
 *				  of packets present in the subqueues
 *
 *				* {basename}_pkt_delay.txt: record the MAC delay
 *               
 *				* {basename}_beacon_frame_sent.txt: record the number
 *				  of beacon frame sent
 *
 *				* {basename}_beacon_frame_rcv.txt: record the number
 *				  of beacon frame received	
 * No parameter
 */

static void lr_wpan_collect_stat_nodes ()
{
	FILE * fp;
	char report_name[128];
	Boolean exist;
	double mac_delay;
	
	const char * subdirectory	= "\\nodes\\";
	const char * subdirectory_retx	= "\\retransmissions\\";
	
	const char * packet_rcv        = "_pkt_rcv.txt";
	const char * packet_sent       = "_pkt_sent.txt";
	const char * node_queues       = "_node_queues.txt";
	const char * packet_delay      = "_pkt_delay.txt";
	
	const char * beacon_frame_sent = "_beacon_frame_sent.txt";
	const char * beacon_frame_rcv  = "_beacon_frame_rcv.txt";
	
	const char * retransmission_list = "_retransmission_list.txt";
	const char * transmission_list = "_transmission_list.txt";
	
	Wpan_Queue * queue;
	int i; // loop variable
	time_t date;
	char date_str[32];
	
	retx* elem_ptr;
	tx* elem1_ptr;
	
	FIN (lr_wpan_collect_stat_nodes ());
	
	//printf("starting ENDSIM of node %s\n", lr_wpan_node_name);
	
	/* get the date of the day */
	time (&date);
	sprintf (date_str, "%s", ctime (&date));
	
	if(DEBUG_test || DEBUG_BEACON_RCVD || DEBUG_Backoff || DEBUG_Tx_Beacon || DEBUG_State || DEBUG_Rx_Ack || DEBUG_Rx_Data || DEBUG_Data_Tx || DEBUG_Idle_State || DEBUG_MAC_Application)
		fclose (fp_debug);
	
	
	/* PACKET RCV -- get the report name */
	sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, packet_rcv); 
	//printf("report name: %s\n", report_name);
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	printf("%s printing subdirectory %s\n", lr_wpan_node_name, report_name);
	
	/* write a header in the file if it has been created now*/
	if (!exist)
		{
		fprintf (fp, "\n\t*** Packet received at the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tData pkt rcv:\t\tnumber of MAC data packets received\n");
		fprintf (fp, "\tPkt collided:\t\tnumber of MAC data packets collided (not accepted because the RX flag was not idle)\n");
		fprintf (fp, "\tPkt lost:\t\tnumber of MAC data packets lost due to interference (accept = 0)\n");
		fprintf (fp, "\tAck pkt rcv:\t\tnumber of acknowledgment packets received\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Data pkt rcv\t Pkt collided\t Pkt lost\t Ack pkt rcv\t Simulation time\t Last modified date\n");
		}
		
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s",
		integer_to_string (statistic.Data_Pkt_Rcv, 10),
		integer_to_string (statistic.Pkt_Collided, 9),
		integer_to_string (statistic.Pkt_Lost, 8),
		integer_to_string (statistic.Ack_Pkt_Rcv, 9),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
	
	/* PACKET SENT -- get the report name */
	sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, packet_sent);
	
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now*/
	if (!exist)
		{
		fprintf (fp, "\n\t*** Packet sent from the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tSgmt generated:\t\tdata segment generated in the MAC layer\n");
		fprintf (fp, "\tData pkt sent:\t\ttotal number of data packets sent\n");
		fprintf (fp, "\tAck pkt sent:\t\tnumber of acknowledgement packets sent\n");
		fprintf (fp, "\tPkt dropped:\t\tnumber of higher layer packets dropped (maximum number of retransmissions reached or CCA failed)\n");
		fprintf (fp, "\tPkt dropped CCA:\tnumber of higher layer packets dropped (CCA failed)\n");
		fprintf (fp, "\tPkt dropped retx:\tnumber of higher layer packets dropped (maximum number of retransmissions reached)\n");
		fprintf (fp, "\tSgmt dropped:\t\tnumber of segments dropped\n");
		fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmitted packets\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Sgmt generated\t Data pkt sent\t Ack pkt sent\t Pkt dropped\t Pkt dropped CCA\t Pkt dropped retx\t Seg dropped\t Retransmit pkt\t Simulation time\t last modified date\n");
		}
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.Segment_generated, strlen ("Sgmt generated")),
		integer_to_string (statistic.Data_Pkt_Sent, 10),  
		integer_to_string (statistic.Ack_Pkt_Sent, 10),    
		integer_to_string (statistic.Pkt_Dropped, 10),  
		integer_to_string (statistic.Pkt_Dropped_CCA, strlen ("Pkt dropped CCA")),  
		integer_to_string (statistic.Pkt_Dropped_retx, strlen ("Pkt dropped retx")),
		integer_to_string (statistic.Segment_Dropped, 8),  
		integer_to_string (statistic.Retransmission, 8),   
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
	/* QUEUES */
	if (wpan_queue != NULL)
		{
		/* get the report name */
		sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, node_queues);
		
		/* open the report file */
		fp = lr_wpan_open_report_file (report_name, &exist);
		
		/* Print the header of the file if it has been created now*/
		if (!exist)
			{
			fprintf (fp, "\t*** Status of the node queues for %s ***\n", lr_wpan_node_name);
			fprintf (fp, "\tCreation date: %s\n", date_str);
			fprintf (fp, "\tSubq n length:\t\tsize of the subqueue n\n");
			fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
			
			for (i=0; i < wpan_queue->nb_element; i++)
				fprintf (fp, "Subq %d length,\t", i);
			
			/* print the return char */
			fprintf (fp, "simulation time\t last modified date\n");
			}
		
		/* print the results */
		for (i=0, queue = wpan_queue; i < wpan_queue->nb_element; i++)
			{
			fprintf (fp, "%s,\t", integer_to_string (queue->size, 13));
			queue = queue->next;
			}
		
		/* print the return char */
		fprintf (fp, "%s\t %s", double_to_string (op_sim_time (), strlen ("simulation time")), date_str);
		
		fclose (fp);
		}
	
	
	/* PACKET DELAY -- get the report name */
	sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, packet_delay);
	
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* Print the header of the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\t*** Packet delay at the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tTotal MAC delay:\tsum of all the delay collected at the MAC level\n");
		fprintf (fp, "\tNb data pkt:\t\ttotal number of data packets received\n");
		fprintf (fp, "\tMAC delay (average):\taverage of the MAC delay for one packet\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Total MAC delay\t Nb data pkt\t MAC delay (average)\t simulation time\t last modified date\n");
		}
	
	/* compute the MAC average delay */
	mac_delay = (statistic.Data_Pkt_Rcv) ? statistic.Total_MAC_Delay / (double) statistic.Data_Pkt_Rcv : -1.0;
	
	/* print the results */
	fprintf (fp, "%s\t %s\t %s\t %s\t %s", double_to_string (statistic.Total_MAC_Delay, 11), 
		integer_to_string (statistic.Data_Pkt_Rcv, 11),
		double_to_string (mac_delay, 15),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
	
	if (!bulk_data_source)
		{
		/* 
		 * we don't have the simple source but the TCP/IP stack, so we must
		 * generate a report for the upper layer
		 */
		/* get the report name */
		sprintf (report_name, "%s%s_higher_layer.txt", subdirectory, lr_wpan_node_name);
	
		fp = lr_wpan_open_report_file (report_name, &exist);
	
		/* Print the header of the file */
		if (!exist)
			{
			fprintf (fp, "\t*** Packet delay at the node %s ***\n", lr_wpan_node_name);
			fprintf (fp, "\tCreation date: %s\n", date_str);
			fprintf (fp, "\tnb pkt rcvd:\t\ttotal number of higher layer packets received\n");
			fprintf (fp, "\tnb bits rcvd:\t\ttotal number of higher layer bits received\n");
			fprintf (fp, "\tnb pkt sent:\t\ttotal number of higher layer packets sent\n");
			fprintf (fp, "\tnb bits sent:\t\ttotal number of higher layer bits sent\n");			
			fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
			fprintf (fp, "nb packets rcvd\t nb bits rcvd\t nb packets sent\t nb bits sent\t simulation time\t last modified date\n");
			}
				
		/* print the results */
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s", integer_to_string (statistic.tcp_HL_pkt_rcvd, strlen ("nb pkt rcvd")),
			integer_to_string (statistic.tcp_HL_bit_rcvd, strlen ("nb bits rcvd")),
			integer_to_string (statistic.tcp_HL_pkt_sent, strlen ("nb pkt sent")),
			integer_to_string (statistic.tcp_HL_bit_sent, strlen ("nb bits sent")),
			double_to_string (op_sim_time (), strlen ("simulation time")),
			date_str);
		
		fclose (fp);
		}
	
	
		
	/* Report the number of BEACONS SENT */
	/* get the report name */
	sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, beacon_frame_sent);
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	/* write a header in the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\t*** Beacon frame sent from the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tBeacon frame sent:\t\ttotal number of beacon frame sent\n");
		fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Beacon frame sent\t Simulation time\t last modified date\n");
		}
	fprintf (fp, "%s\t %s\t %s", integer_to_string (statistic.Beacon_Frame_Sent, strlen ("Beacon frame sent")),
		double_to_string (op_sim_time (), strlen ("simulation time")), date_str);
	fclose (fp);

	
	/* Report the number of BEACONS RECEIVED */
	/* get the report name */
	sprintf (report_name, "%s%s%s", subdirectory, lr_wpan_node_name, beacon_frame_rcv);
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	/* write a header in the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\t*** Beacon frame received by the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tBeacon frame received:\t\ttotal number of beacon frame received\n");
		fprintf (fp, "\tBeacon frame Collided\t\ttotal number of beacon frame collided (not accepted because the RX flag was not idle)\n");
		fprintf (fp, "\tBeacon frame Noise:\t\ttotal number of beacon frame noise\n");
		fprintf (fp, "\tBeacon frame Lost:\t\ttotal number of beacon frame lost due to interference (accept = 0)\n");
		fprintf (fp, "\tSimulation time:\t\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Beacon frame received\t Beacon Frame Collided\t Beacon Frame Noise\t Beacon Frame Lost\t Simulation time\t last modified date\n");			
		}
	
	fprintf (fp, "%s\t %s\t %s\t %s\t  %s\t %s ", 
		integer_to_string (statistic.Beacon_Frame_Rcv, strlen ("Beacon frame received")),
		integer_to_string (statistic.Beacon_Frame_Collided, strlen ("Beacon Frame Collided")),
		integer_to_string (statistic.Beacon_Frame_Noise, strlen ("Beacon Frame Noise")),
		integer_to_string (statistic.Beacon_Frame_Lost, strlen ("Beacon Frame Lost")),
		double_to_string  (op_sim_time (), 
		strlen ("simulation time")), date_str);
	fclose (fp);

	
	/* Report information about the RETRANSMISSIONS */
	/* get the report name */
	sprintf (report_name, "%s%s%s", subdirectory_retx, lr_wpan_node_name, retransmission_list);
	
	/* open the report file */
	
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now */
	
	if (!exist)
		{
		fprintf (fp, "\n\t*** Information about retransmissions for the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tTime\t retransmissions\t \n\n");
		}
	
	elem_ptr = (retx*) op_prg_mem_alloc( sizeof(retx) );
	/*if(!strcmp(lr_wpan_node_name,"coordinator"))
		printf("stat node intermediate 2.3: %s\n", lr_wpan_node_name);*/
	for(i=0; i<op_prg_list_size (statistic_retx_list_ptr); i++)
		{
		elem_ptr = op_prg_list_access (statistic_retx_list_ptr, i);
		fprintf (fp, "%s\t %s\n",
			double_to_string (elem_ptr->time,10),
			integer_to_string ((int)elem_ptr->retransmissions, 10)
			);
		}
	fprintf(fp, "--------------------------------------------------\n");
	
	fclose (fp);
	
	/* get the report name */
	sprintf (report_name, "%s%s%s", subdirectory_retx, lr_wpan_node_name, transmission_list);
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	/* write a header in the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\n\t*** Information about transmissions for the node %s ***\n", lr_wpan_node_name);
		fprintf (fp, "\tTime\t transmissions\t \n\n");
		}
	
	elem1_ptr = (tx*) op_prg_mem_alloc( sizeof(tx) );
	for(i=0; i<op_prg_list_size (statistic_tx_list_ptr); i++)
		{
		elem1_ptr = op_prg_list_access (statistic_tx_list_ptr, i);
		fprintf (fp, "%s\t %s\n",
			double_to_string (elem1_ptr->time,10),
			integer_to_string ((int)elem1_ptr->transmissions, 10)
			);
		}
	fprintf(fp, "--------------------------------------------------\n");
	
	fclose (fp);
	if(!strcmp(lr_wpan_node_name,"coordinator"))
		printf("stat node: %s\n", lr_wpan_node_name);
	FOUT;
}


/*
 * Function:	lr_wpan_collect_stat_global (coded by Flavia Martelli)
 *
 * Description:	collect data at the end of the simulation
 *				
 *				file created during this function:
 *	
 *				* {scenario}.txt: record delivery ratio, Ps and MAC average delay
 *
 * No parameter
 */

static void lr_wpan_collect_stat_global ()
{
	FILE * fp;
	char report_name[128];
	Boolean exist;
	double mac_delay,mac_delay_considering_dropped, G_channel, G_offered;
		
	time_t date;
	char date_str[32];
	
	retx* elem_ptr;
	tx* elem1_ptr;
	stack_change* elem2_ptr;
	stack_change* elem3_ptr;
	int i;
	//char traffic_name[10] = "G_";
	char service_str[100];
	
	
	
	
	FIN (lr_wpan_collect_stat_global ());
	printf("node %s goes collect stat global\n", lr_wpan_node_name);
	
	elem_ptr = (retx*) op_prg_mem_alloc( sizeof(retx) );
	elem1_ptr = (tx*) op_prg_mem_alloc( sizeof(tx) );
	elem2_ptr = (stack_change*) op_prg_mem_alloc( sizeof(stack_change) );
	elem3_ptr = (stack_change*) op_prg_mem_alloc( sizeof(stack_change) );
	
	/* get the date of the day */
	time (&date);
	sprintf (date_str, "%s", ctime (&date));
	
	
	printf("End of Simulation, coordinator node\n");
	
	
	
	/* get the report name */
	sprintf (report_name, "%s.txt", lr_wpan_scenario);
	
	
	printf("Report Name: %s\n", report_name);
	
	
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\n\t*** Global statistics for the scenario %s ***\n", lr_wpan_scenario);
		fprintf (fp, "\tCreation date: %s\n", date_str);
		fprintf (fp, "\tChannel traffic :\t\tchannel traffic (Ts*pkt_sent/sim_time)\n");
		fprintf (fp, "\tOffered traffic :\t\toffered traffic (taking into account also CCA attempts)\n");
		fprintf (fp, "\tApplication generated :\t\ttotal number of packets generated by the application\n");
		fprintf (fp, "\tPackets enqueued at the MAC :\ttotal number of packets enqueued at the MAC layer \n");
		fprintf (fp, "\tPackets not enqueued at the MAC :total number of packets not enqueued at the MAC layer (because another packets had already being processed)\n\n");
		fprintf (fp, "\tTot sent :\t\ttotal number of packets sent \n");
		fprintf (fp, "\tTot rcvd :\t\ttotal number of packets received \n");
		fprintf (fp, "\tCCA failed :\t\tnumber of times the CCA failed (without counting when a packet is dropped))\n");
		fprintf (fp, "\tTot dropped :\t\ttotal number of packets dropped (maximum number of retransmissions reached or CCA failed)\n");
		fprintf (fp, "\tTot dropped CCA:\ttotal number of packets dropped (CCA failed)\n");
		fprintf (fp, "\tTot dropped retx:\ttotal number of packets dropped (maximum number of retransmissions reached)\n");
		fprintf (fp, "\tRetransmit pkt:\t\tnumber of retransmitted packets\n\n");
		fprintf (fp, "\tMac delay:\t\tmac delay per paket received (sec)\n");
		fprintf (fp, "\tMac delay 2:\t\tmac delay per paket received (sec) (considering dropped packets)\n\n");
		fprintf (fp, "\tNumber of backoffs: \t total numbers of slots spent in backoff\n");
		fprintf (fp, "\tBeacon rcv backoff:\t Total number of beacon frames received during backoff\n");
		fprintf (fp, "\tCCA:\t\t Total number of CCA\n");
		fprintf (fp, "\tAckTimeOut:\t\t Total number of maxMacAckWaitTime expired\n\n");
		fprintf (fp, "\tSimulation time:\ttotal simulation time in seconds\n\n");
		fprintf (fp, "Channel traffic\t Offered traffic\t Application generated\t Packets enqueued at the MAC\t Packets not enqueued at the MAC\t Tot sent\t Tot received\t CCA failed\t Tot dropped\t Tot dropped CCA\t Tot dropped retx\t Retransmit pkt\t Mac delay\t Mac delay 2\t Number of backoffs\t Beacon rcv backoff \t\tCCA\t AckTimeOut\t Simulation time\t Last modified date\n\n");
		}
	
	
	
	/*Compute offered traffic*/
	G_channel = aBaseSlotDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE*((double) global_statistics.Data_Pkt_Sent)/op_sim_time ();
	G_offered = aBaseSlotDuration*LR_WPAN_BITS_PER_SYMBOL/LR_WPAN_BIT_RATE*((double) global_statistics.Data_Pkt_Sent+(double)global_statistics.Pkt_Dropped_CCA+(double)Global_CCA_Statistics.First_CCA_Failure_Count)/op_sim_time ();
	
	/*Compute delivery ratio and Ps
	delivery_ratio = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Segment_generated);
	Ps = ((double) global_statistics.Data_Pkt_Rcv) / ((double) global_statistics.Data_Pkt_Sent);
	Ps2 = ((double) global_statistics.Data_Pkt_Rcv) / (((double) global_statistics.Data_Pkt_Sent)+(double)global_statistics.Pkt_Dropped_CCA+(double)Global_CCA_Statistics.First_CCA_Failure_Count);*/
	
	/* compute the MAC average delay */
	mac_delay = (statistic.Data_Pkt_Rcv) ? statistic.Total_MAC_Delay / (double) statistic.Data_Pkt_Rcv : -1.0;
	mac_delay_considering_dropped = (statistic.Data_Pkt_Rcv) ? (statistic.Total_MAC_Delay+global_statistics.Total_Delay_Dropped_packets) / (double) statistic.Data_Pkt_Rcv : -1.0;
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s",
		double_to_string (G_channel, strlen ("Channel traffic")),
		double_to_string (G_offered, strlen ("Offered traffic")),
		integer_to_string ((int)global_statistics.Application_generated, 15),
		integer_to_string ((int)global_statistics.Segment_generated, strlen ("Packets enqueued at the MAC")),
		integer_to_string ((int)global_statistics.Pkt_not_enqueued, strlen ("Packets not enqueued at the MAC")),
		integer_to_string ((int)global_statistics.Data_Pkt_Sent, 8),
		integer_to_string ((int)global_statistics.Data_Pkt_Rcv, 8),
		integer_to_string ((int)Global_CCA_Statistics.First_CCA_Failure_Count, 11),
		integer_to_string ((int)global_statistics.Pkt_Dropped, 11),
		integer_to_string ((int)global_statistics.Pkt_Dropped_CCA, 16),
		integer_to_string ((int)global_statistics.Pkt_Dropped_retx, 16),
		integer_to_string ((int)global_statistics.Retransmission, 10),
		double_to_string (mac_delay, 9),
		double_to_string (mac_delay_considering_dropped, 10),
		integer_to_string ((int)global_statistics.Total_number_backoff_slots, 15),
		integer_to_string ((int)global_statistics.Total_backoff_wait_for_beacon, strlen ("Beacon rcv backoff")),
		integer_to_string ((int)Global_CCA_Statistics.First_CCA_count, 9),
		integer_to_string ((int)global_statistics.Total_Ack_not_rcv, 10),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
	
	fclose (fp);
	
		
	/* cretae a  .txt file without headers, for Matlab postprocessing */
	
	/* get the report name */
	sprintf (report_name, "%s_matlab.txt", lr_wpan_scenario);
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\t %s\n",
		double_to_string (G_channel, strlen ("Channel traffic")),
		double_to_string (G_offered, strlen ("Offered traffic")),
		integer_to_string ((int)global_statistics.Application_generated, 10),
		integer_to_string ((int)global_statistics.Segment_generated, strlen ("Tot seg generated")),
		integer_to_string ((int)global_statistics.Pkt_not_enqueued, strlen ("Tot seg generated")),
		integer_to_string ((int)global_statistics.Data_Pkt_Sent, 8),
		integer_to_string ((int)global_statistics.Data_Pkt_Rcv, 8),
		integer_to_string ((int)Global_CCA_Statistics.First_CCA_Failure_Count, 11),
		integer_to_string ((int)global_statistics.Pkt_Dropped, 11),
		integer_to_string ((int)global_statistics.Pkt_Dropped_CCA, 16),
		integer_to_string ((int)global_statistics.Pkt_Dropped_retx, 16),
		integer_to_string ((int)global_statistics.Retransmission, 10),
		double_to_string (mac_delay, 9),
		double_to_string (mac_delay_considering_dropped, 10),
		integer_to_string ((int)global_statistics.Total_number_backoff_slots, 15),
		integer_to_string ((int)global_statistics.Total_backoff_wait_for_beacon, strlen ("Beacon rcv backoff")),
		integer_to_string ((int)Global_CCA_Statistics.First_CCA_count, 9),
		integer_to_string ((int)global_statistics.Total_Ack_not_rcv, 10),
		double_to_string (op_sim_time (), strlen ("simulation time")));
	
	fclose (fp);
	
	/* create a file with information about protocol stack changes*/
	if(GADGET_enabled)
		{
		sprintf (report_name, "%s_stack_changes.txt", lr_wpan_scenario);
		
		/* open the report file */
		fp = lr_wpan_open_report_file (report_name, &exist);
		if (!exist)
			{
			fprintf (fp, "\n\t*** Global information about protocol stack changes for the scenario %s ***\n", lr_wpan_scenario);
			fprintf (fp, "\tTime\t Slotted ALOHA\t PSMA\t Observed Traffic\t Observed SNR\n\n");
			}
		for(i=0; i<op_prg_list_size (list_stack_change_ptr); i++)
			{
			//printf("printing stack changes\n");
			elem2_ptr = op_prg_list_access (list_stack_change_ptr, i);
			fprintf (fp, "%s\t %s\t %s\t %s\t %s\n",
				double_to_string (elem2_ptr->time,10),
				integer_to_string ((int)elem2_ptr->s_aloha_status, 10),
				integer_to_string ((int)elem2_ptr->psma_status, 10),
				double_to_string (elem2_ptr->observed_traffic,10),
				double_to_string (elem2_ptr->observed_snr,10)
				);
			}
	
		fprintf(fp, "--------------------------------------------------\n");
	
		fclose (fp);
		}
	
	/* create a file with information about superframe average SNR and Traffic*/
	
	sprintf (report_name, "%s_superframe_Traffic_and_SNR.txt", lr_wpan_scenario);
		
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	if (!exist)
		{
		fprintf (fp, "\n\t*** Global information about Traffic and SNR for the scenario %s ***\n", lr_wpan_scenario);
		fprintf (fp, "\tTime\t Slotted ALOHA\t PSMA\t Observed Traffic\t Observed SNR\n\n");
		}
	for(i=0; i<op_prg_list_size (list_traffic_snr_ptr); i++)
		{
		//printf("printing traffic and SNR\n");
		elem3_ptr = op_prg_list_access (list_traffic_snr_ptr, i);
		fprintf (fp, "%s\t %s\t %s\t %s\t %s\n",
			double_to_string (elem3_ptr->time,10),
			integer_to_string ((int)elem3_ptr->s_aloha_status, 10),
			integer_to_string ((int)elem3_ptr->psma_status, 10),
			double_to_string (elem3_ptr->observed_traffic,10),
			double_to_string (elem3_ptr->observed_snr,10)
		);
		}
	
	fprintf(fp, "--------------------------------------------------\n");
	
	fclose (fp);

	
	/* create a file with information about retransmissions*/
	/* get the report name */
	//sprintf (report_name, "%s_retransmissions.txt", lr_wpan_scenario);
	/* open the report file */
	//fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now */
	/*if (!exist)
		{
		fprintf (fp, "\n\t*** Global information about retransmissions for the scenario %s ***\n", lr_wpan_scenario);
		fprintf (fp, "\tTime\t retransmissions\t \n\n");
		}
	
	for(i=0; i<op_prg_list_size (list_retx_ptr_global); i++)
		{
		elem_ptr = op_prg_list_access (list_retx_ptr_global, i);
		fprintf (fp, "%s\t %s\n",
			double_to_string (elem_ptr->time,10),
			integer_to_string ((int)elem_ptr->retransmissions, 10)
			);
		}
	
	fprintf(fp, "--------------------------------------------------\n");
	
	fclose (fp);*/
	
	/* get the report name */
	//sprintf (report_name, "%s_transmissions.txt", lr_wpan_scenario);
	/* open the report file */
	//fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now */
	/*if (!exist)
		{
		fprintf (fp, "\n\t*** Global information about transmissions for the scenario %s ***\n", lr_wpan_scenario);
		fprintf (fp, "\tTime\t transmissions\t \n\n");
		}
	
	for(i=0; i<op_prg_list_size (list_tx_ptr_global); i++)
		{
		elem1_ptr = op_prg_list_access (list_tx_ptr_global, i);
		fprintf (fp, "%s\t %s\n",
			double_to_string (elem1_ptr->time,10),
			integer_to_string ((int)elem1_ptr->transmissions, 10)
			);
		}
	
	fprintf(fp, "--------------------------------------------------\n");
	
	fclose (fp);*/
	
	// method to create separate files with traffic as identifier in file name
	// sprintf (service_str, "%s%s%.2f_%s", file_service_time, traffic_name, G_offered, service_name);
	
	sprintf (service_str, "%s%s", file_service_time, service_name);
	
	fp_service_time = fopen (service_str, "a");
	
	for (i=0;i<MAX_SERV_TIME;i++)
		{
			fprintf(fp_service_time,"%d\t", frame_service_time[i]);
		
		}
	fprintf(fp_service_time, "\n");
	
	fclose (fp_service_time);
	
	FOUT;
}


/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_init (int * init_block_ptr);
	void _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_alloc (VosT_Obtype, int);
	void _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET ());

		{


		FSM_ENTER ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "Init", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init enter execs]", state0_enter_exec)
				{
				/* initialize the process */
				lr_wpan_mac_init ();
				
				
				if (!bulk_data_source)
					{
					/*
					 * If the packet source is the tcp/ip stack,
					 * we need to register the MAC layer in the 
					 * model wide registry 
					 */
					lr_wpan_model_wide_register ();
					}
				/* create a self interupt */
				op_intrpt_schedule_self (op_sim_time (), 0);
				
				
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (Init) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "Init", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init exit execs]", state0_exit_exec)
				{
				if (!bulk_data_source)
					{
					/*
					 * if the TCP/IP stack is present, we need
					 * to resolve the MAC address of the node
					 */
					lr_wpan_mac_address_resolve ();
					}
				
				/*
				 * If we are in a Slotted mode and the current node is the master,
				 * we schedule the first Beacon packet transmission
				 */
				if (my_parameters->slotted_enable && my_parameters->master_enable)
					{
					/* check the consistency of the slotted mode parameters */
					lr_wpan_slotted_consistency (my_parameters);
				
					/* create the MAC address table to send the Beacons on broadcast */
					lr_wpan_slotted_generate_addr_table (my_parameters, &lr_wpan_beacon_param);
				
					/* schedule the first Beacon packet */
					op_intrpt_schedule_self (lr_wpan_slotted_boundary_time (), Wpan_Beacon_To_Send);
					}
				
				
				}
				FSM_PROFILE_SECTION_OUT (state0_exit_exec)


			/** state (Init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Init", "Idle", "tr_0", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init -> Idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (Idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Idle", state1_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle enter execs]", state1_enter_exec)
				{
				/* print a debugging message */
				ENTER_STATE_ODB_PRINTING ("enter the \"Idle\" state");
				
				if(DEBUG_Idle_State) fprintf(fp_debug, "MAC MODULE: Node %s Enter Idle state at %f sec with intrpt code %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				
				if( (my_parameters->slotted_enable == OPC_FALSE) || ((my_parameters->slotted_enable == OPC_TRUE) &&\
					(sf_param.CAP_PERIOD_ACTIVE == OPC_TRUE) && (csma_operation_param.wait_for_the_next_superframe == OPC_FALSE)) )
					{
					
					if (!wpan_transmission_required) 
						{
						if (retransmission_ptr == OPC_NIL) //check if we don't have to retx a packet
							{ 
							/* check the queues to know whether we have some new packets to send */
							lr_wpan_subq_checking ();
							}
						else //we are in the case of a retx
							{ 
							
							/* update BE and number of transmission retries*/
							lr_wpan_ack_not_received();
							
							/* check the number of transmission retries */
							if (nb_transmission_retries <= max_frame_retries)
								{
								/* schedule the retransmission */
								op_intrpt_schedule_self (op_sim_time (), Data_Pkt_To_Send);
								}
							else
								{
								/* 
								* the maximum number of retransmission is reach, we have
								* to drop the packet
								*/
								if (!lr_wpan_destroy_retransmission ())
									{
									/*
									* if this packet is not the last segment of the higher layer
									* we have to destroy the left segments
									*/
									lr_wpan_drop_higher_layer_pkt ();
									}
							
								/* update the statistic */
								statistic.Pkt_Dropped ++;
								global_statistics.Pkt_Dropped ++;
								
								statistic.Pkt_Dropped_retx ++;
								global_statistics.Pkt_Dropped_retx ++;
								/*
								* we have to count the segment dropped
								* in the function "lr_wpan_destroy_retransmission"
								*/
								statistic.Segment_Dropped ++;
								
								if(DEBUG_Data_Tx)
									fprintf(fp_debug, "Node %s dropped packet because of max number of retries exceeded at time %.12f sec\n", lr_wpan_node_name, op_sim_time());
								
								/* reset backoff parameters */
								lr_wpan_reset_backoff_parameters();
								}
							}
						}
				
				
					}
				}
				FSM_PROFILE_SECTION_OUT (state1_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (Idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Idle", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle exit execs]", state1_exit_exec)
				{
				/* check if we receive some packet */
				//if(DEBUG_Idle_State) printf("MAC MODULE: Node %s Exit Idle state\n", lr_wpan_node_name);
				
				lr_wpan_intrpt_check ("Idle");
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (Idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (PACKET_TO_SEND)
			FSM_TEST_COND (EMERGENCY_PACKET_TO_SEND)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 6, state6_enter_exec, ;, "PACKET_TO_SEND", "", "Idle", "Init Backoff", "tr_1", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle -> Init Backoff : PACKET_TO_SEND / ]")
				FSM_CASE_TRANSIT (1, 8, state8_enter_exec, ;, "EMERGENCY_PACKET_TO_SEND", "", "Idle", "Emerg_init_backoff", "tr_124", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle -> Emerg_init_backoff : EMERGENCY_PACKET_TO_SEND / ]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "default", "", "Idle", "Idle", "tr_29", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Idle -> Idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (BackOff) enter executives **/
			FSM_STATE_ENTER_UNFORCED (2, "BackOff", state2_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff enter execs]", state2_enter_exec)
				{
				//if(DEBUG_State)printf("Node: %s Backoff\n", lr_wpan_node_name);
				if(DEBUG_State) fprintf(fp_debug, "Node: %s Backoff state at %12f s with intrpt %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				
				
				/*
				 * We have a packet arriving from the higher layer
				 * We need to send it. To do so, we have to wait for
				 * a backoff period and listen the channel (CCA state)
				 */
				
				/* print a debugging message */
				ENTER_STATE_ODB_PRINTING ("enter the \"Backoff\" state");
				
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (5,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (BackOff) exit executives **/
			FSM_STATE_EXIT_UNFORCED (2, "BackOff", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff exit execs]", state2_exit_exec)
				{
				
				/* check if we receive some packet */
				lr_wpan_intrpt_check ("Backoff");
				
				CCA_stage = 1;
				
				}
				FSM_PROFILE_SECTION_OUT (state2_exit_exec)


			/** state (BackOff) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff trans conditions]", state2_trans_conds)
			FSM_INIT_COND (PSMA_BACKOFF_EXPIRED)
			FSM_TEST_COND (BACKOFF_TO_IDLE)
			FSM_TEST_COND (S_ALOHA_BACKOFF_EXPIRED)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("BackOff")
			FSM_PROFILE_SECTION_OUT (state2_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 3, state3_enter_exec, lr_wpan_cca_init ();, "PSMA_BACKOFF_EXPIRED", "lr_wpan_cca_init ()", "BackOff", "CCA", "tr_13", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff -> CCA : PSMA_BACKOFF_EXPIRED / lr_wpan_cca_init ()]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ;, "BACKOFF_TO_IDLE", "", "BackOff", "Idle", "tr_104", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff -> Idle : BACKOFF_TO_IDLE / ]")
				FSM_CASE_TRANSIT (2, 7, state7_enter_exec, s_aloha_set_flags();, "S_ALOHA_BACKOFF_EXPIRED", "s_aloha_set_flags()", "BackOff", "TX", "tr_115", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff -> TX : S_ALOHA_BACKOFF_EXPIRED / s_aloha_set_flags()]")
				FSM_CASE_TRANSIT (3, 2, state2_enter_exec, ;, "default", "", "BackOff", "BackOff", "tr_33", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [BackOff -> BackOff : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (CCA) enter executives **/
			FSM_STATE_ENTER_UNFORCED (3, "CCA", state3_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA enter execs]", state3_enter_exec)
				{
				//if(DEBUG_State)printf("Node: %s CCA\n", lr_wpan_node_name);
				if(DEBUG_State) fprintf(fp_debug, "Node: %s CCA state at %12f s with intrpt code %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				/* debugging */
				ENTER_STATE_ODB_PRINTING ("Enter the \"CCA\" state");
				
				if(my_parameters->slotted_enable == OPC_TRUE)
					{
					csma_operation_param.evaluate_after_backoff	= OPC_FALSE;
					csma_operation_param.can_proceed = OPC_FALSE;	
					csma_operation_param.pending_backoff_periods = 0;
					csma_operation_param.CCA_evaluation_pending	= OPC_FALSE;
					csma_operation_param.backoff_countdown_is_paused = OPC_FALSE;
					}
				
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (7,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (CCA) exit executives **/
			FSM_STATE_EXIT_UNFORCED (3, "CCA", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA exit execs]", state3_exit_exec)
				{
				/* check the interruption */
				lr_wpan_intrpt_check ("CCA");
				}
				FSM_PROFILE_SECTION_OUT (state3_exit_exec)


			/** state (CCA) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA trans conditions]", state3_trans_conds)
			FSM_INIT_COND (BACK_TO_BACKOFF)
			FSM_TEST_COND (END_OF_CCA)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("CCA")
			FSM_PROFILE_SECTION_OUT (state3_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 6, state6_enter_exec, lr_wpan_cca_failure();, "BACK_TO_BACKOFF", "lr_wpan_cca_failure()", "CCA", "Init Backoff", "tr_14", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA -> Init Backoff : BACK_TO_BACKOFF / lr_wpan_cca_failure()]")
				FSM_CASE_TRANSIT (1, 5, state5_enter_exec, op_stat_write(cca_stat_handle, channel_is_idle);, "END_OF_CCA", "op_stat_write(cca_stat_handle, channel_is_idle)", "CCA", "set Rx flag", "tr_79", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA -> set Rx flag : END_OF_CCA / op_stat_write(cca_stat_handle, channel_is_idle)]")
				FSM_CASE_TRANSIT (2, 3, state3_enter_exec, ;, "default", "", "CCA", "CCA", "tr_47", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [CCA -> CCA : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Wait for Ack) enter executives **/
			FSM_STATE_ENTER_UNFORCED (4, "Wait for Ack", state4_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack enter execs]", state4_enter_exec)
				{
				if(DEBUG_State) fprintf(fp_debug, "Node: %s Wait for Ack state at %12f s with intrpt code %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				
				
				/* print a debugging message */
				ENTER_STATE_ODB_PRINTING ("enter the \"Wait for Ack\" state");
				}
				FSM_PROFILE_SECTION_OUT (state4_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (9,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (Wait for Ack) exit executives **/
			FSM_STATE_EXIT_UNFORCED (4, "Wait for Ack", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack exit execs]", state4_exit_exec)
				{
				/* check if we receive some packet */
				lr_wpan_intrpt_check ("Wait for Ack");
				
				/*
				 * if the transmission is finished, we schedule Ack the time out
				 * Warning: This step should apply only after a Data transmission.
				 */
				if (channel_flag.tx_idle && op_ev_valid (Ack_TimeOut_Evhandle) == OPC_FALSE)
					{
					/* The data transmission is finished */
					channel_flag.data_is_sending = OPC_FALSE;
					
					/* schedule the time out for the acknowledgment*/
					Ack_TimeOut_Evhandle = op_intrpt_schedule_self (op_sim_time () + MAC_ACK_WAIT_DURATION + ((double)LR_WPAN_PHY_OVERHEAD+(double)ACK)/LR_WPAN_BIT_RATE, Ack_Time_Out);
					
					if(DEBUG_State) fprintf(fp_debug, "Node: %s schedules Ack time out for time %f s with intrpt code %d\n", lr_wpan_node_name, (op_sim_time () + MAC_ACK_WAIT_DURATION + ((double)LR_WPAN_PHY_OVERHEAD+(double)ACK)/LR_WPAN_BIT_RATE), op_intrpt_code());
					}
				
				
				/*
					if (my_parameters->slotted_enable)
						{
						/* if we are in the slotted mode, we start the timer at the boundary 
						Ack_TimeOut_Evhandle = op_intrpt_schedule_self (lr_wpan_slotted_boundary_time () + MAC_ACK_WAIT_DURATION, Ack_Time_Out);
						}
					else
						Ack_TimeOut_Evhandle = op_intrpt_schedule_self (op_sim_time () + MAC_ACK_WAIT_DURATION, Ack_Time_Out);
				
					*/
					
					
				}
				FSM_PROFILE_SECTION_OUT (state4_exit_exec)


			/** state (Wait for Ack) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack trans conditions]", state4_trans_conds)
			FSM_INIT_COND (BACK_TO_IDLE)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Wait for Ack")
			FSM_PROFILE_SECTION_OUT (state4_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 1, state1_enter_exec, ;, "BACK_TO_IDLE", "", "Wait for Ack", "Idle", "tr_110", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack -> Idle : BACK_TO_IDLE / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "default", "", "Wait for Ack", "Wait for Ack", "tr_45", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Wait for Ack -> Wait for Ack : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (set Rx flag) enter executives **/
			FSM_STATE_ENTER_FORCED (5, "set Rx flag", state5_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag enter execs]", state5_enter_exec)
				{
				//if(DEBUG_State)printf("Node: %s set Rx flag\n", lr_wpan_node_name);
				if(DEBUG_State)fprintf(fp_debug, "Node: %s set Rx flag state %12f s with intrpt code %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				/* debugging */
				ENTER_STATE_ODB_PRINTING ("Enter the \"Set Rx Flag\" state");
				
				
				if (channel_is_idle)
					{ 
					/* 
					 * after the CCA is completed, if the channel is idle, we need to turn off
					 * the RX flag before the transmission
					 */
					channel_flag.rx_idle = OPC_FALSE;
				
					}
				else
					{
					/* 
					 * Here, all the CCA attempts have failed, we must drop the current packet
					 * and all the segments associates with it if it is the case
					 */
					if (lr_wpan_beacon_param.data_request != OPC_NIL)
						{
						/* we attempt to send a data request, so we destroy it */
						op_pk_destroy (lr_wpan_beacon_param.data_request);
						
						/* we reset the pointer to NULL */
						lr_wpan_beacon_param.data_request = OPC_NIL;
						}
					else if (retransmission_ptr == OPC_NIL)
						{
						/* 
						 * The transmission is not a retransmission:
						 * the packet to transmit is still in the queue,
						 * we have to remove it and all the segment associate
						 * with it from the subqueue
						 */
						lr_wpan_drop_higher_layer_pkt ();
						}
					else if (!lr_wpan_destroy_retransmission ())
						{
						/*
						 * The packet to transmit is a retransmission and 
						 * is not the last segment of the higher layer packet,
						 * we have to destroy the left segments in the subqueue
						 */
						lr_wpan_drop_higher_layer_pkt ();
						
						/*
						 * update the statistic: we have to count the segment
						 * dropped in the function "lr_wpan_destroy_retransmission"
						 */
						statistic.Segment_Dropped ++;
						}
					else
						{
						/* 
						 * if it was a retransmission and the packet was
						 * the last one, just update the number of segment dropped
						 */
						statistic.Segment_Dropped ++;
						}
					/* update the statistic */
					statistic.Pkt_Dropped ++;
					global_statistics.Pkt_Dropped ++;
					
					statistic.Pkt_Dropped_CCA ++;
					global_statistics.Pkt_Dropped_CCA ++;
					
					
					
					if(DEBUG_Data_Tx)
						fprintf(fp_debug, "Node %s dropped packet because of max CCA exceeded at time %.12f sec\n", lr_wpan_node_name, op_sim_time());
					
				    /* reset backoff parameters */
					lr_wpan_reset_backoff_parameters ();
					}
				
				
				/*
				
				
				if (channel_is_idle)
					{
					if(CCA_stage ==2)
						{
						CCA_statistic.Second_CCA_Success_Count++;
						Global_CCA_Statistics.Second_CCA_Success_Count++;
						}
					else if(CCA_stage ==1)
						{
						CCA_statistic.First_CCA_Success_Count++;
						Global_CCA_Statistics.First_CCA_Success_Count++;
						}
				
					}
				else
					{
					if(CCA_stage ==2)
						{
						CCA_statistic.Second_CCA_Failure_Count++;
						Global_CCA_Statistics.Second_CCA_Failure_Count++;
				 
						}
					else if(CCA_stage ==1)
						{
						CCA_statistic.First_CCA_Failure_Count++;
						Global_CCA_Statistics.First_CCA_Failure_Count++;
				 
						}
					}
					
				
				*/
				}
				FSM_PROFILE_SECTION_OUT (state5_enter_exec)

			/** state (set Rx flag) exit executives **/
			FSM_STATE_EXIT_FORCED (5, "set Rx flag", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag exit execs]")


			/** state (set Rx flag) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag trans conditions]", state5_trans_conds)
			FSM_INIT_COND (TRANSMISSION_OK)
			FSM_TEST_COND (TRANSMISSION_NOT_OK)
			FSM_TEST_LOGIC ("set Rx flag")
			FSM_PROFILE_SECTION_OUT (state5_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 7, state7_enter_exec, lr_wpan_cca2_success();, "TRANSMISSION_OK", "lr_wpan_cca2_success()", "set Rx flag", "TX", "tr_18", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag -> TX : TRANSMISSION_OK / lr_wpan_cca2_success()]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ;, "TRANSMISSION_NOT_OK", "", "set Rx flag", "Idle", "tr_117", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [set Rx flag -> Idle : TRANSMISSION_NOT_OK / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Init Backoff) enter executives **/
			FSM_STATE_ENTER_FORCED (6, "Init Backoff", state6_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init Backoff enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init Backoff enter execs]", state6_enter_exec)
				{
				//if(DEBUG_State)printf("Node: %s Init Backoff\n", lr_wpan_node_name);
				if(DEBUG_State) fprintf(fp_debug, "Node: %s Init Backoff state at %12f s with intrpt code %d \n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				
				/* debugging */
				ENTER_STATE_ODB_PRINTING ("Enter the \"init backoff\" state");
				
				/* init the CCA */
				lr_wpan_mac_backoff ();
				
				/* reset the transmission flag if we are in unslotted mode */
				//if (my_parameters->slotted_enable == OPC_FALSE)
					wpan_transmission_required = OPC_FALSE;
				
				}
				FSM_PROFILE_SECTION_OUT (state6_enter_exec)

			/** state (Init Backoff) exit executives **/
			FSM_STATE_EXIT_FORCED (6, "Init Backoff", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init Backoff exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init Backoff exit execs]", state6_exit_exec)
				{
				
				}
				FSM_PROFILE_SECTION_OUT (state6_exit_exec)


			/** state (Init Backoff) transition processing **/
			FSM_TRANSIT_FORCE (2, state2_enter_exec, ;, "default", "", "Init Backoff", "BackOff", "tr_73", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init Backoff -> BackOff : default / ]")
				/*---------------------------------------------------------*/



			/** state (TX) enter executives **/
			FSM_STATE_ENTER_UNFORCED (7, "TX", state7_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX enter execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX enter execs]", state7_enter_exec)
				{
				if(DEBUG_State) fprintf(fp_debug, "Node: %s Tx state at %12f s with intrpt code %d\n", lr_wpan_node_name, op_sim_time(), op_intrpt_code());
				
				/* debugging */
				ENTER_STATE_ODB_PRINTING ("Enter the \"TX\" state");
				
				if(S_ALOHA_BACKOFF_EXPIRED)
					lr_wpan_packet_to_transmit ();
				
				//if(DEBUG_test)
				//if(TRANSMISSION_OK)	
				//fprintf (fp_debug, "MAC MODULE: Node %s enters TX state (Enter) first time at %12f s -- Int Code %d -- TRANSMISSION_OK %d \n", lr_wpan_node_name, op_sim_time(), op_intrpt_code(), TRANSMISSION_OK);	
				 
				 
				
				/*if(psma_time_to_tx)
				{
				if(DEBUG_test)
				 printf("MAC MODULE: Node %s enters third time at %f s \n", lr_wpan_node_name, op_sim_time());
				}
				*/
				}
				FSM_PROFILE_SECTION_OUT (state7_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (15,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (TX) exit executives **/
			FSM_STATE_EXIT_UNFORCED (7, "TX", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX exit execs]")
				FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX exit execs]", state7_exit_exec)
				{
				//if(DEBUG_test)
				  //{
				  //fprintf (fp_debug, "MAC MODULE: Node %s enters TX state (Exit) second time at %12f s -- Int Code %d -- TAT %d \n", lr_wpan_node_name, op_sim_time(), op_intrpt_code(), TAT);
				  //printf("MAC MODULE: Node %s enters TX state at %f s -- Int Code %d -- TAT %d \n", lr_wpan_node_name, op_sim_time(), op_intrpt_code(), TAT);
				  //}
				
				/* check the interuption */
				lr_wpan_intrpt_check ("TX");
				
				if(psma_enabled)
				 {
				 if(TAT)
				  {
				  //if(DEBUG_test)
				   //printf("MAC MODULE: Node %s enters second time at %f s \n", lr_wpan_node_name, op_sim_time());
				  
				  psma_time_to_tx = OPC_TRUE;
					 
				  //op_intrpt_schedule_self(op_sim_time()+(LR_WPAN_BACKOFF_PERIOD_DURATION-WPAN_CCA_PERIOD-WPAN_TURN_AROUND_TIME), PSMA_TIME_TO_TX);
				  //op_intrpt_schedule_self(op_sim_time(), PSMA_TIME_TO_TX);
				  }
				  
				 }
						
				
				}
				FSM_PROFILE_SECTION_OUT (state7_exit_exec)


			/** state (TX) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX trans conditions]", state7_trans_conds)
			FSM_INIT_COND (TAT)
			FSM_TEST_COND (ACKNOWLEDGEMENT)
			FSM_TEST_COND (NO_ACK)
			FSM_TEST_COND (PSMA_TX_NOW)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("TX")
			FSM_PROFILE_SECTION_OUT (state7_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 7, state7_enter_exec, ;, "TAT", "", "TX", "TX", "tr_84", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX -> TX : TAT / ]")
				FSM_CASE_TRANSIT (1, 4, state4_enter_exec, ;, "ACKNOWLEDGEMENT", "", "TX", "Wait for Ack", "tr_83", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX -> Wait for Ack : ACKNOWLEDGEMENT / ]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, unacknowlegement_reset ();, "NO_ACK", "unacknowlegement_reset ()", "TX", "Idle", "tr_111", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX -> Idle : NO_ACK / unacknowlegement_reset ()]")
				FSM_CASE_TRANSIT (3, 7, state7_enter_exec, lr_wpan_packet_to_transmit ();, "PSMA_TX_NOW", "lr_wpan_packet_to_transmit ()", "TX", "TX", "tr_112", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX -> TX : PSMA_TX_NOW / lr_wpan_packet_to_transmit ()]")
				FSM_CASE_TRANSIT (4, 7, state7_enter_exec, ;, "default", "", "TX", "TX", "tr_113", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [TX -> TX : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Emerg_init_backoff) enter executives **/
			FSM_STATE_ENTER_UNFORCED (8, "Emerg_init_backoff", state8_enter_exec, "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (17,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")


			/** state (Emerg_init_backoff) exit executives **/
			FSM_STATE_EXIT_UNFORCED (8, "Emerg_init_backoff", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff exit execs]")


			/** state (Emerg_init_backoff) transition processing **/
			FSM_PROFILE_SECTION_IN ("WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff trans conditions]", state8_trans_conds)
			FSM_INIT_COND ((1))
			FSM_TEST_COND (xxx)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Emerg_init_backoff")
			FSM_PROFILE_SECTION_OUT (state8_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "", "", "Emerg_init_backoff", "BackOff", "tr_119", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff -> BackOff :  / ]")
				FSM_CASE_TRANSIT (1, 1, state1_enter_exec, ;, "xxx", "", "Emerg_init_backoff", "Idle", "tr_121", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff -> Idle : xxx / ]")
				FSM_CASE_TRANSIT (2, 8, state8_enter_exec, ;, "default", "", "Emerg_init_backoff", "Emerg_init_backoff", "tr_123", "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Emerg_init_backoff -> Emerg_init_backoff : default / ]")
				}
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET")
		}
	}




void
_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_svar function. */
#undef intrpt_type
#undef intrpt_stream
#undef intrpt_code
#undef csma_parameters
#undef channel_is_idle
#undef my_parameters
#undef wpan_frequency_center
#undef lr_wpan_node_name
#undef wpan_queue
#undef nb_pkt_subq
#undef nb_pkt_recv
#undef nb_pkt_send
#undef retransmission_ptr
#undef Mac_Data_Rx_Seqn
#undef Rx_Ack_Expected
#undef Tx_Ack_Require
#undef Ack_TimeOut_Evhandle
#undef Mac_Data_Tx_Seqn
#undef Ack_Dest_Addr
#undef channel_flag
#undef statistic
#undef bulk_data_source
#undef TAT_TX_Evhandle
#undef TAT_RX_Evhandle
#undef wpan_transmission_required
#undef current_queue
#undef max_frame_retries
#undef nb_transmission_retries
#undef own_process_record_handle
#undef oms_aa_handle
#undef Acknowledgement_Enable
#undef lr_wpan_beacon_param
#undef Mac_Beacon_Tx_Seqn
#undef sf_param
#undef sf_spec
#undef beacon_interval_time
#undef Wpan_CAP_Period_End_evh
#undef csma_operation_param
#undef can_proceed_index
#undef DEBUG_BEACON_RCVD
#undef lr_wpan_scenario
#undef group_number
#undef CCA_statistic
#undef CCA_stage
#undef last_transmitted_pkt_size
#undef last_tx_pkt_time_generation
#undef node_statistics
#undef DEBUG_Tx_Beacon
#undef DEBUG_MAC_Application
#undef DEBUG_Data_Tx
#undef DEBUG_Rx_Data
#undef DEBUG_Idle_State
#undef DEBUG_Tx_Ack
#undef DEBUG_Rx_Ack
#undef DEBUG_State
#undef DEBUG_Backoff
#undef psma_enabled
#undef s_aloha_enabled
#undef psma_time_to_tx
#undef DEBUG_test
#undef nb_ack_stat_handle
#undef BE_handle
#undef backoff_interval_handle
#undef cca_stat_handle
#undef statistic_retx_list_ptr
#undef aloha_cw
#undef statistic_tx_list_ptr
#undef ideal_poisson_traffic
#undef GADGET_enabled
#undef GADGET_snr
#undef GADGET_pkt_per_superframe
#undef GADGET_sma_snr
#undef GADGET_sma_traffic
#undef GADGET_sma_counter
#undef lecim_enabled
#undef pca_used_enabled
#undef data_rate
#undef pca_allocation_super_rate_enabled
#undef delay_tolerance
#undef lecim_aloha_unit_backoff_periods_per_pca
#undef lecim_channel_number

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET)",
		sizeof (WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state * ptr;
	FIN_MT (_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_alloc (obtype))

	ptr = (WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET [Init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state		*prs_ptr;

	FIN_MT (_op_WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (WPAN_802_15_4a_MAC_PSMA_LECIM_and_Slotted_ALOHA_GADGET_state *)gen_ptr;

	if (strcmp ("intrpt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_type);
		FOUT
		}
	if (strcmp ("intrpt_stream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_stream);
		FOUT
		}
	if (strcmp ("intrpt_code" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_code);
		FOUT
		}
	if (strcmp ("csma_parameters" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->csma_parameters);
		FOUT
		}
	if (strcmp ("channel_is_idle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_is_idle);
		FOUT
		}
	if (strcmp ("my_parameters" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_parameters);
		FOUT
		}
	if (strcmp ("wpan_frequency_center" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wpan_frequency_center);
		FOUT
		}
	if (strcmp ("lr_wpan_node_name" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lr_wpan_node_name);
		FOUT
		}
	if (strcmp ("wpan_queue" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wpan_queue);
		FOUT
		}
	if (strcmp ("nb_pkt_subq" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nb_pkt_subq);
		FOUT
		}
	if (strcmp ("nb_pkt_recv" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nb_pkt_recv);
		FOUT
		}
	if (strcmp ("nb_pkt_send" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nb_pkt_send);
		FOUT
		}
	if (strcmp ("retransmission_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->retransmission_ptr);
		FOUT
		}
	if (strcmp ("Mac_Data_Rx_Seqn" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_Data_Rx_Seqn);
		FOUT
		}
	if (strcmp ("Rx_Ack_Expected" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Rx_Ack_Expected);
		FOUT
		}
	if (strcmp ("Tx_Ack_Require" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Tx_Ack_Require);
		FOUT
		}
	if (strcmp ("Ack_TimeOut_Evhandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Ack_TimeOut_Evhandle);
		FOUT
		}
	if (strcmp ("Mac_Data_Tx_Seqn" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_Data_Tx_Seqn);
		FOUT
		}
	if (strcmp ("Ack_Dest_Addr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Ack_Dest_Addr);
		FOUT
		}
	if (strcmp ("channel_flag" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_flag);
		FOUT
		}
	if (strcmp ("statistic" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->statistic);
		FOUT
		}
	if (strcmp ("bulk_data_source" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->bulk_data_source);
		FOUT
		}
	if (strcmp ("TAT_TX_Evhandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TAT_TX_Evhandle);
		FOUT
		}
	if (strcmp ("TAT_RX_Evhandle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->TAT_RX_Evhandle);
		FOUT
		}
	if (strcmp ("wpan_transmission_required" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->wpan_transmission_required);
		FOUT
		}
	if (strcmp ("current_queue" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->current_queue);
		FOUT
		}
	if (strcmp ("max_frame_retries" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->max_frame_retries);
		FOUT
		}
	if (strcmp ("nb_transmission_retries" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nb_transmission_retries);
		FOUT
		}
	if (strcmp ("own_process_record_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->own_process_record_handle);
		FOUT
		}
	if (strcmp ("oms_aa_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->oms_aa_handle);
		FOUT
		}
	if (strcmp ("Acknowledgement_Enable" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Acknowledgement_Enable);
		FOUT
		}
	if (strcmp ("lr_wpan_beacon_param" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lr_wpan_beacon_param);
		FOUT
		}
	if (strcmp ("Mac_Beacon_Tx_Seqn" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Mac_Beacon_Tx_Seqn);
		FOUT
		}
	if (strcmp ("sf_param" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sf_param);
		FOUT
		}
	if (strcmp ("sf_spec" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->sf_spec);
		FOUT
		}
	if (strcmp ("beacon_interval_time" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->beacon_interval_time);
		FOUT
		}
	if (strcmp ("Wpan_CAP_Period_End_evh" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->Wpan_CAP_Period_End_evh);
		FOUT
		}
	if (strcmp ("csma_operation_param" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->csma_operation_param);
		FOUT
		}
	if (strcmp ("can_proceed_index" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->can_proceed_index);
		FOUT
		}
	if (strcmp ("DEBUG_BEACON_RCVD" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_BEACON_RCVD);
		FOUT
		}
	if (strcmp ("lr_wpan_scenario" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lr_wpan_scenario);
		FOUT
		}
	if (strcmp ("group_number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->group_number);
		FOUT
		}
	if (strcmp ("CCA_statistic" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CCA_statistic);
		FOUT
		}
	if (strcmp ("CCA_stage" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->CCA_stage);
		FOUT
		}
	if (strcmp ("last_transmitted_pkt_size" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_transmitted_pkt_size);
		FOUT
		}
	if (strcmp ("last_tx_pkt_time_generation" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_tx_pkt_time_generation);
		FOUT
		}
	if (strcmp ("node_statistics" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->node_statistics);
		FOUT
		}
	if (strcmp ("DEBUG_Tx_Beacon" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Tx_Beacon);
		FOUT
		}
	if (strcmp ("DEBUG_MAC_Application" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_MAC_Application);
		FOUT
		}
	if (strcmp ("DEBUG_Data_Tx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Data_Tx);
		FOUT
		}
	if (strcmp ("DEBUG_Rx_Data" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Rx_Data);
		FOUT
		}
	if (strcmp ("DEBUG_Idle_State" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Idle_State);
		FOUT
		}
	if (strcmp ("DEBUG_Tx_Ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Tx_Ack);
		FOUT
		}
	if (strcmp ("DEBUG_Rx_Ack" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Rx_Ack);
		FOUT
		}
	if (strcmp ("DEBUG_State" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_State);
		FOUT
		}
	if (strcmp ("DEBUG_Backoff" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Backoff);
		FOUT
		}
	if (strcmp ("psma_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->psma_enabled);
		FOUT
		}
	if (strcmp ("s_aloha_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->s_aloha_enabled);
		FOUT
		}
	if (strcmp ("psma_time_to_tx" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->psma_time_to_tx);
		FOUT
		}
	if (strcmp ("DEBUG_test" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_test);
		FOUT
		}
	if (strcmp ("nb_ack_stat_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nb_ack_stat_handle);
		FOUT
		}
	if (strcmp ("BE_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->BE_handle);
		FOUT
		}
	if (strcmp ("backoff_interval_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->backoff_interval_handle);
		FOUT
		}
	if (strcmp ("cca_stat_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->cca_stat_handle);
		FOUT
		}
	if (strcmp ("statistic_retx_list_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->statistic_retx_list_ptr);
		FOUT
		}
	if (strcmp ("aloha_cw" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->aloha_cw);
		FOUT
		}
	if (strcmp ("statistic_tx_list_ptr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->statistic_tx_list_ptr);
		FOUT
		}
	if (strcmp ("ideal_poisson_traffic" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->ideal_poisson_traffic);
		FOUT
		}
	if (strcmp ("GADGET_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_enabled);
		FOUT
		}
	if (strcmp ("GADGET_snr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_snr);
		FOUT
		}
	if (strcmp ("GADGET_pkt_per_superframe" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_pkt_per_superframe);
		FOUT
		}
	if (strcmp ("GADGET_sma_snr" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_sma_snr);
		FOUT
		}
	if (strcmp ("GADGET_sma_traffic" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_sma_traffic);
		FOUT
		}
	if (strcmp ("GADGET_sma_counter" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->GADGET_sma_counter);
		FOUT
		}
	if (strcmp ("lecim_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lecim_enabled);
		FOUT
		}
	if (strcmp ("pca_used_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pca_used_enabled);
		FOUT
		}
	if (strcmp ("data_rate" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->data_rate);
		FOUT
		}
	if (strcmp ("pca_allocation_super_rate_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->pca_allocation_super_rate_enabled);
		FOUT
		}
	if (strcmp ("delay_tolerance" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->delay_tolerance);
		FOUT
		}
	if (strcmp ("lecim_aloha_unit_backoff_periods_per_pca" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lecim_aloha_unit_backoff_periods_per_pca);
		FOUT
		}
	if (strcmp ("lecim_channel_number" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->lecim_channel_number);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

