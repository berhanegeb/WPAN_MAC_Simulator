/* Process model C form file: lr_wpan_channel_PSMA_GADGET.pr.c */
/* Portions of this file copyright 1986-2009 by OPNET Technologies, Inc. */


/*
 =========================== NOTE ==========================
 This file is automatically generated from lr_wpan_channel_PSMA_GADGET.pr.m
 during a process model compilation.

 Do NOT manually edit this file.
 Manual edits will be lost during the next compilation.
 =========================== NOTE ==========================
*/



/* This variable carries the header into the object file */
const char lr_wpan_channel_PSMA_GADGET_pr_c [] = "MIL_3_Tfile_Hdr_ 150A 30A modeler 7 50ACDC29 50ACDC29 1 s-cwc-pc204 bgebreme 0 0 none none 0 0 none 0 0 0 0 0 0 0 0 21b7 3                                                                                                                                                                                                                                                                                                                                                                                                     ";
#include <string.h>



/* OPNET system definitions */
#include <opnet.h>



/* Header Block */

/*
** $File : WPAN channel header
**
** EPON model in Opnet
** National Institute of Standards and Technology
**
** This model was developed at the National Institute of Standards
** and Technology by employees of the Federal Government in the course
** of their official duties. Pursuant to title 17 Section 105 of the
** United States Code this software is not subject to copyright
** protection and is in the public domain. This is an experimental
** system.  NIST assumes no responsibility whatsoever for its use by
** other parties, and makes no guarantees, expressed or implied,
** about its quality, reliability, or any other characteristic.
**
** We would appreciate acknowledgement if the model is used.
**
** NIST ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION
** AND DISCLAIM ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER
** RESULTING FROM THE USE OF THIS SOFTWARE.
**
** Primary Author:      O. Rebala
** Secondary Author:	N. Chevrollier
** Module description:  channel for Low Rate WPAN model
** Last Modification:   October, 1st 2005
**
*/

/* include header */
#include "lr_wpan_support_15_4a.h"
#include "channel_buffer.h"
#include "Physical_Layer.h"
#include <math.h>
#include "wlan_support.h"
#include <stdio.h>
#include "MATRIX.h"
//#include "MODULATION_TABLES.h"

#include "lr_wpan_stat_write.h"


/* define some constants */
#define PKT_DELIVERY_CODE	0
#define	WPAN_CCA_CODE 		6
#define WPAN_RX_START		8

/* State machine conditions */
#define PACKET_RECEIVED	(INTRPT_STRM)
#define PACKET_TO_SEND 	(INTRPT_SELF && intrpt_code == PKT_DELIVERY_CODE)

#define     MAX_ERROR_TO_CORRECT   35  /* Maximum of errors that we can correct */
#define		STAT_FILE_LENGTH	2000	/*statistics collection vector size */



double *bt_report_table[2][MAX_ERROR_TO_CORRECT];
int count_in = 0;
int count_out = 0;

double min_snr = 100;
double max_snr = 0;
double accumulate_snr = 0;
int channel_buff_global_packet_count = 0;

/*Modification to collect channel utilisation distribution*/
char useful_name[20] = "_useful.txt";
char busy_name[20] = "_busy.txt";
char idle_name[20] = "_idle.txt";
FILE * fp_useful;
FILE * fp_busy;
FILE * fp_idle;
long int useful_period[STAT_FILE_LENGTH];
long int busy_period[STAT_FILE_LENGTH];
long int idle_period[STAT_FILE_LENGTH];

/*Channel model store*/
Channel_Model Channel;

/* File for debug information */
FILE* fp_channel_debug;
char pippo[100] = "C:\\Users\\bgebreme\\op_reports\\Simulation_channel.txt";


/* function prototypes */
static void 		wpan_channel_init (void);
static void 		lr_wpan_chan_error (const char * fcnt, const char * msg, const char * opt);
static void 		lr_wpan_chan_buffer_insert (void);
static int			channel_queue_search_pkt (OpT_Packet_Id pkt_id);
static void 		lr_wpan_channel_pk_send (void);
static int			compute_accept_flag (Buff_Info_Packet * info_packet);
static int 			fec (double ber, int packet_size);
static void 		wlan_flag_transmission (const Buff_Info_Packet * info_packet);
static void 		wlan_flag_transmission_nico (const Buff_Info_Packet * info_packet);

static void			wpan_update_wlan_flag (const Buff_Info_Packet * info_packet);
static void			wpan_flag_cca (const Buff_Info_Packet * info_packet);

static void 		channel_collect_stat (void);
static void 		channel_usage_stat_init (void);
static void			channel_usage_stat (int pkt_in_buffer);

/* Numbero of errors uncorrected by the Reed_solomon Code*/
int NER (double Overlap, double SNR, double SINR);

/* End of Header Block */

#if !defined (VOSD_NO_FIN)
#undef	BIN
#undef	BOUT
#define	BIN		FIN_LOCAL_FIELD(_op_last_line_passed) = __LINE__ - _op_block_origin;
#define	BOUT	BIN
#define	BINIT	FIN_LOCAL_FIELD(_op_last_line_passed) = 0; _op_block_origin = __LINE__;
#else
#define	BINIT
#endif /* #if !defined (VOSD_NO_FIN) */



/* State variable definitions */
typedef struct
	{
	/* Internal state tracking for FSM */
	FSM_SYS_STATE
	/* State Variables */
	Objid	                  		my_objid                                        ;	/* ID of the current module */
	Objid	                  		my_node_objid                                   ;	/* ID of the current node */
	int	                    		intrpt_type                                     ;	/* type of the current interruption */
	int	                    		intrpt_stream                                   ;	/* stream of the current interruption */
	int	                    		intrpt_code                                     ;	/* code of the current interruption */
	List *	                 		channel_pkt_queue                               ;	/* queue for the received packet */
	Boolean	                		DEBUG_Channel                                   ;
	Stathandle	             		buffer_size_handle                              ;
	int	                    		buffer_size_pkts                                ;
	int	                    		channel_pkt_forwarded                           ;
	int	                    		channel_pkt_accepted                            ;
	int	                    		channel_pkt_not_accepted                        ;
	int	                    		N_occupied_slots                                ;
	double	                 		last_time_inc_N_occ                             ;
	int	                    		N_occupied_slots_PSMA                           ;
	Boolean	                		capture_effect_enabled                          ;
	int	                    		useful_slots                                    ;
	int	                    		busy_slots                                      ;
	int	                    		idle_slots                                      ;
	double	                 		last_busy_timestamp                             ;
	Boolean	                		psma_enabled                                    ;
	Boolean	                		s_aloha_enabled                                 ;
	Boolean	                		awgn_enabled                                    ;
	Boolean	                		nakagami_enabled                                ;
	} lr_wpan_channel_PSMA_GADGET_state;

#define my_objid                		op_sv_ptr->my_objid
#define my_node_objid           		op_sv_ptr->my_node_objid
#define intrpt_type             		op_sv_ptr->intrpt_type
#define intrpt_stream           		op_sv_ptr->intrpt_stream
#define intrpt_code             		op_sv_ptr->intrpt_code
#define channel_pkt_queue       		op_sv_ptr->channel_pkt_queue
#define DEBUG_Channel           		op_sv_ptr->DEBUG_Channel
#define buffer_size_handle      		op_sv_ptr->buffer_size_handle
#define buffer_size_pkts        		op_sv_ptr->buffer_size_pkts
#define channel_pkt_forwarded   		op_sv_ptr->channel_pkt_forwarded
#define channel_pkt_accepted    		op_sv_ptr->channel_pkt_accepted
#define channel_pkt_not_accepted		op_sv_ptr->channel_pkt_not_accepted
#define N_occupied_slots        		op_sv_ptr->N_occupied_slots
#define last_time_inc_N_occ     		op_sv_ptr->last_time_inc_N_occ
#define N_occupied_slots_PSMA   		op_sv_ptr->N_occupied_slots_PSMA
#define capture_effect_enabled  		op_sv_ptr->capture_effect_enabled
#define useful_slots            		op_sv_ptr->useful_slots
#define busy_slots              		op_sv_ptr->busy_slots
#define idle_slots              		op_sv_ptr->idle_slots
#define last_busy_timestamp     		op_sv_ptr->last_busy_timestamp
#define psma_enabled            		op_sv_ptr->psma_enabled
#define s_aloha_enabled         		op_sv_ptr->s_aloha_enabled
#define awgn_enabled            		op_sv_ptr->awgn_enabled
#define nakagami_enabled        		op_sv_ptr->nakagami_enabled

/* These macro definitions will define a local variable called	*/
/* "op_sv_ptr" in each function containing a FIN statement.	*/
/* This variable points to the state variable data structure,	*/
/* and can be used from a C debugger to display their values.	*/
#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE
#define FIN_PREAMBLE_DEC	lr_wpan_channel_PSMA_GADGET_state *op_sv_ptr;
#define FIN_PREAMBLE_CODE	\
		op_sv_ptr = ((lr_wpan_channel_PSMA_GADGET_state *)(OP_SIM_CONTEXT_PTR->_op_mod_state_ptr));


/* Function Block */

#if !defined (VOSD_NO_FIN)
enum { _op_block_origin = __LINE__ + 2};
#endif

/*
 * Function:	lr_wpan_chan_error
 *
 * Descritpion: print error message and end the simulation
 *
 * ParamIn:		const char * fcnt
 *				name of the function
 *
 *				const char * msg
 *				error message to print
 *
 *				const char * opt
 *				optional error message to print
 *
 */

static void 
lr_wpan_chan_error (const char * fcnt, const char * msg, const char * opt)
{
	FIN (static void lr_wpan_mac_error (fcnt, msg, opt));
	
	/* print error message and end the simulation */
	op_sim_end ("LR WPAN Channel:", fcnt, msg, opt);
	
	FOUT;
}


/*
 * Function:	wpan_channel_init
 *
 * Description:	initialization the channel node
 *
 * No parameter
 */

static void 
wpan_channel_init (void)
{
	Objid cca_param_comp_objid;
	Objid cca_param_objid;
	Objid rem_node_objid;

	
	FIN (wpan_channel_init ());
	
	/* initialize the pointer to the channel buffer */
	channel_buffer_ptr = NULL;
	
	/* record the channel node id */
	wpan_channel_objid = my_objid;
	
	/* init the channel queue */
	channel_pkt_queue = op_prg_list_create ();
	
	/* get the WPAN Parameters Object ID */
	op_ima_obj_attr_get (my_objid, "CCA Parameters", &cca_param_comp_objid);
	cca_param_objid = op_topo_child (cca_param_comp_objid, OPC_OBJTYPE_GENERIC, 0);
	
	/* get the WPAN CCA mode */
	op_ima_obj_attr_get (cca_param_objid, "WPAN node", &wpan_cca_all_pkt_types);
	op_ima_obj_attr_get (cca_param_objid, "WLAN node", &wlan_cca_all_pkt_types);
	
	
	/*Debug flag */
	op_ima_obj_attr_get (my_objid, "DEBUG_CHANNEL", &DEBUG_Channel);
	
	op_ima_obj_attr_get (my_objid, "Capture_effect_enabled", &capture_effect_enabled);
	
	
	buffer_size_pkts = 0;
	buffer_size_handle = op_stat_reg ("channel.Buffer Size (pkts)", OPC_STAT_INDEX_NONE, OPC_STAT_LOCAL);
	
	channel_pkt_forwarded = 0;
	channel_pkt_accepted = 0;
	channel_pkt_not_accepted = 0;
	N_occupied_slots = 0;
	N_occupied_slots_PSMA = 0;
	last_time_inc_N_occ = 0.0;
	
	if(DEBUG_Channel)
		fp_channel_debug = fopen (pippo, "a");
		
	
	/* print informations */
	printf ("\n+--------------------------------------------------------------\n");
	printf ("| Channel Information:\n");
	printf ("| \tWPAN CCA mode: %s\n", wpan_cca_all_pkt_types ? "All packet types checked" : "Only WPAN packets checked");
	printf ("+--------------------------------------------------------------\n");
	
	
	
	/* determine the object ID of the desired remote queue 
		Id starting at the top level pointing to the MAC of the coordinator */
	rem_node_objid = op_id_from_hierarchical_name ("Office Network.coordinator.MAC");
	//printf("Coordinator Object ID: %d\n", (int)rem_node_objid);


	/*MAC protocol*/
	op_ima_obj_attr_get (rem_node_objid, "PSMA_Enabled", &psma_enabled);
	op_ima_obj_attr_get (rem_node_objid, "S_Aloha_Enabled", &s_aloha_enabled);
	printf("Used protocol: PSMA %d, S_ALOHA %d\n", (int)psma_enabled, (int)s_aloha_enabled);
	
	/*Get channel Model*/
	op_ima_obj_attr_get (my_objid, "AWGN_Enabled", &awgn_enabled);
	op_ima_obj_attr_get (my_objid, "Nakagami_Enabled", &nakagami_enabled);
	
	if(awgn_enabled)
		{
		Channel = AWGN_15_4A;
		printf("WPAN_CHANNEL_INIT: AWGN channel selected!\n");
		}
	else if (nakagami_enabled)
		{
		Channel = NAKAGAMI_15_4A;
		printf("WPAN_CHANNEL_INIT: Nakagami channel selected!\n");
		}
	else
		printf("WPAN_CHANNEL_INIT: No Channel Model selected! Using CustomPPM Modulation Curve.\n");
	
	
	channel_usage_stat_init ();
	
	FOUT;
}


/*
 * Function:	lr_wpan_chan_buffer_insert
 *
 * Description:	insert the received packet into the channel buffer.
 *				All the packet we receive are linked with an ICI structure
 *				which contain the infoamtion about the packet type and
 *				the position of the nodes.
 *				The computation of the transmission delay and the
 *				propagation delay are made here with the information
 *				collected. We record all this information in a structure
 *				Buff_Info_Packet.
 *				Finally, we schedules remote interuptions for the destination
 *				and source nodes to keep track of the different delays. 
 *
 * No parameter
 */

static void 
lr_wpan_chan_buffer_insert (void)
{
	Packet * rcv_pkptr;
	Ici *	ici_ptr;
	Buff_Info_Packet * info_packet;
	double bit_rate;
	int dest_address, pos_index;
	Wpan_Node_Param * element;
	char format[64];
	
	
	FIN (lr_wpan_chan_buffer_insert ());
	
	/* get the received packet */
	if ((rcv_pkptr = op_pk_get (intrpt_stream)) == OPC_NIL)
		lr_wpan_chan_error ("lr_wpan_chan_buffer_insert", "No received packet", OPC_NIL);
		
	/* get the received ICI */
	if ((ici_ptr = op_pk_ici_get (rcv_pkptr)) == OPC_NIL)
		lr_wpan_chan_error ("lr_wpan_chan_buffer_insert", "No ICI associates with the current packet", OPC_NIL);
	
	if (ici_ptr == NULL || ici_ptr == OPC_NIL)
		printf ("lr_wpan_chan_buffer_insert: Invalid ICI\n");
	
	/* create the info packet cell */
	info_packet = create_info_packet_cell ();
	
	/* get information from the ici */
	if (op_ici_attr_get (ici_ptr, "txrx distance", &info_packet->txrx_distance) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "bit rate", &bit_rate) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "channel", &info_packet->frequency) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "power", &info_packet->power) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "packet type", &info_packet->packet_type) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "dest address", &dest_address) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "Tx x", &info_packet->tx_x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "Tx y", &info_packet->tx_y) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "Rx x", &info_packet->rx_x) == OPC_COMPCODE_FAILURE ||
		op_ici_attr_get (ici_ptr, "Rx y", &info_packet->rx_y) == OPC_COMPCODE_FAILURE)
		lr_wpan_chan_error ("lr_wpan_chan_buffer_insert", "cannot read the ICI attributes", OPC_NIL);
	
		//op_ici_attr_get (ici_ptr, "piconet number", &piconet_number) == OPC_COMPCODE_FAILURE)
		//lr_wpan_chan_error ("lr_wpan_chan_buffer_insert", "cannot read the ICI attributes", OPC_NIL);
	
	/* get the packet format */
	op_pk_format (rcv_pkptr, format);
	
	/* 
	 * destroy the ICI pointer if the packet comes from a WLAN
	 * or is a WPAN acknolegement.
	 * If the packet is a WPAN data, the ICI will be destroyed
	 * with the copy of the packet used for the retransmission
	 */
	if (strcmp (format, "lr_wpan_mac"))
		op_ici_destroy (ici_ptr);
	
	/* a priori, the packet is valid until the opposite statment is made */
	if (info_packet->packet_type == WPAN_PKT_TYPE)
		{
		info_packet->noise = OPC_FALSE;  //if(!accept || noise) packet is discarded at rx (MAC function lower_layer_pkt_received)
		}
	/* get the size of the packet */
	info_packet->packet_size = (int) op_pk_total_size_get (rcv_pkptr);
	
	//if(DEBUG_Channel) printf("CHANNEL  MODULE: buffer insert function\n");
	
	/* compute the propagation delay */
	info_packet->prop_delay =  info_packet->txrx_distance / LIGHT_SPEED;
	
	
	//if(DEBUG_Channel) printf("CHANNEL MODULE: Tx-Rx distance = %f m\n", info_packet->txrx_distance);
	//if(DEBUG_Channel) printf("CHANNEL MODULE: Propagation delay = %f sec\n", info_packet->prop_delay);
	
	/* compute the transmission delay */
	if (info_packet->packet_type == WLAN_PKT_TYPE)info_packet->tx_delay = info_packet->packet_size / bit_rate;
	 else if (info_packet->packet_type == WPAN_PKT_TYPE)info_packet->tx_delay = (info_packet->packet_size + (double) LR_WPAN_PHY_OVERHEAD) / bit_rate;
	
	//if(DEBUG_Channel) printf("CHANNEL MODULE: Transmission delay = %f sec\n", info_packet->tx_delay);
	
	/*search the information about the destination module in the list of nodes */

	pos_index = wpan_search_mac_address (dest_address);
	/* get the information */
	element = (Wpan_Node_Param *) op_prg_list_access (wpan_node_param_list, pos_index);
	
		
	/* complete the info packet pointer */
	info_packet->packet_id		= op_pk_id (rcv_pkptr);
	info_packet->tx_time		= op_sim_time ();
	info_packet->delivery_time	= op_sim_time () + info_packet->prop_delay + info_packet->tx_delay; 
	
	info_packet->dest_objid		= element->objid;
	info_packet->src_objid		= op_intrpt_source ();
	
	/* if the packet is a wlan packet, we update the WLAN flags */
	if (wlan_cca_all_pkt_types || info_packet->packet_type == WLAN_PKT_TYPE)
		{
		/* update the transmission flag */
		wlan_flag_transmission (info_packet);
		}
	
	if (wpan_cca_all_pkt_types || info_packet->packet_type == WPAN_PKT_TYPE)
		{
		/* update the transmission flag of the WPAN devices */
		wpan_flag_cca (info_packet);
		}
	 //if(DEBUG_Channel) printf("CHANNEL MODULE: Remote int scheduled at %f sec\n", op_sim_time () + info_packet->prop_delay);
	/* Send some remote interruption according to the packet type */
	if (info_packet->packet_type == WPAN_PKT_TYPE)
		{
		
		/* if the packet is a WPAN, send an interuption to the destination node to start the reception */
		op_intrpt_schedule_remote (op_sim_time () + info_packet->prop_delay, WPAN_RX_START, info_packet->dest_objid);
		
		}
	else if (info_packet->packet_type == WLAN_PKT_TYPE)
		{
		/* if the packet is a WLAN, send an interuption to the source module to idle the transmission */
		op_intrpt_schedule_remote (op_sim_time () + info_packet->tx_delay, 0, info_packet->src_objid);
		}
	
	/* schedule the interuption to send the packet to its destination */
	op_intrpt_schedule_self (info_packet->delivery_time, PKT_DELIVERY_CODE);

	/* insert the packet into the buffer */
	channel_buffer_register_packet (info_packet);
	
	buffer_size_pkts++;
	op_stat_write(buffer_size_handle, buffer_size_pkts);
	
	if (!strcmp (format, "lr_wpan_mac"))
		{
		channel_pkt_forwarded++;
		
		//if(op_sim_time() != last_time_inc_N_occ )
		if(op_sim_time() >= last_time_inc_N_occ + 0.00083)
			{
			N_occupied_slots++;
			last_time_inc_N_occ = op_sim_time();
			
			if (info_packet->nb_collisions == 1) //the packet has no collision
				N_occupied_slots_PSMA = N_occupied_slots_PSMA + 2;
				
			else N_occupied_slots_PSMA++;
				
			}
		}
	
	/* insert the packet into the queue */
	op_prg_list_insert (channel_pkt_queue, rcv_pkptr, OPC_LISTPOS_TAIL);
	
	/* debug informations */
	if (ODB_CHANNEL_BUFFER)
		{
		printf ("\n+---------------------------------------------\n");
		printf ("| Channel buffer: %.12f s\n|\tpropagation delay: %.12f s\n", op_sim_time (), info_packet->prop_delay);
		printf ("|\ttransmission delay: %.9f s\n|\tdelivery time: %.12f s\n", info_packet->tx_delay, info_packet->delivery_time);
		printf ("+---------------------------------------------\n");
		}
	
	//if(DEBUG_Channel) printf("CHANNEL MODULE: inserted packet in channel buffer\n");
		
	FOUT;
}


/*
 * Function:	channel_queue_search_pkt
 *
 * Description:	search a packet in the channel queue, according
 *				to the packet ID in parameter and return the
 *				index of this packet in the list if it exists,
 *				otherwise return -1
 *
 * ParamIn:		OpT_Packet_Id pkt_id
 *				ID of the packet to search
 *
 * ParamOut:	int pos_index
 *				position index of the element
 */

static int 
channel_queue_search_pkt (OpT_Packet_Id pkt_id)
{
	int i, pos_index = -1;
	Packet * element;
	int nbElement; // = op_prg_list_size (channel_pkt_queue);
	
	
	FIN (channel_queue_search_pkt (pkt_id));
	
	nbElement = op_prg_list_size (channel_pkt_queue);
	
	/* chack if the list is not null */
	if (!nbElement)
		lr_wpan_chan_error ("channel_queue_search_pkt:", "No packet registered.", OPC_NIL);

	/* search the element in the list of nodes */
	for (i = 0; i < nbElement; i++)
		{
		/* access the element */
		element = op_prg_list_access (channel_pkt_queue, i);
		
		/* check the MAC address*/
		if (op_pk_id(element) == pkt_id)
			pos_index = i;
		}
		
	FRET (pos_index);
}


/*
 * Function:	lr_wpan_channel_pk_send
 */

static void 
lr_wpan_channel_pk_send (void)
{
	Buff_Info_Packet * info_packet;
	Packet * pkptr;
	//Frame_Ctrl_Field * ctrl_field_ptr;
	char format[64];
	int pos_index;
	int accept;
	
	FIN (lr_wpan_channel_pk_send ());
	
	//if(DEBUG_Channel) printf("CHANNEL MODULE: Forward function\n");
	
	/* get the information of the packet to send */
	info_packet = search_pkt_info_for_delivery ();
	
	/* get the packet according to the information cell */
	if ((pos_index = channel_queue_search_pkt (info_packet->packet_id)) == -1)
		lr_wpan_chan_error ("lr_wpan_channel_pk_send:", "No packet found in the queue.", OPC_NIL);
	
	/* remove the packet from the channel queue */
	if ((pkptr = op_prg_list_remove (channel_pkt_queue, pos_index)) == OPC_NIL)
		lr_wpan_chan_error ("lr_wpan_channel_pk_send:", "Cannot remove packet from the queue.", OPC_NIL);
	
	/*
	ctrl_field_ptr = (Frame_Ctrl_Field *) op_prg_mem_alloc (sizeof (Frame_Ctrl_Field));
	op_pk_nfd_access(pkptr, "Frame Ctrl", &ctrl_field_ptr); 	
	
	
	if(DEBUG_Channel)printf("CHANNEL MODULE: Forward packet at time %f sec -- Pkt type: %d\n", op_sim_time(), ctrl_field_ptr->frame_type);
	*/
	
		
	/* compute the accept flag ONLY FOR DATA */
	op_pk_format(pkptr, format);
	
	//if (ctrl_field_ptr->frame_type == WPAN_Beacon) accept= 1;	
	if (!strcmp (format, "lr_wpan_beacon") || !strcmp (format, "lr_wpan_ack")) accept= 1;	
	 else accept = compute_accept_flag (info_packet);

	/* set the accept flag */
	op_pk_nfd_set (pkptr, "Accept", accept);
	
	/* Set the noise flag */
	if (info_packet->packet_type == WPAN_PKT_TYPE)
		{
		op_pk_nfd_set (pkptr, "Noise", info_packet->noise);
		}
		
	if (info_packet->packet_type == WPAN_PKT_TYPE)
		{	
		/* send the packet to its destination */
		op_pk_deliver (pkptr, info_packet->dest_objid, 1);
		}
	else
		{
		 op_pk_deliver (pkptr, info_packet->dest_objid, 0);	
		 }
	
	if(DEBUG_Channel) 
		{
		fprintf(fp_channel_debug, "Forward packet at time %f sec\n", op_sim_time());
		fprintf (fp_channel_debug, "\n+--------------------------------------------------------------\n");
		fprintf (fp_channel_debug, "| Packet %d, %.0f MHz\n", (int) info_packet->packet_id, info_packet->frequency); 
		fprintf (fp_channel_debug, "| Source id %d\n", (int) info_packet->src_objid); 
		fprintf (fp_channel_debug, "| delivery time: %.12f s\n", info_packet->delivery_time);
		fprintf (fp_channel_debug, "| Nb of collision(s): %d\n", info_packet->nb_collisions);
		fprintf (fp_channel_debug, "+--------------------------------------------------------------\n");
		}
	
	/* remove the packet from the queue */
	channel_buffer_remove_packet (info_packet);
	
	
	//write statistics
	buffer_size_pkts--;
	op_stat_write(buffer_size_handle, buffer_size_pkts);
	
	if (!strcmp (format, "lr_wpan_mac"))
		{
				
		if (accept == 1) 	channel_pkt_accepted++;
		else 			channel_pkt_not_accepted++;
		}
	
	
	
	//op_prg_mem_free (ctrl_field_ptr);

	FOUT;
}



/*
 * Function:	compute_accept_flag
 *
 * Description	
 */

static int compute_accept_flag (Buff_Info_Packet * info_packet)
{	
	double ber = 0.0, pmd = 0.0, snr = 0.0, snr_i=0.0, snr_lin = 0.0, snr_i_lin= 0.0, SINR=0.0, SINR_dB=0.0;
	double power_packet_w, power_packet_interferer_w;
	double distance_interferer, distance_transmitter, delta_x, delta_y, delta_dist;
	double delta_delay, overlap;
	double int_window = 32.05e-9;

	Buff_Info_Packet * info_packet_interferer = info_packet->next_collision;
	
	int packet_size = (int) info_packet->packet_size;
	int Errors, correct ;
	
			
	FIN (compute_accept_flag (info_packet));
	
	//Buff_Info_Packet * info_packet_interferer = info_packet->next_collision;
	
	/* compute snr*/
	delta_x = info_packet->rx_x - info_packet->tx_x;
	delta_y = info_packet->rx_y - info_packet->tx_y;
	distance_transmitter = sqrt (delta_x * delta_x + delta_y * delta_y);
		
	power_packet_w = info_packet->power;
	
	//It gives the SNR in dB, without implementation loss
	//snr = snr_15_4a (info_packet->frequency, power_packet_w, distance_transmitter);
	//With imolementation loss
	snr = snr_15_4a (info_packet->frequency, power_packet_w, distance_transmitter) - IMPLEMENTATION_LOSS; //power is in mW, return in dB
		
		
	//to compute average snr
	accumulate_snr = accumulate_snr + snr;
	channel_buff_global_packet_count++;
		
		
	//compute min and max snr
	if(snr > max_snr)
		max_snr = snr;
	if(snr < min_snr)
		min_snr = snr;
	
	/* check the number of collisions with the packet */
	if (info_packet->nb_collisions == 1) //the packet has no collision, compute miss-detection and ber 
		{
		
		if (capture_effect_enabled == OPC_FALSE)
		 {
			if (awgn_enabled || nakagami_enabled) //AWGN or Nakagami enabled, check Pmd, ber and fec
				{
				/*compute pmd*/
				pmd = Pmd_802_15_4a(snr);
					
				if (op_dist_uniform (1.0) < pmd)
					{
					/* if random value is lower than pmd , the packet is missed*/
					channel_usage_stat(0);
					FRET (0);
					}
				
				ber= bit_error_rate_802_15_4a(snr, Channel);
				correct = fec (ber, packet_size);
		
				}
			else{	// no channel model used, ideal channel
				correct = 1;
				
				}
			
			channel_usage_stat(correct);
			FRET(correct);
		 }
		else
		 {
		
		/*compute pmd*/
		pmd = Pmd_802_15_4a(snr);
					
		if (op_dist_uniform (1.0) < pmd)
			{
			/* if random value is lower than pmd , the packet is missed*/
			channel_usage_stat(0);
			FRET (0);
			}
		
		/* compute the BER */
		if (awgn_enabled || nakagami_enabled)
			ber= bit_error_rate_802_15_4a(snr, Channel);
		else
			ber= bit_error_rate_802_15_4(snr);
						
		/*check if the fec can correct the errors in the packet*/
		correct = fec (ber, packet_size);
		channel_usage_stat(correct);
		//printf("Compute Accept: distance = %f, SNR = %f, BER = %f, FRET(FEC) = %d\n", distance_transmitter, snr, ber, correct);
		FRET(correct);
		
		 }
		
		
		
		}
	
		
	else	
		if((info_packet->nb_collisions == 2)&&(capture_effect_enabled == OPC_TRUE))	//one collision && capture effect enabled
			
	   			{  
	         	/* compute the distance beetween the interferer and the receiver*/
				delta_x = info_packet->rx_x - info_packet_interferer->tx_x;
				delta_y = info_packet->rx_y - info_packet_interferer->tx_y;
				distance_interferer = sqrt (delta_x * delta_x + delta_y * delta_y);
				
				power_packet_interferer_w = info_packet_interferer->power;
				
				//SNR of the interfering packet
				snr_i =snr_15_4a (info_packet_interferer->frequency, power_packet_interferer_w, distance_interferer);
				
				if(snr_i > snr) 
					{
						channel_usage_stat(info_packet->nb_collisions);
						FRET(0);
					}
				
				else
					{
					/*compute relative distance*/
					if(distance_transmitter <= distance_interferer) 
						delta_dist= distance_interferer - distance_transmitter;
					else 
						delta_dist = distance_transmitter - distance_interferer;
					
					delta_delay = delta_dist/ LIGHT_SPEED;
					
					/*compare delta delay with int_window: if the delay is equal or greater than the Int.Window compute miss detection and ber*/
					if(delta_delay >= int_window)
						{
						//compute pmd
						pmd = Pmd_802_15_4a(snr);
						if (op_dist_uniform (1.0) < pmd)
							{
							// if random value is lower than pmd , the packet is missed
							channel_usage_stat(0);
							FRET (0);			
							}
						
						// compute the BER
						if (awgn_enabled || nakagami_enabled)
							ber= bit_error_rate_802_15_4a(snr, Channel);
						
						else
							ber= bit_error_rate_802_15_4(snr);
						
						//check if the fec can correct the errors in the packet
						correct = fec (ber, packet_size);
						channel_usage_stat(correct);
						//printf("Single Packet Collision, BER = %f, FRET(FEC) = %d\n", ber, correct);
						FRET(correct);
						}
					
					else
						{        
						/*compute the percentage of overlapping in the int.window*/
						overlap = (delta_delay * 100)/int_window;
						count_in++;
						
						//conversion to linear
						snr_lin = util_inverse_dB(snr);		
						snr_i_lin = util_inverse_dB(snr_i);
						//signal to noise and interference ratio
						SINR = snr_lin /( snr_i_lin + 1); 
						SINR_dB = util_dB(SINR);
						
						/* evaluate the number of uncorrected errors*/
						Errors = NER (overlap, snr, SINR_dB);
						
						if (Errors !=0)  //an error occurred in the packet, so it is not accepted 
							{	                 	
							op_prg_odb_bkpt ("collision");
							channel_usage_stat(info_packet->nb_collisions);
							FRET (0);
							}
						else 
							{
							channel_usage_stat(1);
							FRET (1);
							count_out++;
							}
						}
					}
				}
				
				
		else 
		 {
		 	channel_usage_stat(info_packet->nb_collisions);
			FRET(0);	//more than one collision or capture effect disabled
		 }
}

						 

/*
 * Function:	fec
 *
 * Description	
 */

static int fec (double ber, int packet_size)
{	int i, j; // loop variable
	int Nsegments, Nerr ;
	int segment_size = 330;
	int max_error = 4;
	int last_segment_size, max_error_last_segment;
	
		
	FIN (fec (ber, packet_size));
	/*compute the error in the packet : RS FEC: 4 errors corrected every 330 bits.*/
	Nsegments = packet_size/segment_size;
			
	last_segment_size = packet_size - Nsegments*segment_size;
	max_error_last_segment = floor((last_segment_size*max_error)/segment_size);
		
	if(DEBUG_Channel) 
		fprintf(fp_channel_debug, "packet_size = %d -- segment_size = %d -- Nsegments = %d -- last_segment_size = %d -- max_error_last_segment = %d\n", packet_size, segment_size, Nsegments, last_segment_size, max_error_last_segment);
		
	for(j=0; j<Nsegments; j++)
		{
		Nerr=0;
		for (i=0; i<segment_size; i++)
			if (op_dist_uniform (1.0) < ber)						Nerr++;
		
		if (Nerr>max_error) FRET (0);
		}
	
	Nerr=0;
	for (i=0; i<last_segment_size; i++)
		if (op_dist_uniform (1.0) < ber)	 Nerr++;
	
	if (Nerr>max_error_last_segment) 	FRET (0);						
	
	FRET (1);
}


/*
 * Function:	wlan_flag_transmission
 *
 * Description:	
 */

static void 
wlan_flag_transmission (const Buff_Info_Packet * info_packet)
{	
	Ici * wlan_rx, *wlan_rx_beginning, *wlan_rx_end;
	int nb_wlan,i;
	Wpan_Node_Param * element;
	double prop_delay;
	double delivery_time;
	
	FIN (wlan_idle_transmission (info_packet));

	
	/* check the information cell */
	if (info_packet->delivery_time	== 0.0 ||
		info_packet->prop_delay		== 0.0 ||
		info_packet->tx_delay		== 0.0 ||
		info_packet->dest_objid		== 0 ||
		info_packet->src_objid		== 0)
		op_sim_message ("FUNCTION WARNING: \"wlan_flag_transmission\" of the LR WPAN Channel", "Some informations of the cell are set to the default value.");
   
	
	if (info_packet->packet_type == WLAN_PKT_TYPE)
		{
		/* check the information cell */
		if (info_packet == NULL)
			lr_wpan_chan_error ("wpan_update_wlan_flag:", "No packet information found.", OPC_NIL);
	
		/* get the number of WLAN in the topology */
		nb_wlan = wpan_list_size_get_wlan_node ();
		
		/* For each WLAN, we need to send an interuption */
		for (i = 0; i < nb_wlan; i++)
			{
			/* get the WLAN device */
			element = wpan_search_wlan_node (i);
			//printf(" device %d, packet %d,\n", element->objid, info_packet->dest_objid );
			
			if( element->objid == info_packet->dest_objid)
				{
				/* 
				* We create an ICI to send the packet delivery time to the wlan receiver
				* in order to update the "rx_end_time" field of the MAC layer 
				*/
				wlan_rx = (Ici *) op_ici_create ("ici_wlan_rx_end");
		
				if (op_ici_attr_set_int32 (wlan_rx, "Packet Type", WLAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
					op_ici_attr_set_dbl (wlan_rx, "End of Transmission", info_packet->delivery_time) == OPC_COMPCODE_FAILURE)
					lr_wpan_chan_error ("wlan_flag_transmission:", "Unable to set the ICI.", OPC_NIL);
		
				/* install the ici with the first interruption */
				op_ici_install (wlan_rx);
		
				/* send an interuption to the destination module to update the power transmission */
				op_intrpt_schedule_remote (op_sim_time () + info_packet->prop_delay, 0, info_packet->dest_objid);
	
				/* Deinstall the ici mechanism */
				op_ici_install (OPC_NIL);
				}
			else
				{
				if ((element->parent_id != op_topo_parent(info_packet->src_objid))&&(element->frequency == info_packet->frequency))
					{
					/* compute the propagation delay */
					prop_delay = sqrt((info_packet->tx_x - element->x)*(info_packet->tx_x - element->x) + 
						(info_packet->tx_y - element->y)*(info_packet->tx_y - element->y)) / LIGHT_SPEED;
		
					/* compute the delivery time */
					delivery_time = info_packet->delivery_time - info_packet->prop_delay + prop_delay;
					
					/* 
					* We create an ICI to send the packet delivery time to the wlan receiver
					* in order to update the "rx_end_time" field of the MAC layer 
					*/
					wlan_rx_beginning = (Ici *) op_ici_create ("ici_wlan_rx_end");
					
					if (op_ici_attr_set_int32 (wlan_rx_beginning, "Packet Type", WLAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
						op_ici_attr_set_dbl (wlan_rx_beginning, "End of Transmission", delivery_time) == OPC_COMPCODE_FAILURE)
						lr_wpan_chan_error ("wpan_update_wlan_flag:", "Unable to set the ICI.", OPC_NIL);
		
					/* install the ici with the first interruption */ 
					op_ici_install (wlan_rx_beginning);
		
					/* send an interuption to the destination module to update the power transmission */
					op_intrpt_schedule_remote (op_sim_time () + prop_delay, 0, element->objid);
					
					/* Deinstall the ici mechanism */
					op_ici_install (OPC_NIL);
					
					wlan_rx_end = (Ici *) op_ici_create ("ici_wlan_rx_end");
					
					if (op_ici_attr_set_int32 (wlan_rx_end, "Packet Type", WLAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
						op_ici_attr_set_dbl (wlan_rx_end, "End of Transmission", delivery_time) == OPC_COMPCODE_FAILURE ||
						op_ici_attr_set_dbl (wlan_rx_end, "Packet Size", info_packet->packet_size) == OPC_COMPCODE_FAILURE )
						lr_wpan_chan_error ("wpan_update_wlan_flag:", "Unable to set the ICI.", OPC_NIL);
		
					/* install the ici with the first interruption */ 
					op_ici_install (wlan_rx_end);
					
					op_intrpt_schedule_remote (delivery_time, 1, element->objid);
					
					op_ici_install (OPC_NIL);
					
					}
				}
			}	
		
		}
	else
		{
		/* if the packet is from a WPAN, we have to send a power transmission in each WLAN device */
		wpan_update_wlan_flag (info_packet);
		}
	
	FOUT;
}



/*
 * Function:	wpan_update_wlan_flag
 *
 * Description:	send a power transmission to all WLAN devices
 *				if a WPAN send a packet and the CCA of the WLAN
 *				detects all packet type
 */

static void
wpan_update_wlan_flag (const Buff_Info_Packet * info_packet)
{
	Ici * wlan_rx;
	int nb_wlan;
	int i; // loop variable
	Wpan_Node_Param * element;
	double prop_delay;
	double delivery_time;
	
	FIN (wpan_update_wlan_flag (info_packet));
	
	/* check the information cell */
	if (info_packet == NULL)
		lr_wpan_chan_error ("wpan_update_wlan_flag:", "No packet information found.", OPC_NIL);
	
	/* get the number of WLAN in the topology */
	nb_wlan = wpan_list_size_get_wlan_node ();
		
	/* For each WLAN, we need to send an interuption */
	for (i = 0; i < nb_wlan; i++)
		{
		/* get the WLAN device */
		element = wpan_search_wlan_node (i);
		
		/* compute the propagation delay */
		prop_delay = sqrt((info_packet->tx_x - element->x)*(info_packet->tx_x - element->x) + 
			(info_packet->tx_y - element->y)*(info_packet->tx_y - element->y)) / LIGHT_SPEED;
		
		/* compute the delivery time */
		delivery_time = info_packet->delivery_time - info_packet->prop_delay + prop_delay;
		
		/* 
		* We create an ICI to send the packet delivery time to the wlan receiver
		* in order to update the "rx_end_time" field of the MAC layer 
		*/
		wlan_rx = (Ici *) op_ici_create ("ici_wlan_rx_end");
		
		if (op_ici_attr_set_int32 (wlan_rx, "Packet Type", WPAN_PKT_TYPE) == OPC_COMPCODE_FAILURE ||
			op_ici_attr_set_dbl (wlan_rx, "End of Transmission", delivery_time) == OPC_COMPCODE_FAILURE)
			lr_wpan_chan_error ("wpan_update_wlan_flag:", "Unable to set the ICI.", OPC_NIL);
		
		/* install the ici with the first interruption */
		op_ici_install (wlan_rx);
		
		/* send an interuption to the destination module to update the power transmission */
		op_intrpt_schedule_remote (op_sim_time () + prop_delay, 0, element->objid);
			
		/* Deinstall the ici mechanism */
		op_ici_install (OPC_NIL);
		}
		
	FOUT;
}


/*
 * Function:	wpan_flag_transmission
 *
 * Description:	
 */

static void
wpan_flag_cca (const Buff_Info_Packet * info_packet)
{
	Wpan_Node_Param * element;
	int list_size = op_prg_list_size (wpan_node_param_list);
	int i; // loop variable
	double distance;
	double prop_delay;
	double deltaX, deltaY, deltaXsquare, deltaYsquare;
	
	FIN (wpan_flag_cca (info_packet));
	
	//if(DEBUG_Channel) printf("CCA flag enter\n");
	
	/* check the information cell */
	if (info_packet->tx_x == 0.0 ||
		info_packet->tx_y == 0.0)
		op_sim_message ("FUNCTION WARNING: \"wpan_flag_cca\" of the LR WPAN Channel", "Some informations of the cell are set to the default value.");
	
	//if(DEBUG_Channel) printf("CHANNEL MODULE: CCA schedule remote, test coord. x %f\n", info_packet->tx_x);
	//if(DEBUG_Channel) printf("CHANNEL MODULE: CCA schedule remote, test coord. y %f\n", info_packet->tx_y);
	
	/*
	 * We check all the node list to know whether we need
	 * to send an interuption for the CCA
	 */
	for (i=0; i<list_size; i++)
		{
		/* get the element in the node list */
		element = op_prg_list_access (wpan_node_param_list, i);
		/* if the node asks for a CCA */
		// equality of frequencies depends on detection mechanism
		//if ((element->cca_requirement) && (element->frequency_wpan == info_packet->frequency))
		if ((element->cca_requirement))	
			{
			//if(DEBUG_Channel) printf("X: %f, Y: %f\n", element->x, element->y);
			
			deltaX = info_packet->tx_x - element->x;
			deltaY = info_packet->tx_y - element->y;
			
			deltaXsquare = deltaX*deltaX;
			deltaYsquare = deltaY*deltaY;
			
			/* compute the distance between the two nodes */
			distance = sqrt(deltaXsquare + deltaYsquare);
			//distance = sqrt((info_packet->tx_x - element->x)*(info_packet->tx_x - element->x) + (info_packet->tx_y - element->y)*(info_packet->tx_y - element->y));		
			
			/* compute the propagation delay */
			prop_delay = distance/LIGHT_SPEED;
				
			/* schedule an event for the CCA period */
			op_intrpt_schedule_remote (op_sim_time () + prop_delay, WPAN_CCA_CODE, element->objid);
			//if(DEBUG_Channel) printf("CCA flag exit\n");
			}
		}
		
	
	FOUT
}


 /* Function:	NER
 *
 * Description:	number of uncorrected errors
 */

int NER (double Overlap, double SNR, double SINR)
{
  int NER;
  int SINR_q , SNR_q ,overlap_q;
  int index;
 
  FIN (NER (Overlap, SNR, SINR));
 
                       overlap_q = ((int)(Overlap/5))-5 ; //the first column of the matrix refers to overlap=25% (spaced 5%)
                       SINR_q= (int)SINR -1;//the first square of the matrix refers to SINR=0dB
                       SNR_q= (int)SNR -18; //the rows of the matrix refers to SNR 18 to 40 (spaced 1)
					 
                        /*conversion to address the right element of the array MATRIX*/
  
  /*if overlap <25% we assume 0 errors because SNR is 18-40dB . Furthermore SINR > 10dB yields to an error .the check on SNR >40db is only to avoid errors , since it is never reached*/
  if(SINR > 10) NER=0;
  else if (SNR>40 || Overlap<25 ) {NER = 0;}
	   else { if (SNR<18) NER = 100;
              else {
			 index = (int)((23*16)*SINR_q+SNR_q*16+overlap_q);
		     NER = (int) MATRIX[index];	     
	   }
			  }
  
  FRET (NER);
}

/*
 * Function:	channel_collect_stat (coded by Flavia Martelli)
 *
 * Description:	collect data at the end of the simulation
 *				
 *				file created during this function:
 *	
 *				*  channel.txt
 *
 * No parameter
 */

static void channel_collect_stat ()
{
	FILE * fp;
	long int i;
	Boolean exist;
	
	time_t date;
	char date_str[32];
	
	char report_name[20] = "channel.txt";
	char report_name_m[20] = "channel_matlab.txt";
	
	
	//char traffic_name[20] = "_G_";
	char traffic_str_B[100];
	char traffic_str_U[100];
	char traffic_str_I[100];
	double traffic_value = 0.0;
	//double aBaseSlotDuration;
	
	FIN (channel_collect_stat ());
	
	// code to collect separate files with traffic rate as name.
	/* aBaseSlotDuration = (2*PROPAGATION_DELAY+2*LR_WPAN_PHY_OVERHEAD+WPAN_HEADER_SIZE+WPAN_PAYLOAD_MAX_SIZE+aTurnaroundTime+macAckWaitDuration+ACK+aMinLIFSPeriod)/LR_WPAN_BIT_RATE;
	traffic_value = ((int)channel_pkt_forwarded/op_sim_time ())*aBaseSlotDuration;
	sprintf (traffic_str_U, "%s%.2f%s", traffic_name, traffic_value, useful_name);
	sprintf (traffic_str_B, "%s%.2f%s", traffic_name, traffic_value, busy_name);
	sprintf (traffic_str_I, "%s%.2f%s", traffic_name, traffic_value, idle_name);
	*/
	
	
	sprintf (traffic_str_U, "%s", useful_name);
	sprintf (traffic_str_B, "%s", busy_name);
	sprintf (traffic_str_I, "%s", idle_name);
	
	
	
	/* open the report file */
	
	fp_useful = lr_wpan_open_report_file (traffic_str_U, &exist);
	fp_busy = lr_wpan_open_report_file (traffic_str_B, &exist);
	fp_idle = lr_wpan_open_report_file (traffic_str_I, &exist);
	
	
	
	
	/* get the date of the day */
	time (&date);
	sprintf (date_str, "%s", ctime (&date));
	

	/* open the report file */
	fp = lr_wpan_open_report_file (report_name, &exist);
	
	/* write a header in the file if it has been created now */
	if (!exist)
		{
		fprintf (fp, "\n\t*** Statistics gathered from the channel ***\n");
		fprintf (fp, "\tCreation date: %s\n", date_str);
		
		fprintf (fp, "Packets to channel\t Packet accepted\t Packet not accepted\t Occupied slots\t Occupied slots(PSMA)\t Simulation time\t Last modified date\n\n");
		}
	
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\t %s",
		integer_to_string ((int)channel_pkt_forwarded, 15),
		integer_to_string ((int)channel_pkt_accepted, 15),
		integer_to_string ((int)channel_pkt_not_accepted, 15),
		integer_to_string ((int)N_occupied_slots, 15),
		integer_to_string ((int)N_occupied_slots_PSMA, 15),
		double_to_string (op_sim_time (), strlen ("simulation time")),
		date_str);
		
	fclose (fp);
	
	
	/* cretae a  .txt file without headers, for Matlab postprocessing */
	
	
	/* open the report file */
	fp = lr_wpan_open_report_file (report_name_m, &exist);
	
	fprintf (fp, "%s\t %s\t %s\t %s\t %s\t %s\n",
		integer_to_string ((int)channel_pkt_forwarded, 15),
		integer_to_string ((int)channel_pkt_accepted, 15),
		integer_to_string ((int)channel_pkt_not_accepted, 15),
		integer_to_string ((int)N_occupied_slots, 15),
		integer_to_string ((int)N_occupied_slots_PSMA, 15),
		double_to_string (op_sim_time (), strlen ("simulation time")));
	
	fclose (fp);
	
	for(i=0;i<STAT_FILE_LENGTH;i++)
		{
		fprintf(fp_useful, "%d\t", useful_period[i]);
		fprintf(fp_busy, "%d\t", busy_period[i]);
		fprintf(fp_idle, "%d\t", idle_period[i]);
		}
	fprintf(fp_busy, "\n");
	fprintf(fp_idle, "\n");
	fclose (fp_busy);
	fclose (fp_idle);
	fprintf(fp_useful, "\n");
	fclose (fp_useful);
	
	
	FOUT;
}

static void channel_usage_stat_init ()
{	
	

	FIN (channel_usage_stat_init ());
	

	useful_slots = 0;
	if (psma_enabled) //initialise the first busy slot depending on the protocol to avoid zero length busy period in the first channel_usage_stat access
		busy_slots = 2; 
	else if (s_aloha_enabled)
		busy_slots = 1;
	else
		busy_slots = 0;
	idle_slots = 0;
	last_busy_timestamp = 0.0;
	
	
	
	FOUT;

}

static void channel_usage_stat (int pkt_in_buffer)
{

	double aBaseSlotDuration, temp2, aBackoffBoundary;
	long int temp;
	
	Objid rem_node_objid;

	FIN (channel_usage_stat (pkt_in_buffer));
	
	/* determine the object ID of the desired remote queue 
		Id starting at the top level pointing to the MAC of the coordinator */
	rem_node_objid = op_id_from_hierarchical_name ("Office Network.coordinator.MAC");
	//printf("Coordinator Object ID: %d\n", (int)rem_node_objid);


	/*MAC protocol*/
	op_ima_obj_attr_get (rem_node_objid, "PSMA_Enabled", &psma_enabled);
	op_ima_obj_attr_get (rem_node_objid, "S_Aloha_Enabled", &s_aloha_enabled);
	//printf("Used protocol: PSMA %d, S_ALOHA %d\n", (int)psma_enabled, (int)s_aloha_enabled);
	
	aBaseSlotDuration = (2*PROPAGATION_DELAY+2*LR_WPAN_PHY_OVERHEAD+WPAN_HEADER_SIZE+WPAN_PAYLOAD_MAX_SIZE+aTurnaroundTime+macAckWaitDuration+ACK+aMinLIFSPeriod)/LR_WPAN_BIT_RATE;
	if(s_aloha_enabled)		
		aBackoffBoundary = aBaseSlotDuration;
	else if(psma_enabled)		
		aBackoffBoundary = aBaseSlotDuration/2;
	else
		{
			printf("Unrecognised MAC protocol at lr_wpan_channel, function: channe_usage_stat\n");
			aBackoffBoundary = aBaseSlotDuration;
		}
		
	
	if (psma_enabled)
		{
		if ((op_sim_time()-last_busy_timestamp) > (aBaseSlotDuration+(aMinLIFSPeriod/LR_WPAN_BIT_RATE)))
			{
			temp2 = (((op_sim_time()-last_busy_timestamp)-aBaseSlotDuration)/aBackoffBoundary);
			if((temp2-floor(temp2)) < 0.5)
				temp = floor(temp2);
			else
				temp = ceil(temp2);
			if(temp > STAT_FILE_LENGTH)
				temp = STAT_FILE_LENGTH-1;
			if(temp == 0)
				//printf("Idle time zero at %f with last_busy %f, aBackoffBoundary = %f, temp = %d, round = %f\n", op_sim_time(), last_busy_timestamp, aBackoffBoundary, temp, (((op_sim_time()-last_busy_timestamp)-aBackoffBoundary)/aBackoffBoundary));
				idle_period[1]++;
			if(temp > 0)
				idle_period[temp]++;
			if(pkt_in_buffer == 1) //single packet in buffer
				{
		
				if(useful_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					useful_slots=STAT_FILE_LENGTH-1;
				
				if (useful_slots > 0) //if previous busy periods generated useful periods, record them.
					useful_period[useful_slots]++;

			
				useful_slots = 2; 	//reset useful to 2 new slots that have been just accumulated
				
				
				if(busy_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					busy_slots = STAT_FILE_LENGTH-1;
				
				busy_period[busy_slots]++; //collect the accumulated busy slots as there now was an idle period
				/*if (busy_slots == 0)
					printf("busy slots 0 after idle with 1 pkt in buffer at %f with last_busy %f\n", op_sim_time(), last_busy_timestamp);
				*/	
				busy_slots = 2; //reset busy slots to two, as there was an idle period
		
		
				}
			else //more than one packet in buffer
				{
				if(useful_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					useful_slots=STAT_FILE_LENGTH-1;
			
				if(useful_slots > 0) //if previous busy periods generated useful periods, record them.
					useful_period[useful_slots]++;
				
				useful_slots = 0; //A collision occurs now, hence reset useful slots
				
				if(busy_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					busy_slots = STAT_FILE_LENGTH-1;
			
				busy_period[busy_slots]++; //collect the accumulated busy slots as there now was an idle period
				/*if (busy_slots == 0)
					printf("busy slots 0 after idle with %d pkt in buffer at %f with last_busy %f\n", pkt_in_buffer, op_sim_time(), last_busy_timestamp);
				*/
				busy_slots = 2; //reset busy slots to two, as there was an idle period
			
		
				}
			}
		
		else //busy period continues
			{
			if(pkt_in_buffer == 1) //single packet in buffer
				{
			
				useful_slots += 2; //increment useful period by 2
				busy_slots += 2; //increment busy period by 2
				}

		
			else //more than one packet in buffer
				{
				if ((op_sim_time()-last_busy_timestamp) > (aMinLIFSPeriod/LR_WPAN_BIT_RATE)) //only the first function call in aBackoffBoundary updates busy 
				
					busy_slots += 2; //only busy period increased
				
				}
			}
		}
	
	else if(s_aloha_enabled)
		{
		if ((op_sim_time()-last_busy_timestamp) > (aBackoffBoundary+(aMinLIFSPeriod/LR_WPAN_BIT_RATE))) //last access more than 1 slot ago
			{
			temp2 = (((op_sim_time()-last_busy_timestamp)-aBackoffBoundary)/aBackoffBoundary); //record the idle duration in slots
			if((temp2-floor(temp2)) < 0.5) //round to integer
				temp = floor(temp2);
			else
				temp = ceil(temp2);
			if(temp > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
				temp = STAT_FILE_LENGTH-1;
			if(temp == 0)
				idle_period[1]++;
				//printf("Idle time zero at %f with last_busy %f, aBackoffBoundary = %f, temp = %d, round = %f\n", op_sim_time(), last_busy_timestamp, aBackoffBoundary, temp, (((op_sim_time()-last_busy_timestamp)-aBackoffBoundary)/aBackoffBoundary));
			if(temp > 0)
				idle_period[temp]++; //record idle duration
		
			if(pkt_in_buffer == 1) //one packet in buffer
				{
		
				if(useful_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
				useful_slots=STAT_FILE_LENGTH-1;
			
				if (useful_slots > 0) //if previous busy periods generated useful periods, record them.
					useful_period[useful_slots]++;
			
				useful_slots = 1; 	//reset useful slots to 1 that has just been accumulated
				
				if(busy_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					busy_slots = STAT_FILE_LENGTH-1;
				
				busy_period[busy_slots]++; //collect the accumulated busy slots as there now was an idle period
					
				busy_slots = 1; //reset busy slots to 1, as there was an idle period
		
				}
			else //more than one packet in buffer
				{
				if(useful_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					useful_slots=STAT_FILE_LENGTH-1;
			
				if(useful_slots > 0) //if previous busy periods generated useful periods, record them.
					useful_period[useful_slots]++;
				
				useful_slots = 0; //A collision occurs now, hence reset useful slots
				
				if(busy_slots > STAT_FILE_LENGTH) //check that statistics file columns are not exceeded
					busy_slots = STAT_FILE_LENGTH-1;
			
				busy_period[busy_slots]++; //collect the accumulated busy slots as there now was an idle period
			
				busy_slots = 1; //reset busy slots to one, as there was an idle period
			
		
				}
				
			}
		else //busy period continues
			{
			if(pkt_in_buffer == 1)
				{
					useful_slots++;
					busy_slots++;
					
				}
			else
				{
				if ((op_sim_time()-last_busy_timestamp) > (aMinLIFSPeriod/LR_WPAN_BIT_RATE)) //only the first function call in aBackoffBoundary updates busy

					busy_slots++;

				}
			}
		}
	
	else
		{
		printf("Uknown MAC protocol at %f with last_busy %f\n", op_sim_time(), last_busy_timestamp);
		}
		
	
	last_busy_timestamp = op_sim_time();
	
	FOUT;


}

/* End of Function Block */

/* Undefine optional tracing in FIN/FOUT/FRET */
/* The FSM has its own tracing code and the other */
/* functions should not have any tracing.		  */
#undef FIN_TRACING
#define FIN_TRACING

#undef FOUTRET_TRACING
#define FOUTRET_TRACING

#if defined (__cplusplus)
extern "C" {
#endif
	void lr_wpan_channel_PSMA_GADGET (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Obtype _op_lr_wpan_channel_PSMA_GADGET_init (int * init_block_ptr);
	void _op_lr_wpan_channel_PSMA_GADGET_diag (OP_SIM_CONTEXT_ARG_OPT);
	void _op_lr_wpan_channel_PSMA_GADGET_terminate (OP_SIM_CONTEXT_ARG_OPT);
	VosT_Address _op_lr_wpan_channel_PSMA_GADGET_alloc (VosT_Obtype, int);
	void _op_lr_wpan_channel_PSMA_GADGET_svar (void *, const char *, void **);


#if defined (__cplusplus)
} /* end of 'extern "C"' */
#endif




/* Process model interrupt handling procedure */


void
lr_wpan_channel_PSMA_GADGET (OP_SIM_CONTEXT_ARG_OPT)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	FIN_MT (lr_wpan_channel_PSMA_GADGET ());

		{


		FSM_ENTER ("lr_wpan_channel_PSMA_GADGET")

		FSM_BLOCK_SWITCH
			{
			/*---------------------------------------------------------*/
			/** state (Init) enter executives **/
			FSM_STATE_ENTER_UNFORCED_NOLABEL (0, "Init", "lr_wpan_channel_PSMA_GADGET [Init enter execs]")
				FSM_PROFILE_SECTION_IN ("lr_wpan_channel_PSMA_GADGET [Init enter execs]", state0_enter_exec)
				{
				/* get the ID of the current module */
				my_objid = op_id_self ();
				
				/* get the ID of the current node */
				my_node_objid = op_topo_parent (my_objid);
				
				/* init the process */
				wpan_channel_init ();
				
				/* create a self interuption to exit the initialize state */
				op_intrpt_schedule_self (op_sim_time (), 0);
				}
				FSM_PROFILE_SECTION_OUT (state0_enter_exec)

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (1,"lr_wpan_channel_PSMA_GADGET")


			/** state (Init) exit executives **/
			FSM_STATE_EXIT_UNFORCED (0, "Init", "lr_wpan_channel_PSMA_GADGET [Init exit execs]")


			/** state (Init) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Init", "Idle", "tr_10", "lr_wpan_channel_PSMA_GADGET [Init -> Idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (Idle) enter executives **/
			FSM_STATE_ENTER_UNFORCED (1, "Idle", state1_enter_exec, "lr_wpan_channel_PSMA_GADGET [Idle enter execs]")

			/** blocking after enter executives of unforced state. **/
			FSM_EXIT (3,"lr_wpan_channel_PSMA_GADGET")


			/** state (Idle) exit executives **/
			FSM_STATE_EXIT_UNFORCED (1, "Idle", "lr_wpan_channel_PSMA_GADGET [Idle exit execs]")
				FSM_PROFILE_SECTION_IN ("lr_wpan_channel_PSMA_GADGET [Idle exit execs]", state1_exit_exec)
				{
				/* get the type of the interruption */
				intrpt_type = op_intrpt_type ();
				
				switch (intrpt_type)
					{
					case OPC_INTRPT_STRM:
					intrpt_stream = op_intrpt_strm ();
					break;
					
					case OPC_INTRPT_SELF:
					intrpt_code = op_intrpt_code ();
					break;
					
					case OPC_INTRPT_ENDSIM:
					{
					printf ("CHANNEL: Minimum SNR = %f -- Maximum SNR = %f -- Average SNR = %f\n", min_snr, max_snr, (accumulate_snr/channel_buff_global_packet_count));
					
					channel_collect_stat();
					
					if(DEBUG_Channel)
						fclose(fp_channel_debug);
					
					break;
					}
				
				
					default:
					lr_wpan_chan_error ("Idle state:", "Unexpected interruption.", OPC_NIL);
					break;
					}
				}
				FSM_PROFILE_SECTION_OUT (state1_exit_exec)


			/** state (Idle) transition processing **/
			FSM_PROFILE_SECTION_IN ("lr_wpan_channel_PSMA_GADGET [Idle trans conditions]", state1_trans_conds)
			FSM_INIT_COND (PACKET_RECEIVED)
			FSM_TEST_COND (PACKET_TO_SEND)
			FSM_DFLT_COND
			FSM_TEST_LOGIC ("Idle")
			FSM_PROFILE_SECTION_OUT (state1_trans_conds)

			FSM_TRANSIT_SWITCH
				{
				FSM_CASE_TRANSIT (0, 2, state2_enter_exec, ;, "PACKET_RECEIVED", "", "Idle", "Pkt Rcv", "tr_1", "lr_wpan_channel_PSMA_GADGET [Idle -> Pkt Rcv : PACKET_RECEIVED / ]")
				FSM_CASE_TRANSIT (1, 3, state3_enter_exec, ;, "PACKET_TO_SEND", "", "Idle", "Send", "tr_3", "lr_wpan_channel_PSMA_GADGET [Idle -> Send : PACKET_TO_SEND / ]")
				FSM_CASE_TRANSIT (2, 1, state1_enter_exec, ;, "default", "", "Idle", "Idle", "tr_5", "lr_wpan_channel_PSMA_GADGET [Idle -> Idle : default / ]")
				}
				/*---------------------------------------------------------*/



			/** state (Pkt Rcv) enter executives **/
			FSM_STATE_ENTER_FORCED (2, "Pkt Rcv", state2_enter_exec, "lr_wpan_channel_PSMA_GADGET [Pkt Rcv enter execs]")
				FSM_PROFILE_SECTION_IN ("lr_wpan_channel_PSMA_GADGET [Pkt Rcv enter execs]", state2_enter_exec)
				{
				/* put the packet received in the channel buffer */
				lr_wpan_chan_buffer_insert ();
				}
				FSM_PROFILE_SECTION_OUT (state2_enter_exec)

			/** state (Pkt Rcv) exit executives **/
			FSM_STATE_EXIT_FORCED (2, "Pkt Rcv", "lr_wpan_channel_PSMA_GADGET [Pkt Rcv exit execs]")


			/** state (Pkt Rcv) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Pkt Rcv", "Idle", "tr_2", "lr_wpan_channel_PSMA_GADGET [Pkt Rcv -> Idle : default / ]")
				/*---------------------------------------------------------*/



			/** state (Send) enter executives **/
			FSM_STATE_ENTER_FORCED (3, "Send", state3_enter_exec, "lr_wpan_channel_PSMA_GADGET [Send enter execs]")
				FSM_PROFILE_SECTION_IN ("lr_wpan_channel_PSMA_GADGET [Send enter execs]", state3_enter_exec)
				{
				/* forward the packet and call the physical layer */
				lr_wpan_channel_pk_send ();
				}
				FSM_PROFILE_SECTION_OUT (state3_enter_exec)

			/** state (Send) exit executives **/
			FSM_STATE_EXIT_FORCED (3, "Send", "lr_wpan_channel_PSMA_GADGET [Send exit execs]")


			/** state (Send) transition processing **/
			FSM_TRANSIT_FORCE (1, state1_enter_exec, ;, "default", "", "Send", "Idle", "tr_4", "lr_wpan_channel_PSMA_GADGET [Send -> Idle : default / ]")
				/*---------------------------------------------------------*/



			}


		FSM_EXIT (0,"lr_wpan_channel_PSMA_GADGET")
		}
	}




void
_op_lr_wpan_channel_PSMA_GADGET_diag (OP_SIM_CONTEXT_ARG_OPT)
	{
	/* No Diagnostic Block */
	}




void
_op_lr_wpan_channel_PSMA_GADGET_terminate (OP_SIM_CONTEXT_ARG_OPT)
	{

	FIN_MT (_op_lr_wpan_channel_PSMA_GADGET_terminate ())


	/* No Termination Block */

	Vos_Poolmem_Dealloc (op_sv_ptr);

	FOUT
	}


/* Undefine shortcuts to state variables to avoid */
/* syntax error in direct access to fields of */
/* local variable prs_ptr in _op_lr_wpan_channel_PSMA_GADGET_svar function. */
#undef my_objid
#undef my_node_objid
#undef intrpt_type
#undef intrpt_stream
#undef intrpt_code
#undef channel_pkt_queue
#undef DEBUG_Channel
#undef buffer_size_handle
#undef buffer_size_pkts
#undef channel_pkt_forwarded
#undef channel_pkt_accepted
#undef channel_pkt_not_accepted
#undef N_occupied_slots
#undef last_time_inc_N_occ
#undef N_occupied_slots_PSMA
#undef capture_effect_enabled
#undef useful_slots
#undef busy_slots
#undef idle_slots
#undef last_busy_timestamp
#undef psma_enabled
#undef s_aloha_enabled
#undef awgn_enabled
#undef nakagami_enabled

#undef FIN_PREAMBLE_DEC
#undef FIN_PREAMBLE_CODE

#define FIN_PREAMBLE_DEC
#define FIN_PREAMBLE_CODE

VosT_Obtype
_op_lr_wpan_channel_PSMA_GADGET_init (int * init_block_ptr)
	{
	VosT_Obtype obtype = OPC_NIL;
	FIN_MT (_op_lr_wpan_channel_PSMA_GADGET_init (init_block_ptr))

	obtype = Vos_Define_Object_Prstate ("proc state vars (lr_wpan_channel_PSMA_GADGET)",
		sizeof (lr_wpan_channel_PSMA_GADGET_state));
	*init_block_ptr = 0;

	FRET (obtype)
	}

VosT_Address
_op_lr_wpan_channel_PSMA_GADGET_alloc (VosT_Obtype obtype, int init_block)
	{
#if !defined (VOSD_NO_FIN)
	int _op_block_origin = 0;
#endif
	lr_wpan_channel_PSMA_GADGET_state * ptr;
	FIN_MT (_op_lr_wpan_channel_PSMA_GADGET_alloc (obtype))

	ptr = (lr_wpan_channel_PSMA_GADGET_state *)Vos_Alloc_Object (obtype);
	if (ptr != OPC_NIL)
		{
		ptr->_op_current_block = init_block;
#if defined (OPD_ALLOW_ODB)
		ptr->_op_current_state = "lr_wpan_channel_PSMA_GADGET [Init enter execs]";
#endif
		}
	FRET ((VosT_Address)ptr)
	}



void
_op_lr_wpan_channel_PSMA_GADGET_svar (void * gen_ptr, const char * var_name, void ** var_p_ptr)
	{
	lr_wpan_channel_PSMA_GADGET_state		*prs_ptr;

	FIN_MT (_op_lr_wpan_channel_PSMA_GADGET_svar (gen_ptr, var_name, var_p_ptr))

	if (var_name == OPC_NIL)
		{
		*var_p_ptr = (void *)OPC_NIL;
		FOUT
		}
	prs_ptr = (lr_wpan_channel_PSMA_GADGET_state *)gen_ptr;

	if (strcmp ("my_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_objid);
		FOUT
		}
	if (strcmp ("my_node_objid" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->my_node_objid);
		FOUT
		}
	if (strcmp ("intrpt_type" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_type);
		FOUT
		}
	if (strcmp ("intrpt_stream" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_stream);
		FOUT
		}
	if (strcmp ("intrpt_code" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->intrpt_code);
		FOUT
		}
	if (strcmp ("channel_pkt_queue" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_pkt_queue);
		FOUT
		}
	if (strcmp ("DEBUG_Channel" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->DEBUG_Channel);
		FOUT
		}
	if (strcmp ("buffer_size_handle" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->buffer_size_handle);
		FOUT
		}
	if (strcmp ("buffer_size_pkts" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->buffer_size_pkts);
		FOUT
		}
	if (strcmp ("channel_pkt_forwarded" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_pkt_forwarded);
		FOUT
		}
	if (strcmp ("channel_pkt_accepted" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_pkt_accepted);
		FOUT
		}
	if (strcmp ("channel_pkt_not_accepted" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->channel_pkt_not_accepted);
		FOUT
		}
	if (strcmp ("N_occupied_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->N_occupied_slots);
		FOUT
		}
	if (strcmp ("last_time_inc_N_occ" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_time_inc_N_occ);
		FOUT
		}
	if (strcmp ("N_occupied_slots_PSMA" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->N_occupied_slots_PSMA);
		FOUT
		}
	if (strcmp ("capture_effect_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->capture_effect_enabled);
		FOUT
		}
	if (strcmp ("useful_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->useful_slots);
		FOUT
		}
	if (strcmp ("busy_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->busy_slots);
		FOUT
		}
	if (strcmp ("idle_slots" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->idle_slots);
		FOUT
		}
	if (strcmp ("last_busy_timestamp" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->last_busy_timestamp);
		FOUT
		}
	if (strcmp ("psma_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->psma_enabled);
		FOUT
		}
	if (strcmp ("s_aloha_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->s_aloha_enabled);
		FOUT
		}
	if (strcmp ("awgn_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->awgn_enabled);
		FOUT
		}
	if (strcmp ("nakagami_enabled" , var_name) == 0)
		{
		*var_p_ptr = (void *) (&prs_ptr->nakagami_enabled);
		FOUT
		}
	*var_p_ptr = (void *)OPC_NIL;

	FOUT
	}

